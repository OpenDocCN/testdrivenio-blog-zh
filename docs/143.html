<html>
<head>
<title>HTML Over WebSockets </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>网络套接字上的超文本标记语言</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/html-over-websockets/#0001-01-01">https://testdriven.io/blog/html-over-websockets/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>本文着眼于实现单页面应用程序(SPA)的新方法——基于WebSockets的HTML。</p>
<blockquote>
<p>本文由<a href="https://programadorwebvalencia.com/html-sobre-websockets/">原文</a>西班牙语版本翻译改编而成。</p>
</blockquote>



<h2 id="what-is-it">这是什么？</h2>
<p>实现单页面应用程序(SPA)的传统方法是在后端和前端之间划分职责:</p>
<ul>
<li>后端通过JSON RESTful API提供信息</li>
<li>前端通过API调用从后端异步获取数据</li>
</ul>
<p>不幸的是，这种模式成本很高，需要两个专门的开发人员配置文件，并且由于您必须开发和维护两个不同的应用程序(通常使用两种不同的语言)，因此会减慢发布周期。这也使得快速原型制作和SEO变得困难。自21世纪初以来，这种模式一直占据主导地位。为了交付具有桌面应用外观和感觉的web应用，这是我们必须付出的代价。然而，这种情况正在开始改变，因为许多团队认识到收益不会超过成本，并且正在尝试交付SPA的新模式。一种开始流行的模式是通过WebSocket提供HTML而不是JSON。</p>
<h2 id="how-does-it-work">它是如何工作的？</h2>
<p><a href="http://chrismccord.com/">Chris MC cord</a>,<a href="https://www.phoenixframework.org/">Phoenix</a>(<a href="https://elixir-lang.org/">Elixir</a>生态系统中最受欢迎的框架)的创建者，在<a href="https://www.youtube.com/watch?v=txk4WAlabvI"> ElixirConf 2019 </a>上展示了一项名为<a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html"> LiveView </a>的技术，该技术通过WebSockets提供HTML服务。不久之后，他<a href="https://www.phoenixframework.org/blog/build-a-real-time-twitter-clone-in-15-minutes-with-live-view-and-phoenix-1-5">演示了</a>如何在不使用React、Angular或Vue等客户端JavaScript框架的情况下，用LiveView在15分钟内构建一个实时Twitter克隆。他展示了从后端框架交付一个流畅的实时UI是可能的。这启发了其他开发人员使用其他语言和web框架创建自己的实现。</p>
<p>McCord的解决方案是通过WebSockets将HTML而不是JSON发送到前端。这种方法不仅简化了开发，而且性能也得到了很好的提升，因为呈现逻辑由后端处理，前端不需要发出任何新的HTTP请求来获取新数据。</p>
<h3 id="traditional-approach">传统方法</h3>
<p>同样，使用这种方法，浏览器首先从前端发出一个HTTP请求，获得一个带有原始的、预处理过的信息的JSON响应。然后前端负责处理信息并创建相应的HTML。</p>
<p><img data-src="/static/images/blog/html-over-websockets/traditional_spa.jpg" loading="lazy" class="lazyload" alt="Traditional SPA Approach" src="../Images/6c7a98305a0a19edaeb65b3b3842858f.png" data-original-src="https://testdriven.io/static/images/blog/html-over-websockets/traditional_spa.jpg"/></p>
<h3 id="html-over-websockets-approach">基于WebSockets方法的HTML</h3>
<p>使用这种方法，浏览器或服务器可以开始工作，因为WebSockets提供双向通信。</p>
<p><img data-src="/static/images/blog/html-over-websockets/websocket_spa.jpg" loading="lazy" class="lazyload" alt="WebSocket SPA Approach" src="../Images/2793ce9ab8c52c5128474f3d69c882eb.png" data-original-src="https://testdriven.io/static/images/blog/html-over-websockets/websocket_spa.jpg"/></p>
<h3 id="example">例子</h3>
<p>让我们看一个显示博客文章的快速例子。</p>
<ol>
<li>
<p><strong>连接</strong>:我们从一个连接开始。WebSockets支持客户端和服务器之间的双向通信，您只需建立一次。</p>
<p><img data-src="/static/images/blog/html-over-websockets/websocket_example_1.jpg" loading="lazy" class="lazyload" alt="WebSocket Example - establish connection" src="../Images/cc0bd213caf2be1d13668d7bb36a351a.png" data-original-src="https://testdriven.io/static/images/blog/html-over-websockets/websocket_example_1.jpg"/></p>
</li>
<li>
<p><strong>组件请求</strong>:客户端请求与<code>/article/2</code>路线相关联的特定文章的内容。</p>
<p><img data-src="/static/images/blog/html-over-websockets/websocket_example_2.jpg" loading="lazy" class="lazyload" alt="WebSocket Example - request article" src="../Images/14a4ade01c7f763b52e38e1449e7539c.png" data-original-src="https://testdriven.io/static/images/blog/html-over-websockets/websocket_example_2.jpg"/></p>
</li>
<li>
<p><strong>后端逻辑</strong>:服务器为模板生成相关的HTML、CSS、JavaScript，使用模板系统(比如Jinja)，通过WebSocket通道返回模板片段。</p>
<p><img data-src="/static/images/blog/html-over-websockets/websocket_example_3.jpg" loading="lazy" class="lazyload" alt="WebSocket Example - generate template" src="../Images/fbc96c68165b00ac87336f34dc3a7a3f.png" data-original-src="https://testdriven.io/static/images/blog/html-over-websockets/websocket_example_3.jpg"/></p>
</li>
<li>
<p><strong>更新DOM </strong>:最后前端用模板片段更新DOM，显示博客文章。</p>
</li>
</ol>
<h2 id="django-demo">Django演示</h2>
<p>我用<a href="https://www.djangoproject.com/"> Django </a>创建了一个HTML over WebSockets方法的原型，它使用<a href="https://channels.readthedocs.io/en/stable/"> Django通道</a>来支持WebSocket。这个应用程序本身相当简单。它只是一个有文章和评论的博客。也就是说，这是一个完整的SPA，所以页面更改不需要页面刷新。</p>
<p><img data-src="https://github.com/testdrivenio/demo-HTML-over-WebSockets-in-Django/raw/main/demo.gif" loading="lazy" class="lazyload" alt="demo" src="../Images/3e9312e02b4982636d8eacf65d746610.png" data-original-src="https://github.com/testdrivenio/demo-HTML-over-WebSockets-in-Django/raw/main/demo.gif"/></p>
<p>你可以在这里看到WebSockets的威力:</p>
<p><img data-src="https://github.com/testdrivenio/demo-HTML-over-WebSockets-in-Django/raw/main/demo-v2.gif" loading="lazy" class="lazyload" alt="demo" src="../Images/2313ccfd330f0f8fc4cc9a68eae0fac1.png" data-original-src="https://github.com/testdrivenio/demo-HTML-over-WebSockets-in-Django/raw/main/demo-v2.gif"/></p>
<p>你可以在<a href="https://github.com/tanrax/demo-HTML-over-WebSockets-in-Django"> GitHub </a>上找到代码。</p>
<h2 id="benefits-and-drawbacks">优点和缺点</h2>
<p>好处:</p>
<ol>
<li>HTML呈现/处理只发生在后端</li>
<li>实时</li>
<li>WebSockets协议比HTTP快</li>
<li>使用<a href="https://browsee.io/blog/websocket-vs-http-calls-performance-study/">慢速连接</a>工作</li>
<li>几乎不用任何JavaScript就能创建一个SPA</li>
<li>简单的搜索引擎优化</li>
</ol>
<p>缺点:</p>
<ol>
<li>服务器需要更多的资源，因为您必须为每个客户端打开一个WebSocket</li>
<li>新生的生态系统——很少的框架、教程和文档</li>
</ol>
<h2 id="resources">资源</h2>
<p>您可以从以下资源开始:</p>
<ol>
<li>Web软件的未来是HTML-over-WebSockets</li>
<li><a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html">凤凰城现场直播</a></li>
<li>Hotwire  -通过网络发送HTML来构建现代网络应用</li>
<li>反应器-Django的实时视图库</li>
<li><a href="https://github.com/jonathan-s/django-sockpuppet">sock puppet</a>——使用您已经了解并喜爱的Django工具构建反应式应用程序</li>
<li><a href="https://guides.rubyonrails.org/action_cable_overview.html">Action Cable</a>——将WebSockets与你的Ruby和Rails应用程序的其余部分无缝集成</li>
<li>用Ruby和Rails构建快速、可靠的实时应用</li>
</ol>
<h2 id="conclusion">结论</h2>
<p>虽然这种方法仍然很新，但值得一看。采用在增长，每个月都有越来越多的工具和例子出现。就我个人而言，我对它如此鲜为人知感到惊讶。我想这与JavaScript生态系统的强大有很大关系。</p>
  </div>

  </div>    
</body>
</html>