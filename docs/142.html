<html>
<head>
<title>Testing in Python </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Python测试</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/testing-python/#0001-01-01">https://testdriven.io/blog/testing-python/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>自动化测试一直是软件开发中的热门话题，但在持续集成和微服务时代，它被谈论得更多。有许多工具可以帮助您在Python项目中编写、运行和评估测试。让我们来看看其中的几个。</p>
<blockquote>
<p>本文是<a href="/guides/complete-python/">完整Python </a>指南的一部分:</p>
<ol>
<li><a href="/blog/python-environments/">现代Python环境——依赖性和工作空间管理</a></li>
<li><a href="/blog/testing-python/">Python中的测试</a>(本文！)</li>
<li><a href="/blog/modern-tdd/">Python中的现代测试驱动开发</a></li>
<li><a href="/blog/python-code-quality/"> Python代码质量</a></li>
<li><a href="/blog/python-type-checking/"> Python类型检查</a></li>
<li><a href="/blog/documenting-python/">记录Python代码和项目</a></li>
<li><a href="/blog/python-project-workflow/"> Python项目工作流程</a></li>
</ol>
</blockquote>



<h2 id="pytest">pytest</h2>
<p>虽然Python标准库附带了一个名为“nittest”的单元测试框架，但是<a href="https://docs.pytest.org/"> pytest </a>是测试Python代码的首选测试框架。</p>
<p>pytest让它变得简单(而且有趣！)来编写、组织和运行测试。与Python标准库中的unittest相比，pytest:</p>
<ol>
<li>需要更少的样板代码，因此您的测试套件将更具可读性。</li>
<li>支持简单的<code>assert</code>语句，与unittest中的<code>assertSomething</code>方法——如<code>assertEquals</code>、<code>assertTrue</code>和<code>assertContains</code>——相比，它可读性更好，也更容易记住。</li>
<li>更新更频繁，因为它不是Python标准库的一部分。</li>
<li>通过夹具系统简化测试状态的设置和拆除。</li>
<li>使用功能方法。</li>
</ol>
<p>另外，使用pytest，您可以在所有Python项目中保持一致的风格。假设您的堆栈中有两个web应用程序——一个用Django构建，另一个用Flask构建。如果没有pytest，您很可能会利用Django测试框架以及Flask扩展，如Flask-Testing。所以，你的测试套件会有不同的风格。另一方面，使用pytest，两个测试套件将具有一致的风格，使得从一个跳到另一个更加容易。</p>
<p>pytest也有一个大型的、由社区维护的插件生态系统。</p>
<p>一些例子:</p>
<ul>
<li>pytest-django  -提供了一套专门用于测试django应用程序的工具</li>
<li>pytest-xdist  -用于并行运行测试</li>
<li>添加代码覆盖支持</li>
<li><a href="https://github.com/pytest-dev/pytest-instafail"> pytest-instafail </a> -立即显示故障和错误，而不是等到运行结束</li>
</ul>
<blockquote>
<p>要查看完整的插件列表，请查看文档中的<a href="https://docs.pytest.org/en/latest/reference/plugin_list.html">插件列表</a>。</p>
</blockquote>
<h2 id="mocking">嘲弄的</h2>
<p>自动化测试应该是快速的、隔离的/独立的、确定的/可重复的。因此，如果您需要测试向第三方API发出外部HTTP请求的代码，您应该真正模拟该请求。为什么？如果你不知道，那么具体的测试将会是-</p>
<ol>
<li>速度慢，因为它通过网络发出HTTP请求</li>
<li>取决于第三方服务和网络本身的速度</li>
<li>不确定性，因为根据API的响应，测试可能会产生不同的结果</li>
</ol>
<blockquote>
<p>模仿其他长时间运行的操作也是一个好主意，比如数据库查询和异步任务，因为自动化测试通常会在每次提交到源代码控制时频繁运行。</p>
</blockquote>
<p>模仿是指在运行时用模仿对象替换真实对象的行为。因此，当被模仿的方法被调用时，我们只是返回一个预期的响应，而不是通过网络发送一个真正的HTTP请求。</p>
<p>例如:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">requests</span>


<span class="k">def</span> <span class="nf">get_my_ip</span><span class="p">():</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s1">'http://ipinfo.io/json'</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s1">'ip'</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_get_my_ip</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">my_ip</span> <span class="o">=</span> <span class="s1">'123.123.123.123'</span>

    <span class="k">class</span> <span class="nc">MockResponse</span><span class="p">:</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_body</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">json_body</span> <span class="o">=</span> <span class="n">json_body</span>

        <span class="k">def</span> <span class="nf">json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_body</span>

    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span>
        <span class="n">requests</span><span class="p">,</span>
        <span class="s1">'get'</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">MockResponse</span><span class="p">({</span><span class="s1">'ip'</span><span class="p">:</span> <span class="n">my_ip</span><span class="p">})</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">get_my_ip</span><span class="p">()</span> <span class="o">==</span> <span class="n">my_ip</span>
</code></pre></div>

<p>这里发生了什么事？</p>
<p>我们使用pytest的<a href="https://docs.pytest.org/en/stable/monkeypatch.html"> monkeypatch </a> fixture将所有从<code>requests</code>模块对<code>get</code>方法的调用替换为总是返回<code>MockedResponse</code>实例的<code>lambda</code>回调。</p>
<blockquote>
<p>我们使用一个对象，因为<code>requests</code>返回一个<a href="https://requests.readthedocs.io/en/latest/api/#requests.Response">响应</a>对象。</p>
</blockquote>
<p>我们可以用来自<code>unittest.mock</code>模块的<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.create_autospec"> create_autospec </a>方法来简化测试。该方法创建一个模拟对象，该对象具有与作为参数传递的对象相同的属性和方法:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">mock</span>

<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">requests</span> <span class="kn">import</span> <span class="n">Response</span>


<span class="k">def</span> <span class="nf">get_my_ip</span><span class="p">():</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s1">'http://ipinfo.io/json'</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s1">'ip'</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_get_my_ip</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">my_ip</span> <span class="o">=</span> <span class="s1">'123.123.123.123'</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">create_autospec</span><span class="p">(</span><span class="n">Response</span><span class="p">)</span>
    <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'ip'</span><span class="p">:</span> <span class="n">my_ip</span><span class="p">}</span>

    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span>
        <span class="n">requests</span><span class="p">,</span>
        <span class="s1">'get'</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">response</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">get_my_ip</span><span class="p">()</span> <span class="o">==</span> <span class="n">my_ip</span>
</code></pre></div>

<p>尽管pytest推荐使用monkeypatch方法进行模仿，但是标准库中的<a href="https://github.com/pytest-dev/pytest-mock/"> pytest-mock </a>扩展和普通的<a href="https://docs.python.org/3/library/unittest.mock.html"> unittest.mock </a>库也是不错的方法。</p>
<h2 id="code-coverage">代码覆盖率</h2>
<p>测试的另一个重要方面是代码覆盖率。这是一个指标，它告诉你在测试运行期间执行的行数与你的代码库中所有行的总数之间的比率。为此，我们可以使用pytest-cov插件，它集成了pytest和T2的覆盖率。</p>
<p>安装后，要运行覆盖报告测试，添加<code>--cov</code>选项，如下所示:</p>
<div class="codehilite"><pre><span/><code>$ python -m pytest --cov<span class="o">=</span>.
</code></pre></div>

<p>它将产生如下输出:</p>
<div class="codehilite"><pre><span/><code><span class="o">==================================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">==================================</span>
platform linux -- Python <span class="m">3</span>.7.9, pytest-5.4.3, py-1.9.0, pluggy-0.13.1
rootdir: /home/johndoe/sample-project
plugins: cov-2.10.1
collected <span class="m">6</span> items

tests/test_sample_project.py ....                                             <span class="o">[</span> <span class="m">66</span>%<span class="o">]</span>
tests/test_sample_project_mock.py .                                           <span class="o">[</span> <span class="m">83</span>%<span class="o">]</span>
tests/test_sample_project_mock_1.py .                                         <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

----------- coverage: platform linux, python <span class="m">3</span>.7.9-final-0 -----------
Name                                  Stmts   Miss  Cover
---------------------------------------------------------
sample_project/__init__.py                <span class="m">1</span>      <span class="m">1</span>     <span class="m">0</span>%
tests/__init__.py                         <span class="m">0</span>      <span class="m">0</span>   <span class="m">100</span>%
tests/test_sample_project.py              <span class="m">5</span>      <span class="m">0</span>   <span class="m">100</span>%
tests/test_sample_project_mock.py        <span class="m">13</span>      <span class="m">0</span>   <span class="m">100</span>%
tests/test_sample_project_mock_1.py      <span class="m">12</span>      <span class="m">0</span>   <span class="m">100</span>%
---------------------------------------------------------
TOTAL                                    <span class="m">31</span>      <span class="m">1</span>    <span class="m">97</span>%


<span class="o">==================================</span>  <span class="m">6</span> passed <span class="k">in</span> <span class="m">0</span>.13s <span class="o">==================================</span>
</code></pre></div>

<p>对于项目路径中的每个文件，您将获得:</p>
<ul>
<li>Stmts -代码行数</li>
<li>miss——测试没有执行的行数</li>
<li>Cover -文件的覆盖率</li>
</ul>
<p>在底部，有一行是整个项目的总数。</p>
<p>请记住，尽管鼓励实现高覆盖率，但这并不意味着你的测试是好的测试，测试你代码的每一条快乐和异常路径。例如，使用像<code>assert sum(3, 2) == 5</code>这样的断言的测试可以达到很高的覆盖率，但是你的代码实际上仍然没有经过测试，因为异常路径没有被覆盖。</p>
<h2 id="mutation-testing">突变测试</h2>
<p>变异测试有助于确保您的测试实际上覆盖了代码的全部行为。换句话说，它分析测试套件的有效性或健壮性。在突变测试过程中，一个工具会遍历源代码的每一行，做出一些小的改变(称为突变)来破坏你的代码。在每一次变异之后，该工具都会运行您的单元测试，并检查您的测试是否失败。如果您的测试仍然通过，那么您的代码没有通过变异测试。</p>
<p>例如，假设您有以下代码:</p>
<div class="codehilite"><pre><span/><code><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">50</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">100</span>
</code></pre></div>

<p>变异工具可能会将运算符从<code>&gt;</code>改为<code>&gt;=</code>，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">50</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">100</span>
</code></pre></div>

<p>mutmut是Python的一个变异测试库。让我们看看它的运行情况。</p>
<p>假设您有下面的<code>Loan</code>类:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># loan.py</span>

<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>


<span class="k">class</span> <span class="nc">LoanStatus</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
    <span class="n">PENDING</span> <span class="o">=</span> <span class="s2">"PENDING"</span>
    <span class="n">ACCEPTED</span> <span class="o">=</span> <span class="s2">"ACCEPTED"</span>
    <span class="n">REJECTED</span> <span class="o">=</span> <span class="s2">"REJECTED"</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Loan</span><span class="p">:</span>
    <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">LoanStatus</span> <span class="o">=</span> <span class="n">LoanStatus</span><span class="o">.</span><span class="n">PENDING</span>

    <span class="k">def</span> <span class="nf">reject</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">LoanStatus</span><span class="o">.</span><span class="n">REJECTED</span>

    <span class="k">def</span> <span class="nf">rejected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">LoanStatus</span><span class="o">.</span><span class="n">REJECTED</span>
</code></pre></div>

<p>现在，假设您想要自动拒绝超过250，000的贷款请求:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># reject_loan.py</span>

<span class="k">def</span> <span class="nf">reject_loan</span><span class="p">(</span><span class="n">loan</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">loan</span><span class="o">.</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">250_000</span><span class="p">:</span>
        <span class="n">loan</span><span class="o">.</span><span class="n">reject</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">loan</span>
</code></pre></div>

<p>然后，您编写了以下测试:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># test_reject_loan.py</span>

<span class="kn">from</span> <span class="nn">loan</span> <span class="kn">import</span> <span class="n">Loan</span>
<span class="kn">from</span> <span class="nn">reject_loan</span> <span class="kn">import</span> <span class="n">reject_loan</span>


<span class="k">def</span> <span class="nf">test_reject_loan</span><span class="p">():</span>
    <span class="n">loan</span> <span class="o">=</span> <span class="n">Loan</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">100_000</span><span class="p">)</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="n">reject_loan</span><span class="p">(</span><span class="n">loan</span><span class="p">)</span><span class="o">.</span><span class="n">rejected</span><span class="p">()</span>
</code></pre></div>

<p>当你用mutmut进行突变测试时，你会看到你有两个存活的突变体:</p>
<div class="codehilite"><pre><span/><code>$ mutmut run --paths-to-mutate reject_loan.py --tests-dir<span class="o">=</span>.

- Mutation testing starting -

These are the steps:
<span class="m">1</span>. A full <span class="nb">test</span> suite run will be made to make sure we
   can run the tests successfully and we know how long
   it takes <span class="o">(</span>to detect infinite loops <span class="k">for</span> example<span class="o">)</span>
<span class="m">2</span>. Mutants will be generated and checked

Results are stored <span class="k">in</span> .mutmut-cache.
Print found mutants with <span class="sb">`</span>mutmut results<span class="sb">`</span>.

Legend <span class="k">for</span> output:
🎉 Killed mutants.   The goal is <span class="k">for</span> everything to end up <span class="k">in</span> this bucket.
⏰ Timeout.          Test suite took <span class="m">10</span> <span class="nb">times</span> as long as the baseline so were killed.
🤔 Suspicious.       Tests took a long time, but not long enough to be fatal.
🙁 Survived.         This means your tests needs to be expanded.
🔇 Skipped.          Skipped.

<span class="m">1</span>. Running tests without mutations
⠏ Running...Done

<span class="m">2</span>. Checking mutants
⠸ <span class="m">2</span>/2  🎉 <span class="m">0</span>  ⏰ <span class="m">0</span>  🤔 <span class="m">0</span>  🙁 <span class="m">2</span>  🔇 <span class="m">0</span>
</code></pre></div>

<p>你可以通过ID查看幸存的变种人:</p>
<div class="codehilite"><pre><span/><code>$ mutmut show <span class="m">1</span>

--- reject_loan.py
+++ reject_loan.py
@@ -1,7 +1,7 @@
 <span class="c1"># reject_loan.py</span>

 def reject_loan<span class="o">(</span>loan<span class="o">)</span>:
-    <span class="k">if</span> loan.amount &gt; 250_000:
+    <span class="k">if</span> loan.amount &gt;<span class="o">=</span> 250_000:
         loan.reject<span class="o">()</span>

     <span class="k">return</span> loan
</code></pre></div>

<div class="codehilite"><pre><span/><code>$ mutmut show <span class="m">2</span>

--- reject_loan.py
+++ reject_loan.py
@@ -1,7 +1,7 @@
 <span class="c1"># reject_loan.py</span>

 def reject_loan<span class="o">(</span>loan<span class="o">)</span>:
-    <span class="k">if</span> loan.amount &gt; 250_000:
+    <span class="k">if</span> loan.amount &gt; <span class="m">250001</span>:
         loan.reject<span class="o">()</span>

     <span class="k">return</span> loan
</code></pre></div>

<p>改进您的测试:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">loan</span> <span class="kn">import</span> <span class="n">Loan</span>
<span class="kn">from</span> <span class="nn">reject_loan</span> <span class="kn">import</span> <span class="n">reject_loan</span>


<span class="k">def</span> <span class="nf">test_reject_loan</span><span class="p">():</span>
    <span class="n">loan</span> <span class="o">=</span> <span class="n">Loan</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">100_000</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">reject_loan</span><span class="p">(</span><span class="n">loan</span><span class="p">)</span><span class="o">.</span><span class="n">rejected</span><span class="p">()</span>

    <span class="n">loan</span> <span class="o">=</span> <span class="n">Loan</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">250_001</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">reject_loan</span><span class="p">(</span><span class="n">loan</span><span class="p">)</span><span class="o">.</span><span class="n">rejected</span><span class="p">()</span>

    <span class="n">loan</span> <span class="o">=</span> <span class="n">Loan</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">250_000</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">reject_loan</span><span class="p">(</span><span class="n">loan</span><span class="p">)</span><span class="o">.</span><span class="n">rejected</span><span class="p">()</span>
</code></pre></div>

<p>如果你再次进行突变测试，你会发现没有突变存活下来:</p>
<div class="codehilite"><pre><span/><code>$ mutmut run --paths-to-mutate reject_loan.py --tests-dir<span class="o">=</span>.

- Mutation testing starting -

These are the steps:
<span class="m">1</span>. A full <span class="nb">test</span> suite run will be made to make sure we
   can run the tests successfully and we know how long
   it takes <span class="o">(</span>to detect infinite loops <span class="k">for</span> example<span class="o">)</span>
<span class="m">2</span>. Mutants will be generated and checked

Results are stored <span class="k">in</span> .mutmut-cache.
Print found mutants with <span class="sb">`</span>mutmut results<span class="sb">`</span>.

Legend <span class="k">for</span> output:
🎉 Killed mutants.   The goal is <span class="k">for</span> everything to end up <span class="k">in</span> this bucket.
⏰ Timeout.          Test suite took <span class="m">10</span> <span class="nb">times</span> as long as the baseline so were killed.
🤔 Suspicious.       Tests took a long time, but not long enough to be fatal.
🙁 Survived.         This means your tests needs to be expanded.
🔇 Skipped.          Skipped.

<span class="m">1</span>. Running tests without mutations
⠏ Running...Done

<span class="m">2</span>. Checking mutants
⠙ <span class="m">2</span>/2  🎉 <span class="m">2</span>  ⏰ <span class="m">0</span>  🤔 <span class="m">0</span>  🙁 <span class="m">0</span>  🔇 <span class="m">0</span>
</code></pre></div>

<p>现在您的测试更加健壮了。在<em> reject_loan.py </em>中的任何无意的改变都会导致测试失败。</p>
<blockquote>
<p>Python的变异测试工具不像其他一些工具那样成熟。比如<a href="https://github.com/mbj/mutant">突变体</a>就是Ruby的一个成熟的突变测试工具。要了解更多关于突变测试的知识，请在<a href="https://twitter.com/_m_b_j_">推特</a>上关注突变作者。</p>
</blockquote>
<p>与任何其他方法一样，突变测试也有一个权衡。虽然它提高了测试套件捕捉bug的能力，但它是以速度为代价的，因为您必须运行整个测试套件数百次。它也迫使你真正地测试一切。这有助于发现异常路径，但是您将有更多的测试用例需要维护。</p>
<h2 id="hypothesis">假设</h2>
<p><a href="https://hypothesis.readthedocs.io/en/latest/">假设</a>是在Python中进行<a href="https://hypothesis.works/articles/what-is-property-based-testing/">基于属性的测试</a>的库。基于属性的测试不需要为每一个你想要测试的参数编写不同的测试用例，它会生成大量的随机测试数据，这些数据依赖于之前的测试运行。这有助于增加测试套件的健壮性，同时减少测试冗余。简而言之，您的测试代码将会更干净、更简洁，并且总体上更高效，同时仍然覆盖了广泛的测试数据。</p>
<p>例如，假设您必须为以下函数编写测试:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div>

<p>您可以编写以下测试:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span>
    <span class="s1">'number, result'</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">101234</span><span class="p">,</span> <span class="mi">101235</span><span class="p">),</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_increment</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">increment</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">==</span> <span class="n">result</span>
</code></pre></div>

<p>这种方法没有错。您的代码已经过测试，代码覆盖率很高(准确地说是100%)。也就是说，基于可能的输入范围，您的代码测试得有多好？有相当多的整数可以测试，但是测试中只使用了其中的四个。在某些情况下，这就足够了。在其他情况下，四种情况是不够的——即非确定性机器学习代码。那些非常小或非常大的数字呢？或者假设您的函数接受一个整数列表而不是单个整数——如果这个列表是空的，或者它包含一个元素、数百个元素或数千个元素呢？在某些情况下，我们根本无法提供(更不用说甚至想出)所有可能的情况。这就是基于属性的测试发挥作用的地方。</p>
<blockquote>
<p>机器学习算法是基于属性的测试的一个很好的用例，因为很难为复杂的数据集产生(和维护)测试实例。</p>
</blockquote>
<p>像假说这样的框架提供了生成随机测试数据的方法(假说称之为<a href="https://hypothesis.readthedocs.io/en/latest/data.html?#core-strategies">策略</a>)。假设还存储以前测试运行的结果，并使用它们来创建新的案例。</p>
<blockquote>
<p>策略是基于输入数据的形状生成伪随机数据的算法。它是伪随机的，因为生成的数据是基于以前测试的数据。</p>
</blockquote>
<p>通过假设使用基于属性的测试的相同测试如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">hypothesis</span> <span class="kn">import</span> <span class="n">given</span>
<span class="kn">import</span> <span class="nn">hypothesis.strategies</span> <span class="k">as</span> <span class="nn">st</span>


<span class="nd">@given</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">integers</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">test_add_one</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">increment</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">==</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div>

<p><code>st.integers()</code>是一种假设策略，它生成用于测试的随机整数，而<code>@given</code>装饰器用于参数化测试函数。因此，当调用测试函数时，从策略中生成的整数将被传递到测试中。</p>
<div class="codehilite"><pre><span/><code>$ python -m pytest test_hypothesis.py --hypothesis-show-statistics

<span class="o">==================================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">===================================</span>
platform darwin -- Python <span class="m">3</span>.8.5, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /home/johndoe/sample-project
plugins: hypothesis-5.37.3
collected <span class="m">1</span> item

test_hypothesis.py .                                                               <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>
<span class="o">=================================</span> Hypothesis <span class="nv">Statistics</span> <span class="o">==================================</span>

test_hypothesis.py::test_add_one:

  - during generate phase <span class="o">(</span><span class="m">0</span>.06 seconds<span class="o">)</span>:
    - Typical runtimes: &lt; 1ms, ~ <span class="m">50</span>% <span class="k">in</span> data generation
    - <span class="m">100</span> passing examples, <span class="m">0</span> failing examples, <span class="m">0</span> invalid examples

  - Stopped because settings.max_examples<span class="o">=</span><span class="nv">100</span>


<span class="o">===================================</span> <span class="m">1</span> passed <span class="k">in</span> <span class="m">0</span>.08s <span class="o">====================================</span>
</code></pre></div>

<h2 id="type-checking">类型检查</h2>
<p>测试是代码，它们应该被如此对待。就像您的业务代码一样，您需要维护和重构它们。你甚至可能需要时不时地处理一些bug。正因为如此，保持你的测试简短、简单、直截了当是一个好习惯。您还应该注意不要过度测试您的代码。</p>
<p>运行时(或动态)类型的检查器，如<a href="https://typeguard.readthedocs.io/"> Typeguard </a>和<a href="https://pydantic-docs.helpmanual.io/"> pydantic </a>，可以帮助最小化测试的数量。让我们来看一个pydantic的例子。</p>
<p>例如，假设我们有一个只有一个属性的<code>User</code>，一个电子邮件地址:</p>
<div class="codehilite"><pre><span/><code><span class="k">class</span> <span class="nc">User</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">email</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span>


<span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s1">'<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bbd1d4d3d5fbdfd4de95d8d4d6">[email protected]</a>'</span><span class="p">)</span>
</code></pre></div>

<p>我们希望确保所提供的电子邮件确实是有效的电子邮件地址。因此，为了验证它，我们必须在某个地方添加一些助手代码。除了编写测试，我们还必须花时间为此编写正则表达式。pydantic可以帮助解决这个问题。我们可以用它来定义我们的<code>User</code>模型:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">EmailStr</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">email</span><span class="p">:</span> <span class="n">EmailStr</span>


<span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s1">'<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ddb7b2b5b39db9b2b8f3beb2b0">[email protected]</a>'</span><span class="p">)</span>
</code></pre></div>

<p>现在，在创建每个新的<code>User</code>实例之前，pydantic将验证email参数。当它不是一个有效的电子邮件-即<code>User(email='something')</code> -一个<a href="https://pydantic-docs.helpmanual.io/usage/models/#error-handling">验证错误</a>将被提出。这消除了编写我们自己的验证器的需要。我们也不需要测试它，因为pydantic <a href="https://github.com/samuelcolvin/pydantic/blob/ab671a36708a14017e2ccc62f72c9f7628628737/tests/test_types.py">的维护者为我们处理了</a>。</p>
<p>我们可以减少对任何用户提供的数据进行测试的次数。相反，我们只需要测试是否正确处理了<code>ValidationError</code>。</p>
<p>让我们看看Flask应用程序中的一个简单例子:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">uuid</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">jsonify</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">ValidationError</span><span class="p">,</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">EmailStr</span><span class="p">,</span> <span class="n">Field</span>


<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="n">ValidationError</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_validation_exception</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">errors</span><span class="p">())</span>
    <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">=</span> <span class="mi">400</span>
    <span class="k">return</span> <span class="n">response</span>


<span class="k">class</span> <span class="nc">Blog</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()))</span>
    <span class="n">author</span><span class="p">:</span> <span class="n">EmailStr</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div>

<p>测试:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">json</span>


<span class="k">def</span> <span class="nf">test_create_blog_bad_request</span><span class="p">(</span><span class="n">client</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN request data with invalid values or missing attributes</span>
<span class="sd">    WHEN endpoint /create-blog/ is called</span>
<span class="sd">    THEN it should return status 400 and JSON body</span>
<span class="sd">    """</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
        <span class="s1">'/create-blog/'</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span>
            <span class="p">{</span>
            <span class="s1">'author'</span><span class="p">:</span> <span class="s1">'John Doe'</span><span class="p">,</span>
            <span class="s1">'title'</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">'content'</span><span class="p">:</span> <span class="s1">'Some extra awesome content'</span>
        <span class="p">}</span>
        <span class="p">),</span>
        <span class="n">content_type</span><span class="o">=</span><span class="s1">'application/json'</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">400</span>
    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
</code></pre></div>

<h2 id="conclusion">结论</h2>
<p>测试常常让人觉得是一项令人畏惧的任务。总有这样的时候，但是希望这篇文章提供了一些工具，您可以使用它们来使测试变得更容易。将您的测试工作集中在减少古怪的测试上。你的测试也应该是快速的，隔离的/独立的，确定的/可重复的。最后，对您的测试套件有信心将帮助您更频繁地部署到生产环境中，更重要的是，有助于您晚上睡觉。</p>
<p>测试愉快！</p>
<blockquote>
<p><a href="/guides/complete-python/">完整Python </a>指南:</p>
<ol>
<li><a href="/blog/python-environments/">现代Python环境——依赖性和工作空间管理</a></li>
<li><a href="/blog/testing-python/">Python中的测试</a>(本文！)</li>
<li><a href="/blog/modern-tdd/">Python中的现代测试驱动开发</a></li>
<li><a href="/blog/python-code-quality/"> Python代码质量</a></li>
<li><a href="/blog/python-type-checking/"> Python类型检查</a></li>
<li><a href="/blog/documenting-python/">记录Python代码和项目</a></li>
<li><a href="/blog/python-project-workflow/"> Python项目工作流程</a></li>
</ol>
</blockquote>
  </div>

  </div>    
</body>
</html>