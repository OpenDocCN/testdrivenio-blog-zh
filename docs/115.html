<html>
<head>
<title>Deploying Django to AWS with Docker and Let's Encrypt </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Docker将Django部署到AWS，让我们加密</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/django-docker-https-aws/#0001-01-01">https://testdriven.io/blog/django-docker-https-aws/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>在本教程中，我们将使用Docker将Django应用程序部署到AWS EC2。该应用程序将运行在HTTPS Nginx代理后面，该代理使用Let's加密SSL证书。我们将使用AWS RDS来服务我们的Postgres数据库，并使用AWS ECR来存储和管理我们的Docker图像。</p>
<blockquote>
<p>姜戈码头系列:</p>
<ol>
<li><a href="/blog/dockerizing-django-with-postgres-gunicorn-and-nginx/">用Postgres、Gunicorn和Nginx将Django归档</a></li>
<li><a href="/blog/django-lets-encrypt/">用加密保护容器化的Django应用</a></li>
<li><a href="/blog/django-docker-https-aws/">用Docker把Django部署到AWS，让我们加密</a>(本文！)</li>
</ol>
</blockquote>



<h2 id="objectives">目标</h2>
<p>本教程结束时，您将能够:</p>
<ol>
<li>设置新的EC2实例</li>
<li>在EC2实例上安装Docker</li>
<li>配置和使用弹性IP地址</li>
<li>设置IAM角色</li>
<li>利用Amazon弹性容器注册(ECR)图像注册来存储构建的图像</li>
<li>为数据持久性配置AWS RDS</li>
<li>配置AWS安全组</li>
<li>使用Docker将Django部署到AWS EC2</li>
<li>在HTTPS Nginx代理后面运行Django应用程序，让我们加密SSL证书</li>
</ol>
<h2 id="prerequisites">先决条件</h2>
<p>这篇文章建立在用Postgres、Gunicorn和Nginx 和<a href="/blog/django-lets-encrypt/">保护容器化Django应用程序的基础上，用Let's Encrypt </a>文章。</p>
<p>它假设您可以:</p>
<ol>
<li>将Django应用与Postgres、Nginx和Gunicorn一起容器化。</li>
<li>用<a href="https://letsencrypt.org/">加密</a> SSL证书来保护运行在HTTPS Nginx代理后面的容器化Django应用。</li>
<li>使用SSH连接到远程服务器，使用SCP将文件复制到服务器。</li>
</ol>
<h2 id="aws-ec2">AWS EC2</h2>
<p>首先，创建一个<a href="https://portal.aws.amazon.com/billing/signup#/start"> AWS </a>账户，如果你还没有的话。</p>
<p>接下来，导航到<a href="https://console.aws.amazon.com/ec2/"> EC2控制台</a>并点击<strong>启动实例</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/ec2_home.png" loading="lazy" class="lazyload" alt="EC2 Home" src="../Images/7fa3db3278794149b916206902e87035.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_home.png"/></p>
<p>使用<strong>Ubuntu Server 18.04 LTS(HVM)</strong>作为服务器镜像(AMI):</p>
<p><img data-src="/static/images/blog/django/django-docker/ec2_select_AMI.png" loading="lazy" class="lazyload" alt="Select AMI" src="../Images/6b2d4dc42887ba12746c88a4ad9df0fa.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_select_AMI.png"/></p>
<p>在下一步中，坚持使用<strong> t2.micro </strong>实例。点击<strong>下一步:配置实例详情</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/ec2_instance_type.png" loading="lazy" class="lazyload" alt="EC2 instance type" src="../Images/0a94645b08e41e5c6f615251af6b6418.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_instance_type.png"/></p>
<p>在<strong>配置实例细节</strong>步骤，让一切保持原样以保持简单。然后点击<strong>下一步</strong>几次，直到你在<strong>配置安全组</strong>步骤。</p>
<p>选择<strong>创建新的安全组</strong>，将名称和描述设置为<code>django-ec2</code>，并添加两条规则:</p>
<ul>
<li>HTTP -&gt;任何地方</li>
<li>HTTPS -&gt;任何地方</li>
</ul>
<p><img data-src="/static/images/blog/django/django-docker/ec2_configure_security_groups.png" loading="lazy" class="lazyload" alt="EC2 configure security groups" src="../Images/99928034d5e322074f37afab53df67d6.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_configure_security_groups.png"/></p>
<p>颁发证书和访问应用程序需要这些规则。</p>
<blockquote>
<p>安全组<em>入站</em>规则用于限制从互联网对您的实例的访问。除非您有一些额外的安全需求，否则您可能希望允许来自任何地方的HTTP和HTTPS流量来托管web应用程序。为了设置和部署，必须允许SSH连接到实例。</p>
</blockquote>
<p>点击<strong>查看并启动</strong>。在下一个屏幕上，点击<strong>发射</strong>。</p>
<p>系统会提示您选择一个密钥对。您需要它来通过SSH连接到您的实例。选择<strong>创建一个新的密钥对</strong>，并将其命名为<code>djangoletsencrypt</code>。然后点击<strong>下载密钥对</strong>。下载密钥对后，点击<strong>启动实例</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/ec2_add_key_pair.png" loading="lazy" class="lazyload" alt="EC2 Add key pair" src="../Images/6fd887a1f80a156bf5429f7d7996c25d.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_add_key_pair.png"/></p>
<p>该实例将需要几分钟时间才能启动。</p>
<h2 id="configure-ec2-instance">配置EC2实例</h2>
<p>在本节中，我们将在实例上安装Docker，添加一个弹性IP，并配置一个IAM角色。</p>
<h3 id="install-docker">安装Docker</h3>
<p>导航回<a href="https://console.aws.amazon.com/ec2/"> EC2控制台</a>，选择新创建的实例，并获取公共IP地址:</p>
<p><img data-src="/static/images/blog/django/django-docker/ec2_public_ip.png" loading="lazy" class="lazyload" alt="EC2 Public IP" src="../Images/a654f3ea12f592c283656617685215e7.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_public_ip.png"/></p>
<p>使用我们在“AWS EC2”步骤中下载的<code>.pem</code>键连接到您的EC2实例。</p>


<blockquote>
<p>您的<code>.pem</code>可能被下载到了像~/Downloads/djangoletsencrypt . PEM这样的路径中。如果您不确定在哪里存储它，请将它移到<em> ~/中。ssh </em>目录。您可能还需要更改权限，即<code>chmod 400 -i /path/to/your/djangoletsencrypt.pem</code>。</p>
</blockquote>
<p>首先安装Docker的最新版本和Docker Compose的1.29.2版本:</p>
<div class="codehilite"><pre><span/><code>$ sudo apt update
$ sudo apt install apt-transport-https ca-certificates curl software-properties-common
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg <span class="p">|</span> sudo apt-key add -
$ sudo add-apt-repository <span class="s2">"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"</span>
$ sudo apt update
$ sudo apt install docker-ce
$ sudo usermod -aG docker <span class="si">${</span><span class="nv">USER</span><span class="si">}</span>
$ sudo curl -L <span class="s2">"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-</span><span class="k">$(</span>uname -s<span class="k">)</span><span class="s2">-</span><span class="k">$(</span>uname -m<span class="k">)</span><span class="s2">"</span> -o /usr/local/bin/docker-compose
$ sudo chmod +x /usr/local/bin/docker-compose

$ docker -v
Docker version <span class="m">20</span>.10.8, build 3967b7d

$ docker-compose -v
docker-compose version <span class="m">1</span>.29.2, build 5becea4c
</code></pre></div>

<h3 id="install-aws-cli">安装AWS CLI</h3>
<p>首先，安装unzip:</p>


<p>下载AWS CLI ZIP:</p>
<div class="codehilite"><pre><span/><code>$ curl <span class="s2">"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"</span> -o <span class="s2">"awscliv2.zip"</span>
</code></pre></div>

<p>解压缩其内容:</p>


<p>安装AWS CLI:</p>


<p>验证安装:</p>


<h3 id="elastic-ip">弹性IP</h3>
<p>默认情况下，实例每次启动和重新启动时都会收到新的公共IP地址。</p>
<p><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">弹性IP </a>允许您为EC2实例分配静态IP，因此IP始终保持不变，并且可以在实例之间重新关联。建议为您的生产设置使用一个。</p>
<p>导航到<a href="https://console.aws.amazon.com/ec2/v2/home?#Addresses">弹性IP</a>，点击<strong>分配弹性IP地址</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/elastic_ip.png" loading="lazy" class="lazyload" alt="Elastic IP" src="../Images/d1461447d678a95ed485382b8be143c5.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/elastic_ip.png"/></p>
<p>然后，点击<strong>分配</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/elastic_ip_allocate.png" loading="lazy" class="lazyload" alt="Elastic IP Allocate" src="../Images/d021b3398de4d38de2d20f8dca2dc9e3.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/elastic_ip_allocate.png"/></p>
<p>点击<strong>关联此弹性IP地址</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/elastic_ip_associate.png" loading="lazy" class="lazyload" alt="Elastic IP Associate" src="../Images/a9c8eea020de94ac3a288d41d237c7ac.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/elastic_ip_associate.png"/></p>
<p>选择您的实例并点击<strong>关联</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/elastic_ip_select_instance.png" loading="lazy" class="lazyload" alt="Elastic IP Select Instance" src="../Images/e6058561f7ecdabbf82caa4b6486e0f2.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/elastic_ip_select_instance.png"/></p>
<h3 id="iam-role">IAM角色</h3>
<p>在部署期间，我们将使用AWS ECR将图像从AWS ECR拉至我们的EC2实例。因为我们不允许公众访问ECR上的Docker映像，所以您需要创建一个IAM角色，该角色拥有从ECR中提取Docker映像并将其附加到EC2实例的权限。</p>
<p>导航到<a href="https://console.aws.amazon.com/iam/home#/home"> IAM控制台</a>。</p>
<p>点击左侧工具条中的<strong>角色</strong>，然后<strong>创建角色</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/iam_roles.png" loading="lazy" class="lazyload" alt="IAM Roles" src="../Images/df0763fbc4d351f611f0ab293bb02382.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/iam_roles.png"/></p>
<p>选择<strong> AWS服务</strong>和<strong> EC2 </strong>，然后点击<strong>下一步:权限</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/iam_use_case.png" loading="lazy" class="lazyload" alt="IAM Select Use Case" src="../Images/b650ca0feab8573f49effa643c932e23.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/iam_use_case.png"/></p>
<p>在搜索框中输入<code>container</code>，选择<strong>amazonec 2 containerregistrypoweruser</strong>策略，点击<strong>下一步:标签</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/iam_role_policy.png" loading="lazy" class="lazyload" alt="IAM Role Policy" src="../Images/4a860f4dbb435f0b4151e86d88a4e281.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/iam_role_policy.png"/></p>
<p>点击<strong>下一页:回顾</strong>。使用<code>django-ec2</code>作为名称，点击<strong>创建角色</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/iam_review_role.png" loading="lazy" class="lazyload" alt="IAM Role Review" src="../Images/18599849079f627f9e6c43ebc43ddc4f.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/iam_review_role.png"/></p>
<p>现在您需要将新角色附加到您的EC2实例。</p>
<p>回到<a href="https://console.aws.amazon.com/ec2/"> EC2控制台</a>，点击<strong>实例</strong>，然后选择你的实例。点击<strong>动作</strong>下拉菜单-&gt;T6】实例设置-&gt;T8】附加/替换IAM角色:</p>
<p><img data-src="/static/images/blog/django/django-docker/ec2_attach_role.png" loading="lazy" class="lazyload" alt="EC2 Attach IAM Role" src="../Images/6fb2ac1c6ab4c010e24d8ecc004d722c.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_attach_role.png"/></p>
<p>选择<strong> django-ec2 </strong>角色，然后点击<strong>应用</strong>。</p>
<p><img data-src="/static/images/blog/django/django-docker/ec2_select_iam_role.png" loading="lazy" class="lazyload" alt="EC2 Select IAM Role" src="../Images/5ca39e4c38e792228b7eb37e14a0b607.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_select_iam_role.png"/></p>
<p>点击<strong>关闭</strong>。</p>
<h2 id="add-dns-record">添加DNS记录</h2>
<p>为您正在使用的域向DNS添加一个A记录，以指向您的EC2实例的公共IP。</p>
<p>它是您关联到实例的弹性IP。</p>
<h2 id="aws-ecr">AWS ECR</h2>
<p><a href="https://aws.amazon.com/ecr/">Amazon Elastic Container Registry</a>(ECR)是一个完全托管的Docker图像注册表，可以让开发者轻松存储和管理图像。对于私有映像，通过IAM用户和角色来管理访问。</p>
<p>导航到<a href="https://console.aws.amazon.com/ecr/">集控室控制台</a>。点击工具条中的<strong>库</strong>，然后点击<strong>创建库</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/ecr_repositories.png" loading="lazy" class="lazyload" alt="ECR Repositories" src="../Images/853dafa6cd6960fe3212f7fe41ee3731.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ecr_repositories.png"/></p>
<p>将名称设置为<code>django-ec2</code>并点击<strong>创建存储库</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/ecr_create_repository.png" loading="lazy" class="lazyload" alt="ECR Create repository" src="../Images/a5f64750bd300542e3e3c4ea827d2327.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ecr_create_repository.png"/></p>
<h2 id="aws-rds">AWS RDS</h2>
<p>现在我们可以配置一个RDS Postgres数据库。</p>
<p>虽然您可以在容器中运行自己的Postgres数据库，但由于数据库是<a href="https://vsupalov.com/database-in-docker/">关键服务</a>，添加额外的层，如Docker，会增加生产中不必要的风险。为了简化次要版本更新、定期备份和扩展等任务，建议使用托管服务。所以，我们将使用<a href="https://aws.amazon.com/rds/"> RDS </a>。</p>
<p>导航至<a href="https://console.aws.amazon.com/rds/"> RDS控制台</a>。点击<strong>创建数据库</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/rds_home.png" loading="lazy" class="lazyload" alt="RDS Home" src="../Images/3474c461fa7bc03c68b7c93881d729c1.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/rds_home.png"/></p>
<p>使用<strong>自由层</strong>模板选择最新版本的Postgres:</p>
<p><img data-src="/static/images/blog/django/django-docker/rds_create_database.png" loading="lazy" class="lazyload" alt="RDS Create database" src="../Images/d80db1e01e27591e2fefcc2551dbf7f9.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/rds_create_database.png"/></p>
<p>在<strong>设置</strong>下，设置:</p>
<ul>
<li>数据库实例标识符:<code>djangoec2</code></li>
<li>主用户名:<code>webapp</code></li>
<li>选择<strong>自动生成密码</strong></li>
</ul>
<p>坚持使用默认设置:</p>
<ul>
<li>数据库实例大小</li>
<li>储存；储备</li>
<li>可用性和耐用性</li>
</ul>
<p>跳到<strong>连接</strong>部分，设置以下内容:</p>
<ul>
<li>虚拟私有云(VPC):默认</li>
<li>子网组:默认</li>
<li>可公开访问:否</li>
<li>VPC安全组:<code>django-ec2</code></li>
<li>数据库端口:5432</li>
</ul>
<p><img data-src="/static/images/blog/django/django-docker/rds_connectivity.png" loading="lazy" class="lazyload" alt="RDS Create database connectivity" src="../Images/5d0dbaf7eff16c9ea2a5be7dc71ff4ae.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/rds_connectivity.png"/></p>
<p>让<strong>数据库认证</strong>保持原样。</p>
<p>打开<strong>附加配置</strong>，将<strong>初始数据库名称</strong>改为<code>djangoec2</code>:</p>
<p><img data-src="/static/images/blog/django/django-docker/rds_initial_db_name.png" loading="lazy" class="lazyload" alt="RDS Create database initial DB name" src="../Images/e089d96275b3cdaa1c90446809231718.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/rds_initial_db_name.png"/></p>
<p>保持其他设置不变。</p>
<p>最后，点击<strong>创建数据库</strong>。</p>
<p>点击<strong>查看凭证详情</strong>查看为<strong> webapp </strong>用户生成的密码:</p>
<p><img data-src="/static/images/blog/django/django-docker/rds_view_credentials.png" loading="lazy" class="lazyload" alt="RDS View credentials" src="../Images/ad8f4acbea91e2a9f108ea143bf5c468.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/rds_view_credentials.png"/></p>
<p>请将此密码存放在安全的地方。您需要在这里将它提供给Django应用程序。</p>
<p>该实例将需要几分钟的时间才能启动。启动后，单击新创建的数据库的DB标识符以查看其详细信息。记下数据库端点；你需要在你的Django应用中设置它。</p>
<p><img data-src="/static/images/blog/django/django-docker/rds_db_details.png" loading="lazy" class="lazyload" alt="RDS DB details" src="../Images/0c44001850b06c11eca9b1de45f50d79.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/rds_db_details.png"/></p>
<h2 id="aws-security-group">AWS安全组</h2>
<p>在<a href="https://console.aws.amazon.com/ec2/"> EC2控制台</a>中，点击侧边栏中的<strong>安全组</strong>。找到并点击<strong> django-ec2 </strong>组的ID以编辑其详细信息。</p>
<p>点击<strong>编辑入站规则</strong>:</p>
<p><img data-src="/static/images/blog/django/django-docker/ec2_edit_security_group.png" loading="lazy" class="lazyload" alt="EC2 Security Group Details" src="../Images/0c2c8686a7a4001452d83a3f6b9b72f6.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_edit_security_group.png"/></p>
<p>添加允许Postgres连接到该安全组内实例的入站规则。为此:</p>
<ul>
<li>点击<strong>添加规则</strong></li>
<li>为规则类型选择<strong> PostgreSQL </strong></li>
<li>为规则源选择<strong>自定义</strong></li>
<li>点击搜索字段并选择<strong> django-ec2 </strong>安全组</li>
<li>点击<strong>保存规则</strong></li>
</ul>
<blockquote>
<p>为了限制对数据库的访问，只允许来自同一个安全组内的实例的连接。我们的应用程序可以连接，因为我们为RDS和ec2实例设置了相同的安全组<em> django-ec2 </em>。因此，不允许其他安全组中的实例进行连接。</p>
</blockquote>
<p><img data-src="/static/images/blog/django/django-docker/ec2_edit_inbound_rules.png" loading="lazy" class="lazyload" alt="EC2 Edit inbound rules" src="../Images/734213f01df327128df5dab09d4c3ea7.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ec2_edit_inbound_rules.png"/></p>
<h2 id="project-config">项目配置</h2>
<p>随着AWS基础设施的建立，我们现在需要在部署Django项目之前在本地配置它。</p>
<p>首先，克隆GitHub项目报告的内容:</p>
<div class="codehilite"><pre><span/><code>$ git clone https://github.com/testdrivenio/django-on-docker-letsencrypt django-on-docker-letsencrypt-aws
$ <span class="nb">cd</span> django-on-docker-letsencrypt-aws
</code></pre></div>

<p>这个库包含了部署Dockerized Django和加密HTTPS证书所需的一切。</p>
<h3 id="docker-compose">复合坞站</h3>
<p>首次部署应用程序时，您应该遵循以下两个步骤来避免证书问题:</p>
<ol>
<li>首先从Let's Encrypt的登台环境中颁发证书</li>
<li>然后，当一切按预期运行时，切换到Let's Encrypt的生产环境</li>
</ol>
<blockquote>
<p>你可以在上一篇文章<a href="/blog/django-lets-encrypt/">的</a><a href="/blog/django-lets-encrypt/#lets-encrypt">让我们加密</a>部分，阅读更多关于让我们加密对生产环境的限制。</p>
</blockquote>
<p>对于测试，更新<em>docker-compose . staging . yml .</em>文件，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">'3.8'</span><span class="w"/>

<span class="nt">services</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">context</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./app</span><span class="w"/>
<span class="w">      </span><span class="nt">dockerfile</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Dockerfile.prod</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">&lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com/django-ec2:web</span><span class="w"/>
<span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">gunicorn hello_django.wsgi:application --bind 0.0.0.0:8000</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">static_volume:/home/app/web/staticfiles</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">media_volume:/home/app/web/mediafiles</span><span class="w"/>
<span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8000</span><span class="w"/>
<span class="w">    </span><span class="nt">env_file</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./.env.staging</span><span class="w"/>
<span class="w">  </span><span class="nt">nginx-proxy</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx-proxy</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">&lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com/django-ec2:nginx-proxy</span><span class="w"/>
<span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">always</span><span class="w"/>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">443:443</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">80:80</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">static_volume:/home/app/web/staticfiles</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">media_volume:/home/app/web/mediafiles</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">certs:/etc/nginx/certs</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">html:/usr/share/nginx/html</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">vhost:/etc/nginx/vhost.d</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/var/run/docker.sock:/tmp/docker.sock:ro</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">web</span><span class="w"/>
<span class="w">  </span><span class="nt">nginx-proxy-letsencrypt</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">jrcs/letsencrypt-nginx-proxy-companion</span><span class="w"/>
<span class="w">    </span><span class="nt">env_file</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./.env.staging.proxy-companion</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/var/run/docker.sock:/var/run/docker.sock:ro</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">certs:/etc/nginx/certs</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">html:/usr/share/nginx/html</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">vhost:/etc/nginx/vhost.d</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">acme:/etc/acme.sh</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx-proxy</span><span class="w"/>

<span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">static_volume</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">media_volume</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">certs</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">html</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">vhost</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">acme</span><span class="p">:</span><span class="w"/>
</code></pre></div>

<p>对于<code>web</code>和<code>nginx-proxy</code>服务，更新<code>image</code>属性以使用来自ECR的图像(我们将很快添加)。</p>
<p>示例:</p>
<div class="codehilite"><pre><span/><code><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">123456789.dkr.ecr.us-east-1.amazonaws.com/django-ec2:web</span><span class="w"/>

<span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">123456789.dkr.ecr.us-east-1.amazonaws.com/django-ec2:nginx-proxy</span><span class="w"/>
</code></pre></div>

<p>这些值由存储库URL ( <code>123456789.dkr.ecr.us-east-1.amazonaws.com</code>)以及图像名称(<code>django-ec2</code>)和标签(<code>web</code>和<code>nginx-proxy</code>)组成。</p>
<blockquote>
<p>为了简单起见，我们使用一个注册表来存储两个图像。我们使用<code>web</code>和<code>nginx-proxy</code>来区分这两者。理想情况下，您应该使用两个注册中心:一个用于<code>web</code>，一个用于<code>nginx-proxy</code>。如果你喜欢，请自行更新。</p>
</blockquote>
<p>除了<code>image</code>属性，我们还删除了<code>db</code>服务(和相关的卷),因为我们使用RDS而不是在容器中管理Postgres。</p>
<h3 id="environments">环境</h3>
<p>是时候为<code>web</code>和<code>nginx-proxy-letsencrypt</code>容器设置环境文件了。</p>
<p>首先，为<code>web</code>容器添加一个<em> .env.staging </em>文件:</p>
<div class="codehilite"><pre><span/><code><span class="n">DEBUG</span><span class="o">=</span><span class="mi">0</span>
<span class="n">SECRET_KEY</span><span class="o">=</span><span class="n">change_me</span>
<span class="n">DJANGO_ALLOWED_HOSTS</span><span class="o">=&lt;</span><span class="n">YOUR_DOMAIN</span><span class="p">.</span><span class="n">COM</span><span class="o">&gt;</span>
<span class="n">SQL_ENGINE</span><span class="o">=</span><span class="n">django</span><span class="p">.</span><span class="n">db</span><span class="p">.</span><span class="n">backends</span><span class="p">.</span><span class="n">postgresql</span>
<span class="n">SQL_DATABASE</span><span class="o">=</span><span class="n">djangoec2</span>
<span class="n">SQL_USER</span><span class="o">=</span><span class="n">webapp</span>
<span class="n">SQL_PASSWORD</span><span class="o">=&lt;</span><span class="n">PASSWORD</span><span class="o">-</span><span class="n">FROM</span><span class="o">-</span><span class="n">AWS</span><span class="o">-</span><span class="n">RDS</span><span class="o">&gt;</span>
<span class="n">SQL_HOST</span><span class="o">=&lt;</span><span class="n">DATABASE</span><span class="o">-</span><span class="n">ENDPOINT</span><span class="o">-</span><span class="n">FROM</span><span class="o">-</span><span class="n">AWS</span><span class="o">-</span><span class="n">RDS</span><span class="o">&gt;</span>
<span class="n">SQL_PORT</span><span class="o">=</span><span class="mi">5432</span>
<span class="n">DATABASE</span><span class="o">=</span><span class="n">postgres</span>
<span class="n">VIRTUAL_HOST</span><span class="o">=&lt;</span><span class="n">YOUR_DOMAIN</span><span class="p">.</span><span class="n">COM</span><span class="o">&gt;</span>
<span class="n">VIRTUAL_PORT</span><span class="o">=</span><span class="mi">8000</span>
<span class="n">LETSENCRYPT_HOST</span><span class="o">=&lt;</span><span class="n">YOUR_DOMAIN</span><span class="p">.</span><span class="n">COM</span><span class="o">&gt;</span>
</code></pre></div>

<p>注意事项:</p>
<ol>
<li>将<code>&lt;YOUR_DOMAIN.COM&gt;</code>更改为您的实际域名。</li>
<li>更改<code>SQL_PASSWORD</code>和<code>SQL_HOST</code>以匹配RDS部分中创建的内容。</li>
<li>将<code>SECRET_KEY</code>改为某个长的随机字符串。</li>
<li><code>nginx-proxy</code>容器需要<code>VIRTUAL_HOST</code>和<code>VIRTUAL_PORT</code>来自动创建反向代理配置。</li>
<li><code>LETSENCRYPT_HOST</code>有没有办法让<code>nginx-proxy-companion</code>为你的域名颁发加密证书。</li>
</ol>
<blockquote>
<p>出于测试/调试的目的，您可能希望在第一次部署时使用一个<code>*</code>来代替<code>DJANGO_ALLOWED_HOSTS</code>,以简化事情。只是不要忘记在测试完成后限制允许的主机。</p>
</blockquote>
<p>其次，添加一个<em>. env . staging . proxy-companion</em>文件，确保更新<code>DEFAULT_EMAIL</code>值:</p>
<div class="codehilite"><pre><span/><code><span class="n">DEFAULT_EMAIL</span><span class="o">=</span><span class="n">youremail</span><span class="nv">@yourdomain</span><span class="p">.</span><span class="n">com</span><span class="w"/>
<span class="n">ACME_CA_URI</span><span class="o">=</span><span class="nl">https</span><span class="p">:</span><span class="o">//</span><span class="n">acme</span><span class="o">-</span><span class="n">staging</span><span class="o">-</span><span class="n">v02</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">letsencrypt</span><span class="p">.</span><span class="n">org</span><span class="o">/</span><span class="n">directory</span><span class="w"/>
<span class="n">NGINX_PROXY_CONTAINER</span><span class="o">=</span><span class="n">nginx</span><span class="o">-</span><span class="n">proxy</span><span class="w"/>
</code></pre></div>

<blockquote>
<p>回顾来自<a href="/blog/django-lets-encrypt/">的【让我们加密容器化的Django应用程序】的</a><a href="/blog/django-lets-encrypt/#lets-encrypt-nginx-proxy-companion-service">让我们加密Nginx代理伙伴服务</a>部分，以了解更多关于上述环境变量的信息。</p>
</blockquote>
<h2 id="build-and-push-docker-images">构建和推送Docker映像</h2>
<p>现在我们准备构建Docker图像:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose -f docker-compose.staging.yml build
</code></pre></div>

<p>可能需要几分钟来构建。完成后，我们就可以把图像上传到ECR了。</p>
<p>首先，假设您已经安装了<a href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html">AWS CLI</a>，并且已经设置了<a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html"> AWS凭证</a>，登录ECR Docker存储库:</p>
<div class="codehilite"><pre><span/><code>$ aws ecr get-login-password --region &lt;aws-region&gt; <span class="p">|</span> docker login --username AWS --password-stdin &lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com
<span class="c1"># aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 123456789.dkr.ecr.us-east-1.amazonaws.com</span>
</code></pre></div>

<p>您应该看到:</p>


<p>然后将图像推送到集控室:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose -f docker-compose.staging.yml push
</code></pre></div>

<p>打开您的django-ec2 ECR存储库来查看推送的图像:</p>
<p><img data-src="/static/images/blog/django/django-docker/ecr_images.png" loading="lazy" class="lazyload" alt="ECR Images" src="../Images/a898456def546b16ba63ecbd7551dc7e.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/ecr_images.png"/></p>
<h2 id="running-the-containers">运行容器</h2>
<p>一切都为部署做好了准备。</p>
<p>是时候转移到EC2实例了。</p>
<p>假设您在实例上创建了一个项目目录，如<em>/home/Ubuntu/django-on-docker</em>，使用SCP复制文件和文件夹:</p>
<div class="codehilite"><pre><span/><code>$ scp -i /path/to/your/djangoletsencrypt.pem <span class="se">\</span>
      -r <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/<span class="o">{</span>app,nginx,.env.staging,.env.staging.proxy-companion,docker-compose.staging.yml<span class="o">}</span> <span class="se">\</span>
      <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2b5e495e455f5e6b5b5e4947424806425b064459064f44464a424506444d064e4819064245585f4a45484e">[email protected]</a>:/path/to/django-on-docker
</code></pre></div>

<p>接下来，通过SSH连接到您的实例，并移动到项目目录:</p>
<div class="codehilite"><pre><span/><code>$ ssh -i /path/to/your/djangoletsencrypt.pem <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ccb9aeb9a2b8b98cbcb9aea0a5afe1a5bce1a3bee1a8a3a1ada5a2e1a3aae1a9affee1a5a2bfb8ada2afa9">[email protected]</a>
$ <span class="nb">cd</span> /path/to/django-on-docker
</code></pre></div>

<p>登录ECR Docker存储库。</p>
<div class="codehilite"><pre><span/><code>$ aws ecr get-login-password --region &lt;aws-region&gt; <span class="p">|</span> docker login --username AWS --password-stdin &lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com
</code></pre></div>

<p>提取图像:</p>
<div class="codehilite"><pre><span/><code>$ docker pull &lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com/django-ec2:web
$ docker pull &lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com/django-ec2:nginx-proxy
</code></pre></div>

<p>这样，您就可以开始旋转容器了:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose -f docker-compose.staging.yml up -d
</code></pre></div>

<p>一旦容器启动并运行，在浏览器中导航到您的域。您应该会看到类似这样的内容:</p>
<p><img data-src="/static/images/blog/django/django-docker/privacy_error.png" loading="lazy" class="lazyload" alt="HTTPS certificate not secure" src="../Images/d83157ae320af80a164075c62af84cc2.png" data-original-src="https://testdriven.io/static/images/blog/django/django-docker/privacy_error.png"/></p>
<p>这是意料之中的。显示该屏幕是因为证书是从<a href="https://letsencrypt.org/docs/staging-environment/">暂存环境</a>发布的。</p>
<p>你怎么知道一切是否正常？</p>
<p>点击“高级”,然后点击“继续”。您现在应该可以看到您的应用程序了。上传图像，然后确保您可以在<code>https://yourdomain.com/media/IMAGE_FILE_NAME</code>查看图像。</p>
<h2 id="issue-the-production-certificate">颁发生产证书</h2>
<p>现在，一切都按预期运行，我们可以切换到Let's Encrypt的生产环境。</p>
<p>关闭现有容器并退出实例:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose -f docker-compose.staging.yml down -v
$ <span class="nb">exit</span>
</code></pre></div>

<p>回到您的本地机器，打开<em> docker-compose.prod.yml </em>并进行与您对staging版本所做的相同的更改:</p>
<ol>
<li>更新<code>ìmage</code>属性，使之与<code>ẁeb</code>和<code>nginx-proxy</code>服务的AWS ECR URLs相匹配</li>
<li>移除<code>db</code>服务以及相关的卷</li>
</ol>
<div class="codehilite"><pre><span/><code><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">'3.8'</span><span class="w"/>

<span class="nt">services</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">context</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./app</span><span class="w"/>
<span class="w">      </span><span class="nt">dockerfile</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Dockerfile.prod</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">046505967931.dkr.ecr.us-east-1.amazonaws.com/django-ec2:web</span><span class="w"/>
<span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">gunicorn hello_django.wsgi:application --bind 0.0.0.0:8000</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">static_volume:/home/app/web/staticfiles</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">media_volume:/home/app/web/mediafiles</span><span class="w"/>
<span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8000</span><span class="w"/>
<span class="w">    </span><span class="nt">env_file</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./.env.prod</span><span class="w"/>
<span class="w">  </span><span class="nt">nginx-proxy</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx-proxy</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">046505967931.dkr.ecr.us-east-1.amazonaws.com/django-ec2:nginx-proxy</span><span class="w"/>
<span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">always</span><span class="w"/>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">443:443</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">80:80</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">static_volume:/home/app/web/staticfiles</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">media_volume:/home/app/web/mediafiles</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">certs:/etc/nginx/certs</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">html:/usr/share/nginx/html</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">vhost:/etc/nginx/vhost.d</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/var/run/docker.sock:/tmp/docker.sock:ro</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">web</span><span class="w"/>
<span class="w">  </span><span class="nt">nginx-proxy-letsencrypt</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">jrcs/letsencrypt-nginx-proxy-companion</span><span class="w"/>
<span class="w">    </span><span class="nt">env_file</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./.env.prod.proxy-companion</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/var/run/docker.sock:/var/run/docker.sock:ro</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">certs:/etc/nginx/certs</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">html:/usr/share/nginx/html</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">vhost:/etc/nginx/vhost.d</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">acme:/etc/acme.sh</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx-proxy</span><span class="w"/>

<span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">static_volume</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">media_volume</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">certs</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">html</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">vhost</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">acme</span><span class="p">:</span><span class="w"/>
</code></pre></div>

<p>接下来通过复制<em> .env.staging </em>文件创建一个<em> .env.prod </em>文件。您不需要对其进行任何更改。</p>
<p>最后，添加一个<em>. env . prod . proxy-companion</em>文件:</p>
<div class="codehilite"><pre><span/><code><span class="n">DEFAULT_EMAIL</span><span class="o">=</span><span class="n">youremail</span><span class="nv">@yourdomain</span><span class="p">.</span><span class="n">com</span><span class="w"/>
<span class="n">NGINX_PROXY_CONTAINER</span><span class="o">=</span><span class="n">nginx</span><span class="o">-</span><span class="n">proxy</span><span class="w"/>
</code></pre></div>

<p>再次构建和推送图像:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose -f docker-compose.prod.yml build
$ aws ecr get-login-password --region &lt;aws-region&gt; <span class="p">|</span> docker login --username AWS --password-stdin &lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com
$ docker-compose -f docker-compose.prod.yml push
</code></pre></div>

<p>使用SCP将新文件和文件夹复制到您的实例中:</p>
<div class="codehilite"><pre><span/><code>$ scp -i /path/to/your/djangoletsencrypt.pem <span class="se">\</span>
      <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/<span class="o">{</span>.env.prod,.env.prod.proxy-companion,docker-compose.prod.yml<span class="o">}</span> <span class="se">\</span>
      <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f18493849f8584b18184939d9892dc9881dc9e83dc959e9c90989fdc9e97dc9492c3dc989f8285909f9294">[email protected]</a>:/path/to/django-on-docker
</code></pre></div>

<p>像前面一样，通过SSH连接到您的实例，并移动到项目目录:</p>
<div class="codehilite"><pre><span/><code>$ ssh -i /path/to/your/djangoletsencrypt.pem <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="691c0b1c071d1c29191c0b05000a44001944061b440d060408000744060f440c0a5b4400071a1d08070a0c">[email protected]</a>
$ <span class="nb">cd</span> /path/to/django-on-docker
</code></pre></div>

<p>再次登录您的ECR Docker存储库:</p>
<div class="codehilite"><pre><span/><code>$ aws ecr get-login-password --region &lt;aws-region&gt; <span class="p">|</span> docker login --username AWS --password-stdin &lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com
</code></pre></div>

<p>提取图像:</p>
<div class="codehilite"><pre><span/><code>$ docker pull &lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com/django-ec2:web
$ docker pull &lt;aws-account-id&gt;.dkr.ecr.&lt;aws-region&gt;.amazonaws.com/django-ec2:nginx-proxy
</code></pre></div>

<p>最后旋转容器:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose -f docker-compose.prod.yml up -d
</code></pre></div>

<p>再次导航到您的域。您应该不会再看到警告。</p>
<p>恭喜你。现在，您正在为运行在AWS EC2上的Django应用程序使用一个生产证书。</p>
<blockquote>
<p>想要查看证书创建过程的运行情况，请查看日志:</p><div class="codehilite"><pre><span/><code>$ docker-compose -f docker-compose.prod.yml logs nginx-proxy-letsencrypt
</code></pre></div>
</blockquote>

<h2 id="conclusion">结论</h2>
<p>在本教程中，您将一个容器化的Django应用程序部署到EC2。该应用程序运行在HTTPS Nginx代理后面，让我们加密SSL证书。您还使用了一个RDS Postgres实例，并将Docker图像存储在ECR上。</p>
<p>下一步是什么？</p>
<ol>
<li><a href="/blog/storing-django-static-and-media-files-on-amazon-s3">设置S3并配置Django将静态和媒体文件存储在Docker卷之外的桶中</a></li>
<li><a href="/blog/deploying-django-to-ec2-with-docker-and-gitlab/">在GitLab上设置CI/CD管道</a></li>
<li><a href="/blog/django-logging-cloudwatch/">配置一个运行在EC2实例上的容器化Django应用程序，将日志发送到Amazon CloudWatch </a></li>
</ol>
<p>部署愉快！</p>
<blockquote>
<p>姜戈码头系列:</p>
<ol>
<li><a href="/blog/dockerizing-django-with-postgres-gunicorn-and-nginx/">用Postgres、Gunicorn和Nginx将Django归档</a></li>
<li><a href="/blog/django-lets-encrypt/">用加密保护容器化的Django应用</a></li>
<li><a href="/blog/django-docker-https-aws/">用Docker把Django部署到AWS，让我们加密</a>(本文！)</li>
</ol>
</blockquote>
  </div>

  </div>    
</body>
</html>