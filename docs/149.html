<html>
<head>
<title>Running Flask on Docker Swarm </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Docker Swarm上运行烧瓶</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/running-flask-on-docker-swarm/#0001-01-01">https://testdriven.io/blog/running-flask-on-docker-swarm/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>让我们看看如何在<a href="https://m.do.co/c/d8f211a4b4c2"> DigitalOcean </a>上启动Docker Swarm集群，然后配置一个由Flask和Postgres提供支持的微服务，在其上运行。</p>
<blockquote>
<p>这是一个中级教程。它假设你有Flask、Docker和容器编排的基本工作知识。有关这些工具和主题的更多信息，请查看以下课程:</p>
<ol>
<li><a href="https://testdriven.io/courses/tdd-flask/">使用Python、Flask和Docker进行测试驱动开发</a></li>
<li><a href="https://testdriven.io/courses/aws-flask-react/">展开烧瓶，对AWS ECS进行微服务反应</a></li>
</ol>
</blockquote>
<p><em> Docker依赖:</em></p>
<ul>
<li>文档编号v19.03.9</li>
<li>坞站-复合v1.27.4</li>
<li>对接机v0.16.2</li>
</ul>



<h2 id="objectives">目标</h2>
<p>本教程结束时，您将能够...</p>
<ol>
<li>解释什么是容器编排，以及为什么需要使用编排工具</li>
<li>讨论使用Docker Swarm优于其他编排工具(如Kubernetes和弹性容器服务(ECS ))的利弊</li>
<li>使用Docker Compose在本地构建基于Flask的微服务</li>
<li>构建Docker映像，并将它们上传到Docker Hub映像注册中心</li>
<li>使用Docker机器在DigitalOcean上配置主机</li>
<li>配置一个Docker群集群在数字海洋上运行</li>
<li>在Docker Swarm上运行Flask、Nginx和Postgres</li>
<li>使用循环算法在群集上路由流量</li>
<li>用Docker Swarm Visualizer监控集群</li>
<li>使用Docker Secrets管理Docker Swarm中的敏感信息</li>
<li>配置运行状况检查，以便在将服务添加到群集之前检查其状态</li>
<li>访问运行在集群上的服务的日志</li>
</ol>
<h2 id="what-is-container-orchestration">什么是容器编排？</h2>
<p>当您从在单台机器上部署容器转移到在多台机器上部署容器时，您将需要一个编排工具来管理(并自动化)容器在整个系统中的安排、协调和可用性。</p>
<p>这就是<a href="https://docs.docker.com/engine/swarm/"> Docker Swarm </a>(或“Swarm mode”)与许多其他编排工具相适应的地方——如<a href="https://kubernetes.io/"> Kubernetes </a>、<a href="https://aws.amazon.com/ecs/"> ECS </a>、<a href="https://mesos.apache.org/"> Mesos </a>和<a href="https://www.nomadproject.io/"> Nomad </a>。</p>
<p>你应该用哪一个？</p>
<ul>
<li>如果您需要管理大型、复杂的集群，请使用Kubernetes</li>
<li>如果您刚刚起步和/或需要管理中小型集群，请使用<em> Docker Swarm </em></li>
<li>如果您已经在使用一些AWS服务，请使用<em> ECS </em></li>
</ul>
<table>
<thead>
<tr>
<th>工具</th>
<th>赞成的意见</th>
<th>骗局</th>
</tr>
</thead>
<tbody>
<tr>
<td>库伯内特斯</td>
<td>大型社区，灵活，大多数功能，时尚</td>
<td>复杂的设置、高学习曲线、hip</td>
</tr>
<tr>
<td>码头工人群</td>
<td>易于设置，非常适合小型集群</td>
<td>受Docker API的限制</td>
</tr>
<tr>
<td>精英公司</td>
<td>全面管理的服务，与AWS集成</td>
<td>供应商锁定</td>
</tr>
</tbody>
</table>
<p>市场上还有许多基于Kubernetes的托管服务:</p>
<ol>
<li><a href="https://cloud.google.com/kubernetes-engine/">谷歌Kubernetes引擎</a> (GKE)</li>
<li><a href="https://aws.amazon.com/eks/">弹性集装箱服务</a> (EKS)</li>
<li>Azure Kubernetes服务公司</li>
</ol>
<blockquote>
<p>更多信息，请查看<a href="https://blog.kublr.com/choosing-the-right-containerization-and-cluster-management-tool-fdfcec5700df">选择正确的容器化和集群管理工具</a>博文。</p>
</blockquote>
<h2 id="project-setup">项目设置</h2>
<p>从<a href="https://github.com/testdrivenio/flask-docker-swarm">烧瓶-docker-swarm </a> repo中克隆出<a href="https://github.com/testdrivenio/flask-docker-swarm/tree/base">碱基</a>分支；</p>
<div class="codehilite"><pre><span/><code>$ git clone https://github.com/testdrivenio/flask-docker-swarm --branch base --single-branch
$ <span class="nb">cd</span> flask-docker-swarm
</code></pre></div>

<p>构建映像并在本地旋转容器:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose up -d --build
</code></pre></div>

<p>创建并植入数据库<code>users</code>表:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose run web python manage.py recreate_db
$ docker-compose run web python manage.py seed_db
</code></pre></div>

<p>在您选择的浏览器中测试以下URL。</p>
<p><a href="http://localhost/ping"> http://localhost/ping </a>:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"container_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"3c9dc22aa37a"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"pong!"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"success"</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<blockquote>
<p><code>container_id</code>是运行应用程序的Docker容器的ID:</p>
<div class="codehilite"><pre><span/>$ docker ps --filter <span class="nv">name</span><span class="o">=</span>flask-docker-swarm_web --format <span class="s2">"{{.ID}}"</span>
3c9dc22aa37a
</pre></div></blockquote>

<p><a href="http://localhost/users"> http://localhost/users </a>:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"container_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"3c9dc22aa37a"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"success"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"users"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w"/>
<span class="w">    </span><span class="nt">"active"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nt">"admin"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nt">"email"</span><span class="p">:</span><span class="w"> </span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e68b8f858e87838aa68889929483878ac885898b">[email protected]</a>"</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nt">"username"</span><span class="p">:</span><span class="w"> </span><span class="s2">"michael"</span><span class="w"/>
<span class="w">  </span><span class="p">}]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>在继续之前，快速浏览一下代码:</p>
<div class="codehilite"><pre><span/><code>├── README.md
├── docker-compose.yml
└── services
    ├── db
    │   ├── Dockerfile
    │   └── create.sql
    ├── nginx
    │   ├── Dockerfile
    │   └── prod.conf
    └── web
        ├── Dockerfile
        ├── manage.py
        ├── project
        │   ├── __init__.py
        │   ├── api
        │   │   ├── main.py
        │   │   ├── models.py
        │   │   └── users.py
        │   └── config.py
        └── requirements.txt
</code></pre></div>

<h2 id="docker-hub">坞站集线器</h2>
<p>由于Docker Swarm使用多个Docker引擎，我们需要使用一个Docker映像注册表来将我们的三个映像分发到每个引擎。本教程使用<a href="https://hub.docker.com/"> Docker Hub </a> image registry，但也可以随意使用不同的注册表服务或<a href="https://docs.docker.com/registry/deploying/">在Swarm中运行</a>你自己的私有注册表。</p>
<p>在Docker Hub上创建一个帐户(如果您还没有)，然后登录:</p>


<p>构建、标记和推送图像到Docker Hub:</p>
<div class="codehilite"><pre><span/><code>$ docker build -t mjhea0/flask-docker-swarm_web:latest -f ./services/web/Dockerfile ./services/web
$ docker push mjhea0/flask-docker-swarm_web:latest

$ docker build -t mjhea0/flask-docker-swarm_db:latest -f ./services/db/Dockerfile ./services/db
$ docker push mjhea0/flask-docker-swarm_db:latest

$ docker build -t mjhea0/flask-docker-swarm_nginx:latest -f ./services/nginx/Dockerfile ./services/nginx
$ docker push mjhea0/flask-docker-swarm_nginx:latest
</code></pre></div>

<blockquote>
<p>确保用Docker Hub上的名称空间替换<code>mjhea0</code>。</p>
</blockquote>
<h2 id="compose-file">撰写文件</h2>
<p>接下来，让我们建立一个新的Docker组合文件，用于Docker Swarm:</p>
<div class="codehilite"><pre><span/><code><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">'3.8'</span><span class="w"/>

<span class="nt">services</span><span class="p">:</span><span class="w"/>

<span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">mjhea0/flask-docker-swarm_web:latest</span><span class="w"/>
<span class="w">    </span><span class="nt">deploy</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span><span class="w"/>
<span class="w">      </span><span class="nt">restart_policy</span><span class="p">:</span><span class="w"/>
<span class="w">        </span><span class="nt">condition</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">on-failure</span><span class="w"/>
<span class="w">      </span><span class="nt">placement</span><span class="p">:</span><span class="w"/>
<span class="w">        </span><span class="nt">constraints</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">node.role == worker</span><span class="p p-Indicator">]</span><span class="w"/>
<span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">5000</span><span class="w"/>
<span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">FLASK_ENV=production</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">APP_SETTINGS=project.config.ProductionConfig</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">DB_USER=postgres</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">DB_PASSWORD=postgres</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">SECRET_CODE=myprecious</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">db</span><span class="w"/>
<span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">app</span><span class="w"/>

<span class="w">  </span><span class="nt">db</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">mjhea0/flask-docker-swarm_db:latest</span><span class="w"/>
<span class="w">    </span><span class="nt">deploy</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span><span class="w"/>
<span class="w">      </span><span class="nt">restart_policy</span><span class="p">:</span><span class="w"/>
<span class="w">        </span><span class="nt">condition</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">on-failure</span><span class="w"/>
<span class="w">      </span><span class="nt">placement</span><span class="p">:</span><span class="w"/>
<span class="w">        </span><span class="nt">constraints</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">node.role == manager</span><span class="p p-Indicator">]</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">data-volume:/var/lib/postgresql/data</span><span class="w"/>
<span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">5432</span><span class="w"/>
<span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">POSTGRES_USER=postgres</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">POSTGRES_PASSWORD=postgres</span><span class="w"/>
<span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">app</span><span class="w"/>

<span class="w">  </span><span class="nt">nginx</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">mjhea0/flask-docker-swarm_nginx:latest</span><span class="w"/>
<span class="w">    </span><span class="nt">deploy</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span><span class="w"/>
<span class="w">      </span><span class="nt">restart_policy</span><span class="p">:</span><span class="w"/>
<span class="w">        </span><span class="nt">condition</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">on-failure</span><span class="w"/>
<span class="w">      </span><span class="nt">placement</span><span class="p">:</span><span class="w"/>
<span class="w">        </span><span class="nt">constraints</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">node.role == worker</span><span class="p p-Indicator">]</span><span class="w"/>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">80:80</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">web</span><span class="w"/>
<span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">app</span><span class="w"/>

<span class="nt">networks</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">app</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">driver</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">overlay</span><span class="w"/>

<span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">data-volume</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">driver</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">local</span><span class="w"/>
</code></pre></div>

<p>在项目根目录下将该文件另存为<em> docker-compose-swarm.yml </em>。请注意两个合成文件之间的差异:</p>
<ol>
<li><em> Image </em>:我们现在使用一个图像来设置上下文，而不是引用本地构建目录。</li>
<li><em> Deploy </em>:我们增加了一个<a href="https://github.com/compose-spec/compose-spec/blob/master/deploy.md"> deploy </a>关键字来配置每个服务的<a href="https://github.com/compose-spec/compose-spec/blob/master/deploy.md#replicas">副本</a>、<a href="https://github.com/compose-spec/compose-spec/blob/master/deploy.md#restart_policy">重启策略</a>和<a href="https://github.com/compose-spec/compose-spec/blob/master/deploy.md#placement">放置约束</a>的数量。参考官方<a href="https://docs.docker.com/compose/compose-file/">文档</a>获取更多关于为Docker Swarm设置合成文件的信息。</li>
<li><em>网络</em>:我们现在使用一个<a href="https://docs.docker.com/network/overlay/">覆盖</a>网络来连接每个主机上的多个Docker引擎，并实现群服务之间的通信。</li>
</ol>
<h2 id="docker-swarm">码头工人群</h2>
<p><a href="https://m.do.co/c/d8f211a4b4c2">注册</a>一个数字海洋账户(如果你还没有的话)，然后<a href="https://docs.digitalocean.com/reference/api/create-personal-access-token/">生成</a>一个访问令牌，这样你就可以访问数字海洋API了。</p>
<p>将令牌添加到您的环境中:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">export</span> <span class="nv">DIGITAL_OCEAN_ACCESS_TOKEN</span><span class="o">=[</span>your_digital_ocean_token<span class="o">]</span>
</code></pre></div>

<p>旋转四个数字海洋液滴:</p>
<div class="codehilite"><pre><span/><code>$ <span class="k">for</span> i <span class="k">in</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span><span class="p">;</span> <span class="k">do</span>
    docker-machine create <span class="se">\</span>
      --driver digitalocean <span class="se">\</span>
      --digitalocean-access-token <span class="nv">$DIGITAL_OCEAN_ACCESS_TOKEN</span> <span class="se">\</span>
      --engine-install-url <span class="s2">"https://releases.rancher.com/install-docker/19.03.9.sh"</span> <span class="se">\</span>
      node-<span class="nv">$i</span><span class="p">;</span>
  <span class="k">done</span>
</code></pre></div>

<blockquote>
<p>需要<code>--engine-install-url</code>，因为在撰写本文时，Docker v20.10.0 <a href="https://github.com/docker/machine/issues/4858">无法与Docker Machine </a>一起使用。</p>
</blockquote>
<p>这需要几分钟时间。一旦完成，在<code>node-1</code>初始化<a href="https://docs.docker.com/engine/swarm/">群模式</a>:</p>
<div class="codehilite"><pre><span/><code>$ docker-machine ssh node-1 -- docker swarm init --advertise-addr <span class="k">$(</span>docker-machine ip node-1<span class="k">)</span>
</code></pre></div>

<p>从上一个命令的输出中获取join令牌，然后将剩余的节点作为workers添加到群中:</p>
<div class="codehilite"><pre><span/><code>$ <span class="k">for</span> i <span class="k">in</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span><span class="p">;</span> <span class="k">do</span>
    docker-machine ssh node-<span class="nv">$i</span> <span class="se">\</span>
      -- docker swarm join --token YOUR_JOIN_TOKEN<span class="p">;</span>
<span class="k">done</span>
</code></pre></div>

<p>将Docker守护进程指向<code>node-1</code>并部署堆栈:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env node-1<span class="k">)</span>
$ docker stack deploy --compose-file<span class="o">=</span>docker-compose-swarm.yml flask
</code></pre></div>

<p>列出堆栈中的服务:</p>
<div class="codehilite"><pre><span/><code>$ docker stack ps -f <span class="s2">"desired-state=running"</span> flask
</code></pre></div>

<p>您应该会看到类似如下的内容:</p>
<div class="codehilite"><pre><span/><code>ID              NAME            IMAGE                                    NODE         DESIRED STATE       CURRENT STATE
uz84le3651f8    flask_nginx.1   mjhea0/flask-docker-swarm_nginx:latest   node-3       Running             Running <span class="m">23</span> seconds ago
nv365bhsoek1    flask_web.1     mjhea0/flask-docker-swarm_web:latest     node-2       Running             Running <span class="m">32</span> seconds ago
uyl11jk2h71d    flask_db.1      mjhea0/flask-docker-swarm_db:latest      node-1       Running             Running <span class="m">38</span> seconds ago
</code></pre></div>

<p>现在，为了根据<code>web</code>服务中提供的模式更新数据库，我们首先需要将Docker守护进程指向运行<code>flask_web</code>的节点:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nv">NODE</span><span class="o">=</span><span class="k">$(</span>docker service ps -f <span class="s2">"desired-state=running"</span> --format <span class="s2">"{{.Node}}"</span> flask_web<span class="k">)</span>
$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env <span class="nv">$NODE</span><span class="k">)</span>
</code></pre></div>

<p>将<code>flask_web</code>的容器ID分配给一个变量:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nv">CONTAINER_ID</span><span class="o">=</span><span class="k">$(</span>docker ps --filter <span class="nv">name</span><span class="o">=</span>flask_web --format <span class="s2">"{{.ID}}"</span><span class="k">)</span>
</code></pre></div>

<p>创建数据库表并应用种子:</p>
<div class="codehilite"><pre><span/><code>$ docker container <span class="nb">exec</span> -it <span class="nv">$CONTAINER_ID</span> python manage.py recreate_db
$ docker container <span class="nb">exec</span> -it <span class="nv">$CONTAINER_ID</span> python manage.py seed_db
</code></pre></div>

<p>最后，将Docker守护进程指向<code>node-1</code>，并检索与运行<code>flask_nginx</code>的机器相关联的IP:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env node-1<span class="k">)</span>
$ docker-machine ip <span class="k">$(</span>docker service ps -f <span class="s2">"desired-state=running"</span> --format <span class="s2">"{{.Node}}"</span> flask_nginx<span class="k">)</span>
</code></pre></div>

<p>测试端点:</p>
<ol>
<li><a href="http://YOUR_MACHINE_IP/ping">http://YOUR _ MACHINE _ IP/ping</a></li>
<li><a href="http://YOUR_MACHINE_IP/users">http://你的机器IP/用户</a></li>
</ol>
<p>让我们向集群添加另一个web应用程序:</p>
<div class="codehilite"><pre><span/><code>$ docker service scale <span class="nv">flask_web</span><span class="o">=</span><span class="m">2</span>

flask_web scaled to <span class="m">2</span>
overall progress: <span class="m">2</span> out of <span class="m">2</span> tasks
<span class="m">1</span>/2: running   <span class="o">[==================================================</span>&gt;<span class="o">]</span>
<span class="m">2</span>/2: running   <span class="o">[==================================================</span>&gt;<span class="o">]</span>
verify: Service converged
</code></pre></div>

<p>确认服务确实可以扩展:</p>
<div class="codehilite"><pre><span/><code>$ docker stack ps -f <span class="s2">"desired-state=running"</span> flask

ID              NAME            IMAGE                                    NODE         DESIRED STATE       CURRENT STATE
uz84le3651f8    flask_nginx.1   mjhea0/flask-docker-swarm_nginx:latest   node-3       Running             Running <span class="m">7</span> minutes ago
nv365bhsoek1    flask_web.1     mjhea0/flask-docker-swarm_web:latest     node-2       Running             Running <span class="m">7</span> minutes ago
uyl11jk2h71d    flask_db.1      mjhea0/flask-docker-swarm_db:latest      node-1       Running             Running <span class="m">7</span> minutes ago
n8ld0xkm3pd0    flask_web.2     mjhea0/flask-docker-swarm_web:latest     node-4       Running             Running <span class="m">7</span> seconds ago
</code></pre></div>

<p>向服务提出一些请求:</p>
<div class="codehilite"><pre><span/><code>$ <span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span><span class="m">1</span><span class="p">;</span>i&lt;<span class="o">=</span><span class="m">10</span><span class="p">;</span>i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span> curl http://YOUR_MACHINE_IP/ping<span class="p">;</span> <span class="k">done</span>
</code></pre></div>

<p>您应该看到不同的<code>container_id</code>被返回，表明请求通过两个副本之间的循环算法被适当地路由:</p>
<div class="codehilite"><pre><span/><code><span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"3e984eb707ea"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
<span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"e47de2a13a2e"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
<span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"3e984eb707ea"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
<span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"e47de2a13a2e"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
<span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"3e984eb707ea"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
<span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"e47de2a13a2e"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
<span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"3e984eb707ea"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
<span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"e47de2a13a2e"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
<span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"3e984eb707ea"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
<span class="o">{</span><span class="s2">"container_id"</span>:<span class="s2">"e47de2a13a2e"</span>,<span class="s2">"message"</span>:<span class="s2">"pong!"</span>,<span class="s2">"status"</span>:<span class="s2">"success"</span><span class="o">}</span>
</code></pre></div>

<p>如果我们在流量到达集群时进行扩展，会发生什么情况？</p>
<p><img data-src="/static/images/gifs/blog/flask-docker-swarm/curl.gif" loading="lazy" class="lazyload" alt="curl" src="../Images/4ca76bcd8ad338d6385e30ed8bd078e6.png" data-original-src="https://testdriven.io/static/images/gifs/blog/flask-docker-swarm/curl.gif"/></p>
<p>流量被适当地重新路由。再试一次，但这次要横向扩展。</p>
<h2 id="docker-swarm-visualizer">Docker群体可视化工具</h2>
<p>Docker Swarm Visualizer是一款开源工具，用于监控Docker Swarm集群。</p>
<p>将服务添加到<em> docker-compose-swarm.yml </em>:</p>
<div class="codehilite"><pre><span/><code><span class="nt">visualizer</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">dockersamples/visualizer:latest</span><span class="w"/>
<span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8080:8080</span><span class="w"/>
<span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="s">"/var/run/docker.sock:/var/run/docker.sock"</span><span class="w"/>
<span class="w">  </span><span class="nt">deploy</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">placement</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">constraints</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">node.role == manager</span><span class="p p-Indicator">]</span><span class="w"/>
<span class="w">  </span><span class="nt">networks</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">app</span><span class="w"/>
</code></pre></div>

<p>将Docker守护进程指向<code>node-1</code>并更新堆栈:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env node-1<span class="k">)</span>
$ docker stack deploy --compose-file<span class="o">=</span>docker-compose-swarm.yml flask
</code></pre></div>

<p>可视化工具可能需要一两分钟才能启动。导航至<a href="http://YOUR_MACHINE_IP:8080">http://YOUR _ MACHINE _ IP:8080</a>查看仪表板:</p>
<p><img data-src="/static/images/blog/flask-docker-swarm/visualizer1.png" loading="lazy" class="lazyload" alt="docker swarm visualizer" src="../Images/267855fd3ae431f0ca57eaee66fa6bbd.png" data-original-src="https://testdriven.io/static/images/blog/flask-docker-swarm/visualizer1.png"/></p>
<p>再添加两个<code>flask_web</code>的副本:</p>
<div class="codehilite"><pre><span/><code>$ docker service scale <span class="nv">flask_web</span><span class="o">=</span><span class="m">3</span>
</code></pre></div>

<p><img data-src="/static/images/blog/flask-docker-swarm/visualizer2.png" loading="lazy" class="lazyload" alt="docker swarm visualizer" src="../Images/afd41aa56c1f0caba4d673283e18ec1c.png" data-original-src="https://testdriven.io/static/images/blog/flask-docker-swarm/visualizer2.png"/></p>
<h2 id="docker-secrets">码头工人的秘密</h2>
<p><a href="https://docs.docker.com/engine/swarm/secrets/"> Docker Secrets </a>是一款专门为Docker Swarm设计的秘密管理工具。有了它，你可以轻松地分发敏感信息(如用户名和密码，SSH密钥，SSL证书，API令牌等。)跨集群。</p>
<p>Docker可以从自己的数据库(<a href="https://github.com/compose-spec/compose-spec/blob/master/spec.md#secrets-top-level-element">外部</a>模式)或者从本地文件(<a href="https://github.com/compose-spec/compose-spec/blob/master/spec.md#secrets-top-level-element">文件</a>模式)中读取秘密。我们将着眼于前者。</p>
<p>在<em>services/web/project/API/main . py</em>文件中，记下<code>/secret</code>路径。如果请求有效载荷中的<code>secret</code>与<code>SECRET_CODE</code>变量相同，则响应有效载荷中的消息将等于<code>yay!</code>。否则，它将等于<code>nay!</code>。</p>
<div class="codehilite"><pre><span/><code><span class="c1"># yay</span>
<span class="o">{</span>
  <span class="s2">"container_id"</span>: <span class="s2">"6f91a81a6357"</span>,
  <span class="s2">"message"</span>: <span class="s2">"yay!"</span>,
  <span class="s2">"status"</span>: <span class="s2">"success"</span>
<span class="o">}</span>

<span class="c1"># nay</span>
<span class="o">{</span>
  <span class="s2">"container_id"</span>: <span class="s2">"6f91a81a6357"</span>,
  <span class="s2">"message"</span>: <span class="s2">"nay!"</span>,
  <span class="s2">"status"</span>: <span class="s2">"success"</span>
<span class="o">}</span>
</code></pre></div>

<p>测试终端中的<code>/secret</code>端点:</p>
<div class="codehilite"><pre><span/><code>$ curl -X POST http://YOUR_MACHINE_IP/secret <span class="se">\</span>
    -d <span class="s1">'{"secret": "myprecious"}'</span> <span class="se">\</span>
    -H <span class="s1">'Content-Type: application/json'</span>
</code></pre></div>

<p>您应该看到:</p>
<div class="codehilite"><pre><span/><code><span class="o">{</span>
  <span class="s2">"container_id"</span>: <span class="s2">"6f91a81a6357"</span>,
  <span class="s2">"message"</span>: <span class="s2">"yay!"</span>,
  <span class="s2">"status"</span>: <span class="s2">"success"</span>
<span class="o">}</span>
</code></pre></div>

<p>让我们更新一下<code>SECRET_CODE</code>，让它由Docker Secret而不是环境变量来设置。首先从manager节点创建一个新的密码:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env node-1<span class="k">)</span>
$ <span class="nb">echo</span> <span class="s2">"foobar"</span> <span class="p">|</span> docker secret create secret_code -
</code></pre></div>

<p>确认它已创建:</p>


<p>您应该会看到类似这样的内容:</p>
<div class="codehilite"><pre><span/><code>ID                          NAME             DRIVER    CREATED             UPDATED
za3pg2cbbf92gi9u1v0af16e3   secret_code                <span class="m">15</span> seconds ago      <span class="m">15</span> seconds ago
</code></pre></div>

<p>接下来，删除<code>SECRET_CODE</code>环境变量，并将<code>secrets</code>配置添加到<em> docker-compose-swarm-yml </em>中的<code>web</code>服务中:</p>
<div class="codehilite"><pre><span/><code><span class="nt">web</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">mjhea0/flask-docker-swarm_web:latest</span><span class="w"/>
<span class="w">  </span><span class="nt">deploy</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span><span class="w"/>
<span class="w">    </span><span class="nt">restart_policy</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">condition</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">on-failure</span><span class="w"/>
<span class="w">    </span><span class="nt">placement</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">constraints</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">node.role == worker</span><span class="p p-Indicator">]</span><span class="w"/>
<span class="w">  </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">5000</span><span class="w"/>
<span class="w">  </span><span class="nt">environment</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">FLASK_ENV=production</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">APP_SETTINGS=project.config.ProductionConfig</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">DB_USER=postgres</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">DB_PASSWORD=postgres</span><span class="w"/>
<span class="w">  </span><span class="nt">secrets</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">secret_code</span><span class="w"/>
<span class="w">  </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">db</span><span class="w"/>
<span class="w">  </span><span class="nt">networks</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">app</span><span class="w"/>
</code></pre></div>

<p>在文件的底部，将秘密的来源定义为<code>external</code>，就在<code>volumes</code>声明的下面:</p>
<div class="codehilite"><pre><span/><code><span class="nt">secrets</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">secret_code</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">external</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span><span class="w"/>
</code></pre></div>

<p>就是这样。我们可以在Flask应用程序中获得这个秘密。</p>
<blockquote>
<p>查看<a href="https://github.com/compose-spec/compose-spec/blob/master/spec.md#secrets-top-level-element"> secrets配置参考</a>指南以及<a href="https://stackoverflow.com/questions/42139605/how-do-you-manage-secret-values-with-docker-compose-v3-1">该</a>堆栈溢出答案，了解有关外部和基于文件的机密的更多信息。</p>
</blockquote>
<p>转回<em>services/web/project/API/main . py</em>。</p>
<p>改变:</p>
<div class="codehilite"><pre><span/><code><span class="n">SECRET_CODE</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"SECRET_CODE"</span><span class="p">)</span>
</code></pre></div>

<p>收件人:</p>
<div class="codehilite"><pre><span/><code><span class="n">SECRET_CODE</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"/run/secrets/secret_code"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</code></pre></div>

<p>将Docker环境重置回本地主机:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env -u<span class="k">)</span>
</code></pre></div>

<p>重新构建映像并将新版本推送到Docker Hub:</p>
<div class="codehilite"><pre><span/><code>$ docker build -t mjhea0/flask-docker-swarm_web:latest -f ./services/web/Dockerfile ./services/web
$ docker push mjhea0/flask-docker-swarm_web:latest
</code></pre></div>

<p>将守护程序指向管理器，然后更新服务:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env node-1<span class="k">)</span>
$ docker stack deploy --compose-file<span class="o">=</span>docker-compose-swarm.yml flask
</code></pre></div>

<blockquote>
<p>有关在合成文件中定义机密的更多信息，请参考文档的<a href="https://docs.docker.com/engine/swarm/secrets/#use-secrets-in-compose">在合成</a>中使用机密部分。</p>
</blockquote>
<p>再次测试:</p>
<div class="codehilite"><pre><span/><code>$ curl -X POST http://YOUR_MACHINE_IP/secret <span class="se">\</span>
    -d <span class="s1">'{"secret": "foobar"}'</span> <span class="se">\</span>
    -H <span class="s1">'Content-Type: application/json'</span>

<span class="o">{</span>
  <span class="s2">"container_id"</span>: <span class="s2">"6f91a81a6357"</span>,
  <span class="s2">"message"</span>: <span class="s2">"yay!"</span>,
  <span class="s2">"status"</span>: <span class="s2">"success"</span>
<span class="o">}</span>
</code></pre></div>

<blockquote>
<p>想挑战吗？尝试使用Docker秘密来管理数据库凭证，而不是直接在合成文件中定义它们。</p>
</blockquote>
<h2 id="health-checks">健康检查</h2>
<p>在生产环境中，您应该在将流量路由到某个容器之前，使用健康检查来测试该容器是否按预期<em>工作。在我们的例子中，我们可以使用健康检查来确保Flask应用程序(和API)启动并运行；否则，我们可能会遇到这样的情况:一个新的容器启动并添加到集群中，该容器看起来是健康的，但实际上应用程序实际上是关闭的，无法处理流量。</em></p>
<p>您可以将健康检查添加到docker文件或撰写文件中。我们将着眼于后者。</p>
<blockquote>
<p>想知道如何在Dockerfile文件中添加健康检查吗？查看官方文件中的<a href="https://docs.docker.com/engine/reference/builder/#healthcheck">健康检查说明</a>。</p>
</blockquote>
<p>值得注意的是，在撰写文件中定义的健康检查设置将覆盖Dockerfile文件中的设置。</p>
<p>像这样更新<em> docker-compose-swarm.yml </em>中的<code>web</code>服务:</p>
<div class="codehilite"><pre><span/><code><span class="nt">web</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">mjhea0/flask-docker-swarm_web:latest</span><span class="w"/>
<span class="w">  </span><span class="nt">deploy</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span><span class="w"/>
<span class="w">    </span><span class="nt">restart_policy</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">condition</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">on-failure</span><span class="w"/>
<span class="w">    </span><span class="nt">placement</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">constraints</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">node.role == worker</span><span class="p p-Indicator">]</span><span class="w"/>
<span class="w">  </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">5000</span><span class="w"/>
<span class="w">  </span><span class="nt">environment</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">FLASK_ENV=production</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">APP_SETTINGS=project.config.ProductionConfig</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">DB_USER=postgres</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">DB_PASSWORD=postgres</span><span class="w"/>
<span class="w">  </span><span class="nt">secrets</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">secret_code</span><span class="w"/>
<span class="w">  </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">db</span><span class="w"/>
<span class="w">  </span><span class="nt">networks</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">app</span><span class="w"/>
<span class="w">  </span><span class="nt">healthcheck</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">test</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">curl --fail http://localhost:5000/ping || exit 1</span><span class="w"/>
<span class="w">    </span><span class="nt">interval</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">10s</span><span class="w"/>
<span class="w">    </span><span class="nt">timeout</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2s</span><span class="w"/>
<span class="w">    </span><span class="nt">retries</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">5</span><span class="w"/>
</code></pre></div>

<p>选项:</p>
<ol>
<li><code>test</code>是将运行来检查运行状况的实际命令。如果正常，它应该返回<code>0</code>,如果不正常，应该返回<code>1</code>。为此，curl命令必须在容器中可用。</li>
<li>容器启动后，<code>interval</code>控制第一次运行状况检查的时间和频率。</li>
<li><code>retries</code>设置在容器被视为不健康之前，健康检查将重试失败检查的次数。</li>
<li>如果一次运行状况检查花费的时间超过了<code>timeout</code>中定义的时间，则该运行将被视为失败。</li>
</ol>
<p>在测试健康检查之前，我们需要向容器添加curl。<em>记住:</em>您用于运行状况检查的命令需要在容器内部可用。</p>
<p>像这样更新<em> Dockerfile </em>:</p>
<div class="codehilite"><pre><span/><code><span class="c1">###########</span>
<span class="c1"># BUILDER #</span>
<span class="c1">###########</span>

<span class="c1"># Base Image</span>
FROM python:3.9 as builder

<span class="c1"># Lint</span>
RUN pip install flake8 black
WORKDIR /home/app
COPY project ./project
COPY manage.py .
RUN flake8 --ignore<span class="o">=</span>E501 .
RUN black --check .

<span class="c1"># Install Requirements</span>
COPY requirements.txt .
RUN pip wheel --no-cache-dir --no-deps --wheel-dir /home/app/wheels -r requirements.txt


<span class="c1">#########</span>
<span class="c1"># FINAL #</span>
<span class="c1">#########</span>

<span class="c1"># Base Image</span>
FROM python:3.9-slim

<span class="c1"># ----- NEW ----</span>
<span class="c1"># Install curl</span>
RUN apt-get update <span class="o">&amp;&amp;</span> apt-get install -y curl

<span class="c1"># Create directory for the app user</span>
RUN mkdir -p /home/app

<span class="c1"># Create the app user</span>
RUN groupadd app <span class="o">&amp;&amp;</span> useradd -g app app

<span class="c1"># Create the home directory</span>
ENV <span class="nv">HOME</span><span class="o">=</span>/home/app
ENV <span class="nv">APP_HOME</span><span class="o">=</span>/home/app/web
RUN mkdir <span class="nv">$APP_HOME</span>
WORKDIR <span class="nv">$APP_HOME</span>

<span class="c1"># Install Requirements</span>
COPY --from<span class="o">=</span>builder /home/app/wheels /wheels
COPY --from<span class="o">=</span>builder /home/app/requirements.txt .
RUN pip install --no-cache /wheels/*

<span class="c1"># Copy in the Flask code</span>
COPY . <span class="nv">$APP_HOME</span>

<span class="c1"># Chown all the files to the app user</span>
RUN chown -R app:app <span class="nv">$APP_HOME</span>

<span class="c1"># Change to the app user</span>
USER app

<span class="c1"># run server</span>
CMD gunicorn --log-level<span class="o">=</span>debug -b <span class="m">0</span>.0.0.0:5000 manage:app
</code></pre></div>

<p>再次，重置Docker环境:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env -u<span class="k">)</span>
</code></pre></div>

<p>建立并推广新形象:</p>
<div class="codehilite"><pre><span/><code>$ docker build -t mjhea0/flask-docker-swarm_web:latest -f ./services/web/Dockerfile ./services/web
$ docker push mjhea0/flask-docker-swarm_web:latest
</code></pre></div>

<p>更新服务:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env node-1<span class="k">)</span>
$ docker stack deploy --compose-file<span class="o">=</span>docker-compose-swarm.yml flask
</code></pre></div>

<p>然后，找到<code>flask_web</code>服务所在的节点:</p>
<div class="codehilite"><pre><span/><code>$ docker service ps flask_web
</code></pre></div>

<p>将守护程序指向该节点:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env &lt;NODE&gt;<span class="k">)</span>
</code></pre></div>

<blockquote>
<p>确保用实际的节点替换<code>&lt;NODE&gt;</code>——例如<code>node-2</code>、<code>node-3</code>或<code>node-4</code>。</p>
</blockquote>
<p>获取容器ID:</p>


<p>然后运行:</p>
<div class="codehilite"><pre><span/><code>$ docker inspect --format<span class="o">=</span><span class="s1">'{{json .State.Health}}'</span> &lt;CONTAINER_ID&gt;
</code></pre></div>

<p>您应该会看到类似这样的内容:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"Status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"healthy"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"FailingStreak"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"Log"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"/>
<span class="w">    </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="nt">"Start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2021-02-23T03:31:44.886509504Z"</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="nt">"End"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2021-02-23T03:31:45.104507568Z"</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="nt">"ExitCode"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="nt">"Output"</span><span class="p">:</span><span class="w"> </span><span class="s2">"  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r100    69  100    69    0     0  11629      0 --:--:-- --:--:-- --:--:-- 13800\n{\"container_id\":\"a6127b1f469d\",\"message\":\"pong!\",\"status\":\"success\"}\n"</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="w">  </span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>想看看失败的健康检查吗？将<em> docker-compose-swarm.yml </em>中的<code>test</code>命令更新为ping端口5001而不是5000:</p>
<div class="codehilite"><pre><span/><code><span class="nt">healthcheck</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">test</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">curl --fail http://localhost:5001/ping || exit 1</span><span class="w"/>
<span class="w">  </span><span class="nt">interval</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">10s</span><span class="w"/>
<span class="w">  </span><span class="nt">timeout</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2s</span><span class="w"/>
<span class="w">  </span><span class="nt">retries</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">5</span><span class="w"/>
</code></pre></div>

<p>就像之前一样，更新服务，然后找到<code>flask_web</code>服务所在的节点和容器id。然后，运行:</p>
<div class="codehilite"><pre><span/><code>$ docker inspect --format<span class="o">=</span><span class="s1">'{{json .State.Health}}'</span> &lt;CONTAINER_ID&gt;
</code></pre></div>

<p>您应该会看到类似这样的内容:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"Status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"starting"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"FailingStreak"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"Log"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"/>
<span class="w">    </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="nt">"Start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2021-02-23T03:34:39.644618421Z"</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="nt">"End"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2021-02-23T03:34:39.784855122Z"</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="nt">"ExitCode"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="nt">"Output"</span><span class="p">:</span><span class="w"> </span><span class="s2">"  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0curl: (7) Failed to connect to localhost port 5001: Connection refused\n"</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="w">  </span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>Docker Swarm Visualizer仪表盘中的服务也应该关闭。</p>
<p><img data-src="/static/images/blog/flask-docker-swarm/visualizer3.png" loading="lazy" class="lazyload" alt="docker swarm visualizer" src="../Images/e99a41fdb8622237e671270f161684b9.png" data-original-src="https://testdriven.io/static/images/blog/flask-docker-swarm/visualizer3.png"/></p>
<p>更新运行状况检查和服务。在继续前进之前确保一切正常。</p>
<h2 id="logging">记录</h2>
<p>在使用分布式系统时，设置适当的日志记录和监控非常重要，这样当出现问题时，您就可以深入了解发生了什么。我们已经设置了Docker Swarm Visualizer工具来帮助监控，但还有更多的事情可以做。</p>
<p>在日志记录方面，您可以运行以下命令(从节点管理器)来访问在多个节点上运行的服务的日志:</p>
<div class="codehilite"><pre><span/><code>$ docker service logs -f SERVICE_NAME
</code></pre></div>

<blockquote>
<p>查看文档，了解更多关于<a href="https://docs.docker.com/engine/reference/commandline/service_logs/#description"> logs </a>命令以及如何<a href="https://docs.docker.com/config/containers/logging/configure/#configure-the-default-logging-driver">配置默认日志驱动程序</a>的信息。</p>
</blockquote>
<p>尝试一下:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">eval</span> <span class="k">$(</span>docker-machine env node-1<span class="k">)</span>
$ docker service logs -f flask_web
</code></pre></div>

<p>您可能希望汇总每个服务的日志事件，以帮助简化分析和可视化。一种流行的方法是在Swarm集群中建立一个<a href="https://www.elastic.co/elk-stack"> ELK </a> (Elasticsearch、Logstash和Kibana)栈。这超出了这篇博文的范围，但是可以看看下面的资源来获得帮助:</p>
<ol>
<li><a href="http://callistaenterprise.se/blogg/teknik/2017/09/13/building-microservices-part-8-logging-with-ELK/">使用ELK堆栈进行集中测井</a></li>
<li><a href="https://github.com/mattjtodd/docker-swarm-elk">Docker Swarm ELK Stack示例</a></li>
<li><a href="https://github.com/elastic/examples/tree/master/Miscellaneous/docker">弹性堆栈的Docker示例</a></li>
</ol>
<p>最后，<a href="https://prometheus.io/"> Prometheus </a>(连同它事实上的GUI <a href="https://grafana.com/"> Grafana </a>)是一个强大的监控解决方案。查看<a href="https://stefanprodan.com/2017/docker-swarm-instrumentation-with-prometheus/">Docker Swarm instrumentation with Prometheus</a>了解更多信息。</p>
<p><br/></p>
<p><strong>都搞定了？</strong></p>
<p>关闭堆栈并移除节点:</p>
<div class="codehilite"><pre><span/><code>$ docker stack rm flask
$ docker-machine rm node-1 node-2 node-3 node-4 -y
</code></pre></div>

<h2 id="automation-script">自动化脚本</h2>
<p>准备好把所有东西放在一起了吗？让我们编写一个脚本，它将:</p>
<ol>
<li>用Docker机器提供液滴</li>
<li>配置Docker群组模式</li>
<li>向群集添加节点</li>
<li>创建新的Docker密码</li>
<li>部署Flask微服务</li>
<li>创建数据库表并应用种子</li>
</ol>
<p>将名为<em> deploy.sh </em>的新文件添加到项目根目录:</p>
<div class="codehilite"><pre><span/><code><span class="ch">#!/bin/bash</span>


<span class="nb">echo</span> <span class="s2">"Spinning up four droplets..."</span>

<span class="k">for</span> i <span class="k">in</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span><span class="p">;</span> <span class="k">do</span>
  docker-machine create <span class="se">\</span>
    --driver digitalocean <span class="se">\</span>
    --digitalocean-access-token <span class="nv">$DIGITAL_OCEAN_ACCESS_TOKEN</span> <span class="se">\</span>
    --engine-install-url <span class="s2">"https://releases.rancher.com/install-docker/19.03.9.sh"</span> <span class="se">\</span>
    node-<span class="nv">$i</span><span class="p">;</span>
<span class="k">done</span>


<span class="nb">echo</span> <span class="s2">"Initializing Swarm mode..."</span>

docker-machine ssh node-1 -- docker swarm init --advertise-addr <span class="k">$(</span>docker-machine ip node-1<span class="k">)</span>


<span class="nb">echo</span> <span class="s2">"Adding the nodes to the Swarm..."</span>

<span class="nv">TOKEN</span><span class="o">=</span><span class="sb">`</span>docker-machine ssh node-1 docker swarm join-token worker <span class="p">|</span> grep token <span class="p">|</span> awk <span class="s1">'{ print $5 }'</span><span class="sb">`</span>

<span class="k">for</span> i <span class="k">in</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span><span class="p">;</span> <span class="k">do</span>
  docker-machine ssh node-<span class="nv">$i</span> <span class="se">\</span>
    -- docker swarm join --token <span class="si">${</span><span class="nv">TOKEN</span><span class="si">}</span> <span class="k">$(</span>docker-machine ip node-1<span class="k">)</span>:2377<span class="p">;</span>
<span class="k">done</span>


<span class="nb">echo</span> <span class="s2">"Creating secret..."</span>

<span class="nb">eval</span> <span class="k">$(</span>docker-machine env node-1<span class="k">)</span>
<span class="nb">echo</span> <span class="s2">"foobar"</span> <span class="p">|</span> docker secret create secret_code -


<span class="nb">echo</span> <span class="s2">"Deploying the Flask microservice..."</span>

docker stack deploy --compose-file<span class="o">=</span>docker-compose-swarm.yml flask


<span class="nb">echo</span> <span class="s2">"Create the DB table and apply the seed..."</span>

sleep <span class="m">15</span>
<span class="nv">NODE</span><span class="o">=</span><span class="k">$(</span>docker service ps -f <span class="s2">"desired-state=running"</span> --format <span class="s2">"{{.Node}}"</span> flask_web<span class="k">)</span>
<span class="nb">eval</span> <span class="k">$(</span>docker-machine env <span class="nv">$NODE</span><span class="k">)</span>
<span class="nv">CONTAINER_ID</span><span class="o">=</span><span class="k">$(</span>docker ps --filter <span class="nv">name</span><span class="o">=</span>flask_web --format <span class="s2">"{{.ID}}"</span><span class="k">)</span>
docker container <span class="nb">exec</span> -it <span class="nv">$CONTAINER_ID</span> python manage.py recreate_db
docker container <span class="nb">exec</span> -it <span class="nv">$CONTAINER_ID</span> python manage.py seed_db


<span class="nb">echo</span> <span class="s2">"Get the IP address..."</span>
<span class="nb">eval</span> <span class="k">$(</span>docker-machine env node-1<span class="k">)</span>
docker-machine ip <span class="k">$(</span>docker service ps -f <span class="s2">"desired-state=running"</span> --format <span class="s2">"{{.Node}}"</span> flask_nginx<span class="k">)</span>
</code></pre></div>

<p>试试吧！</p>


<p>完成后将水滴带下来:</p>
<div class="codehilite"><pre><span/><code>$ docker-machine rm node-1 node-2 node-3 node-4 -y
</code></pre></div>

<h2 id="conclusion">结论</h2>
<p>在这篇文章中，我们看了如何通过Docker Swarm在DigitalOcean上运行Flask应用程序。</p>
<p>此时，您应该了解Docker Swarm的工作原理，并能够部署一个运行应用程序的集群。在生产中使用Docker Swarm之前，请确保深入了解一些更高级的主题，如日志记录、监控和使用<a href="https://docs.docker.com/engine/swarm/swarm-tutorial/rolling-update/">滚动更新</a>来实现零停机部署。</p>
<p>你可以在GitHub上的<a href="https://github.com/testdrivenio/flask-docker-swarm"> flask-docker-swarm </a> repo中找到代码。</p>
  </div>

  </div>    
</body>
</html>