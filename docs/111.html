<html>
<head>
<title>Managing Secrets with Vault and Consul </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Vault和Consul管理秘密</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/managing-secrets-with-vault-and-consul/#0001-01-01">https://testdriven.io/blog/managing-secrets-with-vault-and-consul/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>下面的教程详细介绍了如何设置和使用哈希公司的<a href="https://www.vaultproject.io/">金库</a>和<a href="https://www.consul.io/">领事</a>项目来安全地存储和管理机密。</p>
<p>我们将从在Docker容器中构建一个Vault实例开始，然后开始管理静态<a href="https://learn.hashicorp.com/vault/secrets-management/sm-static-secrets">和动态</a><a href="https://learn.hashicorp.com/vault/getting-started/dynamic-secrets">秘密以及Vault的“加密即服务”特性。然后，我们将把Consul添加到这个组合中，看看如何扩展Vault。</a></p>
<blockquote>
<p>这是一个中级教程。假设你对<a href="https://www.docker.com/"> Docker </a>有基本的工作知识。还建议您通读官方文档中的<a href="https://www.vaultproject.io/docs/what-is-vault">简介</a>、<a href="https://www.vaultproject.io/docs/internals">内部</a>和<a href="https://www.vaultproject.io/docs/concepts">基本概念</a>指南，以便在开始之前熟悉跳马。</p>
</blockquote>
<p><em>主要依赖:</em></p>
<ul>
<li>文档v20.10.8</li>
<li>坞站-复合v1.29.2</li>
<li>保险库版本1.8.2</li>
<li>领事v1.10.2</li>
</ul>



<h2 id="objectives">目标</h2>
<p>学完本教程后，您应该能够:</p>
<ol>
<li>解释什么是保险库，以及为什么您可能想要使用它</li>
<li>描述基本的Vault架构以及动态和静态机密、各种后端(存储、机密、验证、审计)，以及如何将Vault用作“加密即服务”</li>
<li>配置并运行Vault，并咨询码头工人</li>
<li>使用文件系统后端启动Vault</li>
<li>初始化并解封保险库</li>
<li>根据保管库进行身份验证</li>
<li>配置审核后端以记录与Vault的所有交互</li>
<li>通过CLI、HTTP API和UI处理静态和动态机密</li>
<li>创建存储策略以限制对特定路径的访问</li>
<li>将传输后端用作“加密即服务”</li>
<li>设置Consul使用Vault作为机密的存储后端</li>
<li>定义机密的自定义租期，并在租期结束前撤销机密</li>
</ol>
<h2 id="what-is-vault">什么是跳马？</h2>
<p><a href="https://www.vaultproject.io/"> Vault </a>是一款开源工具，用于安全存储和管理机密。</p>
<blockquote>
<p>什么是秘密？在本教程的上下文中，秘密是安全敏感的或个人可识别的信息，如数据库凭证、SSH密钥、用户名和密码、AWS IAM凭证、API令牌、社会安全号、信用卡号等等。</p>
</blockquote>
<p>花点时间想想您的团队目前是如何管理和传播秘密的:</p>
<ol>
<li>谁能接触到它们？</li>
<li>谁管理他们？</li>
<li>你如何控制谁可以访问它们？</li>
<li>您的应用程序如何获得它们？</li>
<li>它们是如何更新的？</li>
<li>它们是如何被撤销的？</li>
</ol>
<p>Vault为这些问题提供了答案，并有助于解决以下与机密管理相关的问题:</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>跳马的目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>秘密无处不在。</td>
<td>金库是所有秘密真相的唯一来源。</td>
</tr>
<tr>
<td>它们通常不加密。</td>
<td>Vault管理开箱即用的加密(在传输期间和静止时)。</td>
</tr>
<tr>
<td>很难动态地生成它们。</td>
<td>秘密可以动态生成。</td>
</tr>
<tr>
<td>租赁和撤销它们就更难了。</td>
<td>秘密可以出租和撤销。</td>
</tr>
<tr>
<td>没有审计记录。</td>
<td>秘密的产生和使用都有审计记录。</td>
</tr>
</tbody>
</table>
<p>Vault有许多可移动的部分，因此可能需要一些时间来适应整体架构。花点时间回顾一下<a href="https://www.vaultproject.io/docs/internals/architecture.html">架构</a>指南，注意以下后端:</p>
<table>
<thead>
<tr>
<th>后端</th>
<th>使用</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.vaultproject.io/docs/configuration/storage">存储</a></td>
<td>秘密储存的地方</td>
<td>咨询<code>*</code>，文件系统<code>*</code>，内存中，PostgreSQL，S3</td>
</tr>
<tr>
<td><a href="https://www.vaultproject.io/docs/secrets">秘密</a></td>
<td>处理静态或动态机密</td>
<td>AWS <code>*</code>，数据库，键/值<code>*</code>，RabbitMQ，SSH</td>
</tr>
<tr>
<td><a href="https://www.vaultproject.io/docs/auth">认证</a></td>
<td>处理身份验证和授权</td>
<td>AWS，Azure，Google Cloud，GitHub，令牌<code>*</code>，用户名&amp;密码</td>
</tr>
<tr>
<td><a href="https://www.vaultproject.io/docs/audit">审计</a></td>
<td>记录所有请求和响应</td>
<td>文件<code>*</code>，系统日志，套接字</td>
</tr>
</tbody>
</table>
<p>本教程中使用的<small><code>*</code></small></p>
<p>有了这些，我们开始使用Vault。</p>
<h2 id="filesystem-backend">文件系统后端</h2>
<p>为了快速启动并运行，我们将使用<a href="https://www.vaultproject.io/docs/configuration/storage/filesystem.html">文件系统</a>后端来存储静态秘密。</p>
<blockquote>
<p>文件系统后端应仅用于本地开发或单服务器Vault部署，因为它不支持高可用性。</p>
</blockquote>
<p>创建新的项目目录:</p>
<div class="codehilite"><pre><span/><code>$ mkdir vault-consul-docker <span class="o">&amp;&amp;</span> <span class="nb">cd</span> vault-consul-docker
</code></pre></div>

<p>然后添加以下文件夹:</p>
<div class="codehilite"><pre><span/><code>└── vault
    ├── config
    ├── data
    ├── logs
    └── policies
</code></pre></div>

<p>将<em> Dockerfile </em>添加到“vault”目录:</p>
<div class="codehilite"><pre><span/><code><span class="c"># base image</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">alpine:3.14</span>

<span class="c"># set vault version</span>
<span class="k">ENV</span><span class="w"> </span>VAULT_VERSION <span class="m">1</span>.8.2

<span class="c"># create a new directory</span>
<span class="k">RUN</span><span class="w"> </span>mkdir /vault

<span class="c"># download dependencies</span>
<span class="k">RUN</span><span class="w"> </span>apk --no-cache add <span class="se">\</span>
      bash <span class="se">\</span>
      ca-certificates <span class="se">\</span>
      wget

<span class="c"># download and set up vault</span>
<span class="k">RUN</span><span class="w"> </span>wget --quiet --output-document<span class="o">=</span>/tmp/vault.zip https://releases.hashicorp.com/vault/<span class="si">${</span><span class="nv">VAULT_VERSION</span><span class="si">}</span>/vault_<span class="si">${</span><span class="nv">VAULT_VERSION</span><span class="si">}</span>_linux_amd64.zip <span class="o">&amp;&amp;</span> <span class="se">\</span>
    unzip /tmp/vault.zip -d /vault <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -f /tmp/vault.zip <span class="o">&amp;&amp;</span> <span class="se">\</span>
    chmod +x /vault

<span class="c"># update PATH</span>
<span class="k">ENV</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"PATH=</span><span class="nv">$PATH</span><span class="s2">:</span><span class="nv">$PWD</span><span class="s2">/vault"</span>

<span class="c"># add the config file</span>
<span class="k">COPY</span><span class="w"> </span>./config/vault-config.json /vault/config/vault-config.json

<span class="c"># expose port 8200</span>
<span class="k">EXPOSE</span><span class="w"> </span><span class="s">8200</span>

<span class="c"># run vault</span>
<span class="k">ENTRYPOINT</span><span class="w"> </span><span class="p">[</span><span class="s2">"vault"</span><span class="p">]</span>
</code></pre></div>

<p>接下来，将一个<em> docker-compose.yml </em>文件添加到项目根:</p>
<div class="codehilite"><pre><span/><code><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">'3.8'</span><span class="w"/>

<span class="nt">services</span><span class="p">:</span><span class="w"/>

<span class="w">  </span><span class="nt">vault</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">context</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault</span><span class="w"/>
<span class="w">      </span><span class="nt">dockerfile</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Dockerfile</span><span class="w"/>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8200:8200</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault/config:/vault/config</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault/policies:/vault/policies</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault/data:/vault/data</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault/logs:/vault/logs</span><span class="w"/>
<span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">VAULT_ADDR=http://127.0.0.1:8200</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">VAULT_API_ADDR=http://127.0.0.1:8200</span><span class="w"/>
<span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">server -config=/vault/config/vault-config.json</span><span class="w"/>
<span class="w">    </span><span class="nt">cap_add</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">IPC_LOCK</span><span class="w"/>
</code></pre></div>

<p>将名为<em> vault-config.json </em>的配置文件添加到“vault/config”中:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"backend"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"file"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="nt">"path"</span><span class="p">:</span><span class="w"> </span><span class="s2">"vault/data"</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="w">  </span><span class="p">},</span><span class="w"/>
<span class="w">  </span><span class="nt">"listener"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"tcp"</span><span class="p">:{</span><span class="w"/>
<span class="w">      </span><span class="nt">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.0.0.0:8200"</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="nt">"tls_disable"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="w">  </span><span class="p">},</span><span class="w"/>
<span class="w">  </span><span class="nt">"ui"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>在这里，我们将Vault配置为使用文件系统后端，为Vault定义了<a href="https://www.vaultproject.io/docs/configuration/listener/tcp.html">监听器</a>,<a href="https://www.vaultproject.io/docs/configuration/listener/tcp.html#tls_disable">禁用了TLS </a>，并启用了<a href="https://www.vaultproject.io/docs/configuration/ui"> Vault UI </a>。查看<a href="https://www.vaultproject.io/docs/configuration">文档</a>了解更多关于配置保险库的信息。</p>
<p>现在我们可以构建图像并旋转容器:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose up -d --build
</code></pre></div>

<p>调出Docker日志，确保构建中没有错误:</p>


<p>您应该会看到类似如下的内容:</p>
<div class="codehilite"><pre><span/><code>Attaching to vault-consul-docker_vault_1
vault_1  <span class="p">|</span> <span class="o">==</span>&gt; Vault server configuration:
vault_1  <span class="p">|</span>
vault_1  <span class="p">|</span>              Api Address: http://127.0.0.1:8200
vault_1  <span class="p">|</span> <span class="m">2021</span>-09-08T14:48:35.014Z <span class="o">[</span>INFO<span class="o">]</span>  proxy environment: <span class="nv">http_proxy</span><span class="o">=</span><span class="s2">""</span> <span class="nv">https_proxy</span><span class="o">=</span><span class="s2">""</span> <span class="nv">no_proxy</span><span class="o">=</span><span class="s2">""</span>
vault_1  <span class="p">|</span>                      Cgo: disabled
vault_1  <span class="p">|</span>          Cluster Address: https://127.0.0.1:8201
vault_1  <span class="p">|</span>               Go Version: go1.16.7
vault_1  <span class="p">|</span>               Listener <span class="m">1</span>: tcp <span class="o">(</span>addr: <span class="s2">"0.0.0.0:8200"</span>, cluster address: <span class="s2">"0.0.0.0:8201"</span>, max_request_duration: <span class="s2">"1m30s"</span>, max_request_size: <span class="s2">"33554432"</span>, tls: <span class="s2">"disabled"</span><span class="o">)</span>
vault_1  <span class="p">|</span>                Log Level: info
vault_1  <span class="p">|</span>                    Mlock: supported: true, enabled: <span class="nb">true</span>
vault_1  <span class="p">|</span>            Recovery Mode: <span class="nb">false</span>
vault_1  <span class="p">|</span>                  Storage: file
vault_1  <span class="p">|</span>                  Version: Vault v1.8.2
vault_1  <span class="p">|</span>              Version Sha: aca76f63357041a43b49f3e8c11d67358496959f
vault_1  <span class="p">|</span>
vault_1  <span class="p">|</span> <span class="o">==</span>&gt; Vault server started! Log data will stream <span class="k">in</span> below:
vault_1  <span class="p">|</span>
</code></pre></div>

<h2 id="initializing-and-unsealing">初始化和解封</h2>
<p>在运行的容器中启动bash会话:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose <span class="nb">exec</span> vault bash
</code></pre></div>

<p>在shell中，初始化Vault:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault operator init
</code></pre></div>

<p>记下解封密钥和初始根令牌。每次重新密封或重新启动Vault服务器时，您都需要提供三个解封密钥。</p>
<blockquote>
<p>为什么是三把钥匙？回顾<a href="https://en.wikipedia.org/wiki/Shamir's_Secret_Sharing">沙米尔的秘密分享</a>。</p>
</blockquote>
<p>现在，您可以使用以下三个密钥解封保险库:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault operator unseal
Unseal Key <span class="o">(</span>will be hidden<span class="o">)</span>:
</code></pre></div>

<p>运行这个命令两次以上，每次使用不同的密钥。一旦完成，确保<code>Sealed</code>是<code>false</code>:</p>
<div class="codehilite"><pre><span/><code>Key             Value
---             -----
Seal Type       shamir
Initialized     <span class="nb">true</span>
Sealed          <span class="nb">false</span>
Total Shares    <span class="m">5</span>
Threshold       <span class="m">3</span>
Version         <span class="m">1</span>.8.2
Storage Type    file
Cluster Name    vault-cluster-8fcf9d05
Cluster ID      d86e0274-ad9c-d2c1-d6ec-baeab410797b
HA Enabled      <span class="nb">false</span>
</code></pre></div>

<p>使用根令牌，您现在可以进行身份验证:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault login
Token <span class="o">(</span>will be hidden<span class="o">)</span>:
</code></pre></div>

<p>您应该会看到类似如下的内容:</p>
<div class="codehilite"><pre><span/><code>Success! You are now authenticated. The token information displayed below
is already stored <span class="k">in</span> the token helper. You <span class="k">do</span> NOT need to run <span class="s2">"vault login"</span>
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                s.c0kYHWiOTqQvtR8JuSeTz6sZ
token_accessor       3FQJVxOY5C1brzlHHQSFaCdZ
token_duration       ∞
token_renewable      <span class="nb">false</span>
token_policies       <span class="o">[</span><span class="s2">"root"</span><span class="o">]</span>
identity_policies    <span class="o">[]</span>
policies             <span class="o">[</span><span class="s2">"root"</span><span class="o">]</span>
</code></pre></div>

<blockquote>
<p>请记住，这使用了根策略。在生产中，您会希望设置具有不同访问级别的策略。我们很快就会看到如何做到这一点。</p>
</blockquote>
<p><img data-src="/static/images/gifs/blog/vault-consul-docker/vault-init.gif" loading="lazy" class="lazyload" alt="vault init" src="../Images/de953946d93734de93c2b18b11654836.png" data-original-src="https://testdriven.io/static/images/gifs/blog/vault-consul-docker/vault-init.gif"/></p>
<p>保险库现已解封，可以使用了。</p>
<h2 id="auditing">审计</h2>
<p>在我们测试功能之前，让我们启用一个<a href="https://www.vaultproject.io/docs/audit">审计设备</a>:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault audit <span class="nb">enable</span> file <span class="nv">file_path</span><span class="o">=</span>/vault/logs/audit.log

Success! Enabled the file audit device at: file/
</code></pre></div>

<p>现在，您应该能够在“vault/logs”中本地查看日志。要进行测试，请运行以下命令来查看所有启用的审核设备:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault audit list

Path     Type    Description
----     ----    -----------
file/    file    n/a
</code></pre></div>

<p>请求和后续响应应记录在<em> vault/logs/audit.log </em>中。看一看。</p>
<h2 id="secrets">秘密</h2>
<p>跳马的秘密有两种:<a href="https://learn.hashicorp.com/vault/secrets-management/sm-static-secrets">静态</a>和<a href="https://learn.hashicorp.com/vault/getting-started/dynamic-secrets">动态</a>。</p>
<ol>
<li>
<p>静态机密(比如加密的Redis或Memcached)有刷新间隔，但除非明确撤销，否则不会过期。它们预先用<a href="https://www.vaultproject.io/docs/secrets/kv">键/值</a>后端(以前的“通用”后端)定义，然后共享。</p>
<p><img data-src="/static/images/blog/vault-consul-docker/vault-secure_secret_storage.png" loading="lazy" class="lazyload" alt="secure secret storage" src="../Images/22403a708a73706da2b51efe5c19ff60.png" data-original-src="https://testdriven.io/static/images/blog/vault-consul-docker/vault-secure_secret_storage.png"/></p>
</li>
<li>
<p><strong>动态</strong>秘密按需生成。他们有强制租约，通常在短期内到期。因为它们在被访问之前是不存在的，所以暴露的机会更少——所以动态秘密更安全。Vault附带了许多动态后端——即<a href="https://www.vaultproject.io/docs/secrets/aws"> AWS </a>、<a href="https://www.vaultproject.io/docs/secrets/databases">数据库</a>、<a href="https://www.vaultproject.io/docs/secrets/gcp">谷歌云</a>、<a href="https://www.vaultproject.io/docs/secrets/consul">领事</a>和<a href="https://www.vaultproject.io/docs/secrets/rabbitmq"> RabbitMQ </a>。</p>
</li>
</ol>
<blockquote>
<p>查看<a href="https://www.hashicorp.com/blog/why-we-need-dynamic-secrets">为什么我们需要动态秘密</a>的博客文章，了解更多关于使用动态秘密的优势的信息。</p>
</blockquote>
<h2 id="static-secrets">静态秘密</h2>
<p>可以通过<a href="https://www.vaultproject.io/docs/commands"> CLI </a>、<a href="https://www.vaultproject.io/api-docs"> HTTP API </a>或<a href="https://www.vaultproject.io/docs/configuration/ui"> UI </a>管理Vault。</p>
<h3 id="cli">硬币指示器 （coin-levelindicator的缩写）命令行界面（Command Line Interface for batch scripting）</h3>
<p>仍然在容器的bash会话中，我们可以创建、读取、更新和删除秘密。我们还将了解如何版本化和回滚机密。</p>
<p>使用以下命令启用机密:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault secrets <span class="nb">enable</span> kv

Success! Enabled the kv secrets engine at: kv/
</code></pre></div>

<p>在<code>kv/foo</code>路径中创建一个密钥为<code>bar</code>值为<code>precious</code>的新秘密:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv put kv/foo <span class="nv">bar</span><span class="o">=</span>precious

Success! Data written to: kv/foo
</code></pre></div>

<p>阅读:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv get kv/foo

<span class="o">===</span> <span class="nv">Data</span> <span class="o">===</span>
Key    Value
---    -----
bar    precious
</code></pre></div>

<p>要使用特定键的不同版本，我们需要升级到<a href="https://www.vaultproject.io/docs/secrets/kv">键/值</a>后端的<a href="https://www.vaultproject.io/docs/secrets/kv/kv-v2.html"> v2 </a>:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv enable-versioning kv/

Success! Tuned the secrets engine at: kv/
</code></pre></div>

<p>通过将值更新为<code>copper</code>来添加版本2:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv put kv/foo <span class="nv">bar</span><span class="o">=</span>copper

Key              Value
---              -----
created_time     <span class="m">2021</span>-09-08T18:23:14.4154928Z
deletion_time    n/a
destroyed        <span class="nb">false</span>
version          <span class="m">2</span>
</code></pre></div>

<p>阅读版本1:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv get -version<span class="o">=</span><span class="m">1</span> kv/foo

<span class="o">======</span> <span class="nv">Metadata</span> <span class="o">======</span>
Key              Value
---              -----
created_time     <span class="m">2021</span>-09-08T18:22:37.2548824Z
deletion_time    n/a
destroyed        <span class="nb">false</span>
version          <span class="nv">1</span>

<span class="o">===</span> <span class="nv">Data</span> <span class="o">===</span>
Key    Value
---    -----
bar    precious
</code></pre></div>

<p>阅读版本2:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv get -version<span class="o">=</span><span class="m">2</span> kv/foo

<span class="o">======</span> <span class="nv">Metadata</span> <span class="o">======</span>
Key              Value
---              -----
created_time     <span class="m">2021</span>-09-08T18:23:14.4154928Z
deletion_time    n/a
destroyed        <span class="nb">false</span>
version          <span class="nv">2</span>

<span class="o">===</span> <span class="nv">Data</span> <span class="o">===</span>
Key    Value
---    -----
bar    copper
</code></pre></div>

<p>删除最新版本(如版本2):</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv delete kv/foo

Success! Data deleted <span class="o">(</span><span class="k">if</span> it existed<span class="o">)</span> at: kv/foo
</code></pre></div>

<p>删除版本1:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv delete -versions<span class="o">=</span><span class="m">1</span> kv/foo

Success! Data deleted <span class="o">(</span><span class="k">if</span> it existed<span class="o">)</span> at: kv/foo
</code></pre></div>

<p>您也可以取消删除:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv undelete -versions<span class="o">=</span><span class="m">1</span> kv/foo

Success! Data written to: kv/undelete/foo
</code></pre></div>

<p>删除类似于软删除。如果您想删除底层元数据，您必须使用<a href="https://www.vaultproject.io/api/secret/kv/kv-v2.html#destroy-secret-versions"> destroy </a>命令:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv destroy -versions<span class="o">=</span><span class="m">1</span> kv/foo

Success! Data written to: kv/destroy/foo
</code></pre></div>

<p>查看<a href="https://www.vaultproject.io/api/secret/kv/kv-v1.html"> v1 </a>和<a href="https://www.vaultproject.io/docs/secrets/kv"> v2 </a>以查看所有可用的命令。</p>
<blockquote>
<p>记下审计日志。上面的每个请求都被记录了！</p>
</blockquote>
<h3 id="api">应用程序接口</h3>
<p>您还可以通过<a href="https://learn.hashicorp.com/vault/getting-started/apis"> HTTP API </a>与Vault进行交互。我们将针对API的<a href="https://www.vaultproject.io/api/secret/kv/kv-v2.html"> v2 </a>提出请求。打开一个新的终端选项卡，然后将根令牌设置为环境变量:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">export</span> <span class="nv">VAULT_TOKEN</span><span class="o">=</span>your_token_goes_here
</code></pre></div>

<p>创建一个名为<code>foo</code>的新秘密，其值为<code>world</code>:</p>
<div class="codehilite"><pre><span/><code>$ curl <span class="se">\</span>
    -H <span class="s2">"X-Vault-Token: </span><span class="nv">$VAULT_TOKEN</span><span class="s2">"</span> <span class="se">\</span>
    -H <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
    -X POST <span class="se">\</span>
    -d <span class="s1">'{ "data": { "foo": "world" } }'</span> <span class="se">\</span>
    http://127.0.0.1:8200/v1/kv/data/hello
</code></pre></div>

<p>阅读秘密:</p>
<div class="codehilite"><pre><span/><code>$ curl <span class="se">\</span>
    -H <span class="s2">"X-Vault-Token: </span><span class="nv">$VAULT_TOKEN</span><span class="s2">"</span> <span class="se">\</span>
    -X GET <span class="se">\</span>
    http://127.0.0.1:8200/v1/kv/data/hello
</code></pre></div>

<p>JSON响应应该包含一个<code>data</code>键，其值类似于:</p>
<div class="codehilite"><pre><span/><code><span class="s2">"data"</span>: <span class="o">{</span>
  <span class="s2">"data"</span>:<span class="o">{</span>
    <span class="s2">"foo"</span>: <span class="s2">"world"</span>
  <span class="o">}</span>,
  <span class="s2">"metadata"</span>: <span class="o">{</span>
    <span class="s2">"created_time"</span>: <span class="s2">"2021-09-08T18:30:32.5140484Z"</span>,
    <span class="s2">"deletion_time"</span>: <span class="s2">""</span>,
    <span class="s2">"destroyed"</span>: false,
    <span class="s2">"version"</span>: <span class="m">1</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p><img data-src="/static/images/gifs/blog/vault-consul-docker/vault-api-static-secrets.gif" loading="lazy" class="lazyload" alt="vault api" src="../Images/be308cc2fe26afe28ece8bf830e7b7bf.png" data-original-src="https://testdriven.io/static/images/gifs/blog/vault-consul-docker/vault-api-static-secrets.gif"/></p>
<p>尝试自己添加、删除和销毁新版本。</p>
<h3 id="ui">用户界面</h3>
<p><a href="https://www.vaultproject.io/docs/configuration/ui"> UI </a>应该在<a href="http://localhost:8200/ui/vault">http://localhost:8200/UI/vault</a>上运行。使用根令牌登录。然后，自己探索键/值后端:</p>
<p><img data-src="/static/images/blog/vault-consul-docker/vault-ui_new.png" loading="lazy" class="lazyload" alt="vault ui" src="../Images/e33b57dd888feb76e904fe8f29c256ec.png" data-original-src="https://testdriven.io/static/images/blog/vault-consul-docker/vault-ui_new.png"/></p>
<h2 id="policies">政策</h2>
<p>到目前为止，我们一直使用<a href="https://www.vaultproject.io/docs/concepts/policies.html#root-policy">根策略</a>与API交互。让我们设置一个只有读权限的策略。</p>
<p>将名为<em> app-policy.json </em>的新配置文件添加到“vault/policies”中:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"path"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"kv/data/app/*"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="nt">"policy"</span><span class="p">:</span><span class="w"> </span><span class="s2">"read"</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="w">  </span><span class="p">}</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p><a href="https://www.vaultproject.io/docs/concepts/policies.html#creating-policies">在bash会话中创建</a>一个新策略:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault policy write app /vault/policies/app-policy.json

Success! Uploaded policy: app
</code></pre></div>

<p>然后，创建一个新令牌:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault token create -policy<span class="o">=</span>app

Key                  Value
---                  -----
token                s.ZOUMx3RIhVRhI4ijlZg8KXRQ
token_accessor       TT53xOxbIfGjI7l4392gjXcg
token_duration       768h
token_renewable      <span class="nb">true</span>
token_policies       <span class="o">[</span><span class="s2">"app"</span> <span class="s2">"default"</span><span class="o">]</span>
identity_policies    <span class="o">[]</span>
policies             <span class="o">[</span><span class="s2">"app"</span> <span class="s2">"default"</span><span class="o">]</span>
</code></pre></div>

<p>在另一个新的终端选项卡中(现在应该有三个了)，添加带有新令牌的<code>VAULT_TOKEN</code>环境变量:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">export</span> <span class="nv">VAULT_TOKEN</span><span class="o">=</span>your_token_goes_here
</code></pre></div>

<p>试着读出我们之前设定的<code>foo</code>秘密:</p>
<div class="codehilite"><pre><span/><code>$ curl <span class="se">\</span>
    -H <span class="s2">"X-Vault-Token: </span><span class="nv">$VAULT_TOKEN</span><span class="s2">"</span> <span class="se">\</span>
    -X GET <span class="se">\</span>
    http://127.0.0.1:8200/v1/kv/data/hello
</code></pre></div>

<p>您应该没有查看该机密的正确权限:</p>
<div class="codehilite"><pre><span/><code><span class="o">{</span>
  <span class="s2">"errors"</span>:<span class="o">[</span>
    <span class="s2">"1 error occurred:\n\t* permission denied\n\n"</span>
  <span class="o">]</span>
<span class="o">}</span>
</code></pre></div>

<p>为什么我们连它都看不懂？跳回到<em> vault-config.json </em>中的策略配置。<code>kv/data/app/*</code>表示策略只能从<code>app</code>路径读取。</p>
<blockquote>
<p>你可能已经注意到了，Vault中的几乎所有东西都是基于路径的。</p>
</blockquote>
<p>回到容器中的bash会话，向<code>app/test</code>路径添加一个新的秘密:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault kv put kv/app/test <span class="nv">ping</span><span class="o">=</span>pong

Key              Value
---              -----
created_time     <span class="m">2021</span>-09-08T18:40:35.2694047Z
deletion_time    n/a
destroyed        <span class="nb">false</span>
version          <span class="m">1</span>
</code></pre></div>

<p>您应该能够使用与<code>app</code>策略相关联的令牌来查看秘密:</p>
<div class="codehilite"><pre><span/><code>$ curl <span class="se">\</span>
    -H <span class="s2">"X-Vault-Token: </span><span class="nv">$VAULT_TOKEN</span><span class="s2">"</span> <span class="se">\</span>
    -X GET <span class="se">\</span>
    http://127.0.0.1:8200/v1/kv/data/app/test
</code></pre></div>

<p>也可以从用户界面管理策略:</p>
<p><img data-src="/static/images/blog/vault-consul-docker/vault-ui-policies_new.png" loading="lazy" class="lazyload" alt="vault ui" src="../Images/77a90a80de7a53d542a588909330be4b.png" data-original-src="https://testdriven.io/static/images/blog/vault-consul-docker/vault-ui-policies_new.png"/></p>
<h2 id="encryption-as-a-service">加密即服务</h2>
<p>在我们研究动态秘密之前，让我们快速回顾一下<a href="https://www.vaultproject.io/docs/secrets/transit">传输</a>后端，它可以作为“加密即服务”用于:</p>
<ul>
<li>加密和解密“传输中”的数据，而不将其存储在保险库中</li>
<li>轻松将加密集成到您的应用程序工作流程中</li>
</ul>
<p>回到容器中的bash会话，启用传输:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault secrets <span class="nb">enable</span> transit

Success! Enabled the transit secrets engine at: transit/
</code></pre></div>

<p>配置命名加密密钥:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault write -f transit/keys/foo

Success! Data written to: transit/keys/foo
</code></pre></div>

<p>加密:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault write transit/encrypt/foo <span class="nv">plaintext</span><span class="o">=</span><span class="k">$(</span>base64 <span class="o">&lt;&lt;&lt;</span> <span class="s2">"my precious"</span><span class="k">)</span>

Key           Value
---           -----
ciphertext    vault:v1:cFnk5AQLE9Mg+mZ7Ej17vRmYT5aqheikdZQ1FC4vre5jAod0L/uHDA<span class="o">==</span>
</code></pre></div>

<p>解密:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault write transit/decrypt/foo <span class="nv">ciphertext</span><span class="o">=</span>vault:v1:cFnk5AQLE9Mg+mZ7Ej17vRmYT5aqheikdZQ1FC4vre5jAod0L/uHDA<span class="o">==</span>

Key          Value
---          -----
plaintext    bXkgcHJlY2lvdXMK
</code></pre></div>

<p>解码:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# base64 -d <span class="o">&lt;&lt;&lt;</span> <span class="s2">"bXkgcHJlY2lvdXMK"</span>

my precious
</code></pre></div>

<p>也在用户界面中进行测试:</p>
<p><img data-src="/static/images/gifs/blog/vault-consul-docker/vault-ui-transit.gif" loading="lazy" class="lazyload" alt="vault ui" src="../Images/1905bd4058852765dca971feb9cd275a.png" data-original-src="https://testdriven.io/static/images/gifs/blog/vault-consul-docker/vault-ui-transit.gif"/></p>
<h2 id="dynamic-secrets">动态秘密</h2>
<p>如前所述，Vault支持许多动态秘密后端，用于在需要时动态生成秘密。例如，使用<a href="https://www.vaultproject.io/docs/secrets/aws"> AWS </a>和<a href="https://www.vaultproject.io/docs/secrets/gcp"> Google Cloud </a>后端，您可以基于IAM策略创建访问凭证。与此同时，<a href="https://www.vaultproject.io/docs/secrets/databases">数据库</a>后端基于配置的角色生成数据库凭证。</p>
<p><em>动态秘密:</em></p>
<ul>
<li>按需生成</li>
<li>基于角色具有有限的访问权限</li>
<li>被租赁一段时间</li>
<li>可以撤销</li>
<li>附带一份审计记录</li>
</ul>
<p>让我们看看如何使用AWS后端生成AWS凭证。</p>
<h4 id="aws-credentials">AWS凭据</h4>
<p>启用AWS机密后端:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault secrets <span class="nb">enable</span> -path<span class="o">=</span>aws aws

Success! Enabled the aws secrets engine at: aws/
</code></pre></div>

<p>认证:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault write aws/config/root <span class="nv">access_key</span><span class="o">=</span>foo <span class="nv">secret_key</span><span class="o">=</span>bar

Success! Data written to: aws/config/root
</code></pre></div>

<blockquote>
<p>确保分别用您的AWS访问密钥id和秘密密钥替换<code>foo</code>和<code>bar</code>。</p>
</blockquote>
<p>创建角色:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault write aws/roles/ec2-read <span class="nv">credential_type</span><span class="o">=</span>iam_user <span class="nv">policy_document</span><span class="o">=</span>-<span class="s">&lt;&lt;EOF</span>
<span class="s">{</span>
<span class="s">  "Version": "2012-10-17",</span>
<span class="s">  "Statement": [</span>
<span class="s">    {</span>
<span class="s">      "Sid": "Stmt1426528957000",</span>
<span class="s">      "Effect": "Allow",</span>
<span class="s">      "Action": [</span>
<span class="s">        "ec2:*"</span>
<span class="s">      ],</span>
<span class="s">      "Resource": [</span>
<span class="s">        "*"</span>
<span class="s">      ]</span>
<span class="s">    }</span>
<span class="s">  ]</span>
<span class="s">}</span>
<span class="s">EOF</span>

Success! Data written to: aws/roles/ec2-read
</code></pre></div>

<p>这里，我们基于<code>AmazonEC2ReadOnlyAccess</code>创建了一个新角色，这是一个AWS管理的<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html">策略</a>。顾名思义，它给予用户对EC2控制台的只读访问权；他们不能执行任何操作或创建新资源。您还可以使用内嵌策略根据您的个人需求创建自定义角色。我们很快就会看到一个例子。更多信息请参考<a href="https://www.vaultproject.io/docs/secrets/aws"> AWS秘密引擎</a>文档。</p>
<blockquote>
<p><strong>记住</strong>:动态秘密只有在被请求时才会生成(例如，一个web应用程序请求访问S3)。在此之前，商店里没有这些东西。</p>
</blockquote>
<p>创建一组新的凭据:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault <span class="nb">read</span> aws/creds/ec2-read

Key                Value
---                -----
lease_id           aws/creds/ec2-read/9KdO6J7KVBiSwOPEvwrqqALG
lease_duration     768h
lease_renewable    <span class="nb">true</span>
access_key         AKIAZ4DZAKZKEULSDW5A
secret_key         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
security_token     &lt;nil&gt;
</code></pre></div>

<p>现在，您应该能够在AWS上的<a href="https://console.aws.amazon.com/iam"> IAM控制台</a>的“用户”部分看到该用户:</p>
<p><img data-src="/static/images/blog/vault-consul-docker/iam_new.png" loading="lazy" class="lazyload" alt="aws iam" src="../Images/29349953e3bc194c7c0dfd9fd9cc271f.png" data-original-src="https://testdriven.io/static/images/blog/vault-consul-docker/iam_new.png"/></p>
<h2 id="leases-and-revocation">租赁和撤销</h2>
<p>在这一节中，我们将快速看一下如何定义一个自定义的租期，并在租期结束前撤销一个秘密。</p>
<p>创建新的AWS角色:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault write aws/roles/foo <span class="nv">credential_type</span><span class="o">=</span>iam_user <span class="nv">policy_document</span><span class="o">=</span>-<span class="s">&lt;&lt;EOF</span>
<span class="s">{</span>
<span class="s">  "Version": "2012-10-17",</span>
<span class="s">  "Statement": [</span>
<span class="s">    {</span>
<span class="s">      "Sid": "Stmt1426528957000",</span>
<span class="s">      "Effect": "Allow",</span>
<span class="s">      "Action": [</span>
<span class="s">        "ec2:*"</span>
<span class="s">      ],</span>
<span class="s">      "Resource": [</span>
<span class="s">        "*"</span>
<span class="s">      ]</span>
<span class="s">    }</span>
<span class="s">  ]</span>
<span class="s">}</span>
<span class="s">EOF</span>

Success! Data written to: aws/roles/foo
</code></pre></div>

<p>创建新的AWS凭证时，请注意<code>lease_duration</code>:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault <span class="nb">read</span> aws/creds/foo

Key                Value
---                -----
lease_id           aws/creds/foo/F0oBbnBIHEoz0ywVVtbuJB7r
lease_duration     768h
lease_renewable    <span class="nb">true</span>
access_key         AKIAZ4DZAKZKLJKB7CPX
secret_key         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
security_token     &lt;nil&gt;
</code></pre></div>

<p>如果您只希望所有AWS IAM动态机密的租期为30分钟，会怎么样？</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault write aws/config/lease <span class="nv">lease</span><span class="o">=</span>1800s <span class="nv">lease_max</span><span class="o">=</span>1800s
</code></pre></div>

<p>在本例中，由于<code>lease_max</code>与<code>lease</code>相同，您将无法续订令牌。如果你将<code>lease_max</code>设置为<code>3600s</code>，你就可以续租一次。有关更多信息，请查看<a href="https://learn.hashicorp.com/vault/identity-access-management/tokens">令牌和租赁</a>指南。</p>
<p>创建新凭据:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault <span class="nb">read</span> aws/creds/foo

Key                Value
---                -----
lease_id           aws/creds/foo/xQlJpKDS1ljE9Awz0aywXgbB
lease_duration     30m
lease_renewable    <span class="nb">true</span>
access_key         AKIAZ4DZAKZKJPL5OM5W
secret_key         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
security_token     &lt;nil&gt;
</code></pre></div>

<p>想要快速吊销此凭据吗？抓住<code>lease_id</code>然后跑:</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault lease revoke aws/creds/foo/xQlJpKDS1ljE9Awz0aywXgbB
</code></pre></div>

<p>想要撤销所有AWS信用？</p>
<div class="codehilite"><pre><span/><code>bash-5.1# vault lease revoke -prefix aws/
</code></pre></div>

<p>有关这些概念的更多信息，请参考<a href="https://www.vaultproject.io/docs/concepts/lease">租赁、续订和撤销</a>指南。</p>
<h2 id="consul-backend">领事后端</h2>
<p>到目前为止，我们一直在使用<a href="https://www.vaultproject.io/docs/configuration/storage/filesystem.html">文件系统</a>后端。这将无法扩展到单台服务器之外，因此无法利用Vault的高可用性。幸运的是，有许多其他的<a href="https://www.vaultproject.io/docs/configuration/storage">存储</a>后端，像<a href="https://www.vaultproject.io/docs/configuration/storage/consul.html">领事</a>后端，是为分布式系统设计的。</p>
<p>要设置<a href="https://www.consul.io/">consult</a>，首先要更新<em> docker-compose.yml </em>文件:</p>
<div class="codehilite"><pre><span/><code><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">'3.8'</span><span class="w"/>

<span class="nt">services</span><span class="p">:</span><span class="w"/>

<span class="w">  </span><span class="nt">vault</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">context</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault</span><span class="w"/>
<span class="w">      </span><span class="nt">dockerfile</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Dockerfile</span><span class="w"/>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8200:8200</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault/config:/vault/config</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault/policies:/vault/policies</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault/data:/vault/data</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./vault/logs:/vault/logs</span><span class="w"/>
<span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">VAULT_ADDR=http://127.0.0.1:8200</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">VAULT_API_ADDR=http://127.0.0.1:8200</span><span class="w"/>
<span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">server -config=/vault/config/vault-config.json</span><span class="w"/>
<span class="w">    </span><span class="nt">cap_add</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">IPC_LOCK</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">consul</span><span class="w"/>

<span class="w">  </span><span class="nt">consul</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="nt">context</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./consul</span><span class="w"/>
<span class="w">      </span><span class="nt">dockerfile</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Dockerfile</span><span class="w"/>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8500:8500</span><span class="w"/>
<span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">agent -server -bind 0.0.0.0 -client 0.0.0.0 -bootstrap-expect 1 -config-file=/consul/config/config.json</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./consul/config/consul-config.json:/consul/config/config.json</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./consul/data:/consul/data</span><span class="w"/>
</code></pre></div>

<p>在项目根目录中添加一个名为“consul”的新目录，然后在这个新创建的目录中添加一个新的<em> Dockerfile </em>:</p>
<div class="codehilite"><pre><span/><code><span class="c"># base image</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">alpine:3.14</span>

<span class="c"># set consul version</span>
<span class="k">ENV</span><span class="w"> </span>CONSUL_VERSION <span class="m">1</span>.10.2

<span class="c"># create a new directory</span>
<span class="k">RUN</span><span class="w"> </span>mkdir /consul

<span class="c"># download dependencies</span>
<span class="k">RUN</span><span class="w"> </span>apk --no-cache add <span class="se">\</span>
      bash <span class="se">\</span>
      ca-certificates <span class="se">\</span>
      wget

<span class="c"># download and set up consul</span>
<span class="k">RUN</span><span class="w"> </span>wget --quiet --output-document<span class="o">=</span>/tmp/consul.zip https://releases.hashicorp.com/consul/<span class="si">${</span><span class="nv">CONSUL_VERSION</span><span class="si">}</span>/consul_<span class="si">${</span><span class="nv">CONSUL_VERSION</span><span class="si">}</span>_linux_amd64.zip <span class="o">&amp;&amp;</span> <span class="se">\</span>
    unzip /tmp/consul.zip -d /consul <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -f /tmp/consul.zip <span class="o">&amp;&amp;</span> <span class="se">\</span>
    chmod +x /consul/consul

<span class="c"># update PATH</span>
<span class="k">ENV</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"PATH=</span><span class="nv">$PATH</span><span class="s2">:</span><span class="nv">$PWD</span><span class="s2">/consul"</span>

<span class="c"># add the config file</span>
<span class="k">COPY</span><span class="w"> </span>./config/consul-config.json /consul/config/config.json

<span class="c"># expose ports</span>
<span class="k">EXPOSE</span><span class="w"> </span><span class="s">8300 8400 8500 8600</span>

<span class="c"># run consul</span>
<span class="k">ENTRYPOINT</span><span class="w"> </span><span class="p">[</span><span class="s2">"consul"</span><span class="p">]</span>
</code></pre></div>

<p>接下来，在“consul”目录中添加两个新目录:“config”和“data”。然后，在“config”中，添加一个名为<em> consul-config.json </em>的配置文件:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"datacenter"</span><span class="p">:</span><span class="w"> </span><span class="s2">"localhost"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"data_dir"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/consul/data"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"log_level"</span><span class="p">:</span><span class="w"> </span><span class="s2">"DEBUG"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"server"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"ui"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"ports"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"dns"</span><span class="p">:</span><span class="w"> </span><span class="mi">53</span><span class="w"/>
<span class="w">  </span><span class="p">}</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<blockquote>
<p>请务必查看咨询文档中的<a href="https://www.consul.io/docs/agent/options.html">配置</a>选项，了解有关上述选项的更多信息。</p>
</blockquote>
<p>“领事”目录现在应该是这样的:</p>
<div class="codehilite"><pre><span/><code>├── Dockerfile
├── config
│   └── consul-config.json
└── data
</code></pre></div>

<p>退出bash会话。关闭容器，然后更新Vault配置文件:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"backend"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"consul"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="nt">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"consul:8500"</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="nt">"path"</span><span class="p">:</span><span class="w"> </span><span class="s2">"vault/"</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="w">  </span><span class="p">},</span><span class="w"/>
<span class="w">  </span><span class="nt">"listener"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"tcp"</span><span class="p">:{</span><span class="w"/>
<span class="w">      </span><span class="nt">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.0.0.0:8200"</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="nt">"tls_disable"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="w">  </span><span class="p">},</span><span class="w"/>
<span class="w">  </span><span class="nt">"ui"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>所以，现在我们使用的是<a href="https://www.vaultproject.io/docs/configuration/storage/consul.html">领事</a>后端，而不是文件系统。我们使用服务名<code>consul</code>作为地址的一部分。<code>path</code>键定义了Consul的键/值存储中存储Vault数据的路径。</p>
<p>清除“vault/data”目录中的所有文件和文件夹，以删除文件系统后端。构建新映像并旋转容器:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose down
$ docker-compose up -d --build
</code></pre></div>

<p>在浏览器中导航到<a href="http://localhost:8500/ui"> http://localhost:8500/ui </a>，确保一切正常:</p>
<p><img data-src="/static/images/blog/vault-consul-docker/consul-ui.png" loading="lazy" class="lazyload" alt="consul ui" src="../Images/b217468defbcd79975603bc54ca669ef.png" data-original-src="https://testdriven.io/static/images/blog/vault-consul-docker/consul-ui.png"/></p>
<p>从CLI或UI对此进行测试。</p>
<h3 id="cli_1">硬币指示器 （coin-levelindicator的缩写）命令行界面（Command Line Interface for batch scripting）</h3>
<p>在Vault容器中创建新的bash会话:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose <span class="nb">exec</span> vault bash
</code></pre></div>

<p>然后，运行:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># Init</span>
bash-5.1# vault operator init

<span class="c1"># Unseal</span>
bash-5.1# vault operator unseal

<span class="c1"># Authenticate</span>
bash-5.1# vault login

<span class="c1"># Enable secrets</span>
bash-5.1# vault secrets <span class="nb">enable</span> kv

<span class="c1"># Add a new static secret</span>
bash-5.1# vault kv put kv/foo <span class="nv">bar</span><span class="o">=</span>precious

<span class="c1"># Read it back</span>
bash-5.1# vault kv get kv/foo
</code></pre></div>

<h3 id="ui_1">用户界面</h3>
<p><img data-src="/static/images/gifs/blog/vault-consul-docker/vault-consul.gif" loading="lazy" class="lazyload" alt="vault consul" src="../Images/563b10b4d53832df082d1b52026aea15.png" data-original-src="https://testdriven.io/static/images/gifs/blog/vault-consul-docker/vault-consul.gif"/></p>
<blockquote>
<p>请注意“vault/data”中没有文件或文件夹。你认为这是为什么？</p>
</blockquote>
<p>想再添加一个Consul服务器吗？向<em> docker-compose.yml </em>添加新服务:</p>
<div class="codehilite"><pre><span/><code><span class="nt">consul-worker</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">build</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">context</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./consul</span><span class="w"/>
<span class="w">    </span><span class="nt">dockerfile</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Dockerfile</span><span class="w"/>
<span class="w">  </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">agent -server -join consul -config-file=/consul/config/config.json</span><span class="w"/>
<span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./consul/config/consul-config.json:/consul/config/config.json</span><span class="w"/>
<span class="w">  </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">consul</span><span class="w"/>
</code></pre></div>

<p>这里，我们使用了<a href="https://www.consul.io/commands/join"> join </a>命令将这个代理连接到一个现有的集群。注意，我们只需要引用服务名:<code>consul</code>。</p>
<p>然后:</p>
<ol>
<li>退出bash会话(如有必要)</li>
<li>把集装箱拿下来</li>
<li>清空“领事/数据”中的数据目录(为什么？)</li>
<li>旋转容器并测试</li>
</ol>
<p><img data-src="/static/images/blog/vault-consul-docker/consul-ui2_new.png" loading="lazy" class="lazyload" alt="consul ui" src="../Images/2ba57d3c3d75cd35608a1750e3c0ccdb.png" data-original-src="https://testdriven.io/static/images/blog/vault-consul-docker/consul-ui2_new.png"/></p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们讨论了如何在Docker容器中设置和运行Vault和Consul。现在，您应该对如何与Vault交互以及如何执行基本操作有了清晰的了解。</p>
<p>从<a href="https://github.com/testdrivenio/vault-consul-docker">金库-领事-码头</a>仓库中获取最终代码。也可以看看<a href="https://mherman.org/presentations/vault/">的展示</a>。</p>
<p>想要更多吗？看看下面的帖子吧:</p>
<ol>
<li><a href="/blog/deploying-vault-and-consul/">部署金库和咨询</a></li>
<li><a href="/blog/dynamic-secret-generation-with-vault-and-flask/">使用金库和烧瓶的动态秘密生成</a></li>
</ol>
  </div>

  </div>    
</body>
</html>