<html>
<head>
<title>Understanding the Application and Request Contexts in Flask </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解Flask中的应用程序和请求上下文</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/flask-contexts/#0001-01-01">https://testdriven.io/blog/flask-contexts/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>这篇文章的目的是阐明应用程序和请求上下文在Flask中是如何工作的。</p>
<hr/>
<p>这是关于烧瓶环境的两部分系列的第一部分:</p>
<ol>
<li><strong>基础知识</strong> : <a href="/blog/flask-contexts/">理解Flask中的应用和请求上下文</a>(本文！)</li>
<li><strong>高级</strong> : <a href="/blog/flask-contexts-advanced/">深入了解Flask的应用和请求上下文</a></li>
</ol>



<h2 id="objectives">目标</h2>
<p>在这篇文章结束时，你应该能够解释:</p>
<ol>
<li>Flask如何处理请求对象，以及这与其他web框架有何不同</li>
<li>应用程序和请求上下文是什么</li>
<li>哪些数据存储在应用程序和请求上下文中</li>
<li>如何在正确的上下文中使用<code>current_app</code>、<code>test_request_context</code>和<code>test_client</code></li>
</ol>
<p>您还应该能够修复以下错误:</p>
<div class="codehilite"><pre><span/><code>RuntimeError: Working outside of application context.

This typically means that you attempted to use functionality that needed
to interface with the current application object <span class="k">in</span> some way. To solve
this, <span class="nb">set</span> up an application context with app.app_context<span class="o">()</span>.
</code></pre></div>

<h2 id="contexts-in-flask">烧瓶中的上下文</h2>
<p>与Django和其他web框架不同，Flask view函数不接受包含HTTP请求元数据的请求对象。</p>
<p>Django示例:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">users</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">'POST'</span><span class="p">:</span>
         <span class="c1"># Save the form data to the database</span>
         <span class="c1"># Send response</span>
   <span class="k">else</span><span class="p">:</span>
         <span class="c1"># Get all users from the database</span>
         <span class="c1"># Send response</span>
</code></pre></div>

<p>使用Flask，您可以像这样导入请求对象:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">'/users'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">'GET'</span><span class="p">,</span> <span class="s1">'POST'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">users</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">'POST'</span><span class="p">:</span>
         <span class="c1"># Save the form data to the database</span>
         <span class="c1"># Send response</span>
    <span class="k">else</span><span class="p">:</span>
         <span class="c1"># Get all users from the database</span>
         <span class="c1"># Send response</span>
</code></pre></div>

<p>在Flask示例中，请求对象看起来、感觉起来和行为起来都像一个全局变量，但它不是。</p>
<blockquote>
<p>如果请求对象是一个全局变量，您将无法运行多线程Flask应用程序，因为全局变量不是线程安全的。</p>
</blockquote>
<p>相反，Flask使用<strong> contexts </strong>来使许多对象像全局对象一样“行动”,只针对正在使用的特定上下文(线程、进程或协程)。在Flask中，这被称为<a href="https://werkzeug.palletsprojects.com/en/2.0.x/local/">上下文本地</a>。</p>
<blockquote>
<p>上下文本地类似于Python的<a href="https://docs.python.org/3/library/threading.html#thread-local-data">线程本地</a>实现，用于存储特定于一个线程的数据，但本质上不同。Flask的实现更加通用，允许工作线程、进程或协程。</p>
</blockquote>
<h2 id="data-stored-in-flask-contexts">存储在Flask上下文中的数据</h2>
<p>当接收到请求时，Flask提供两个上下文:</p>
<table>
<thead>
<tr>
<th>语境</th>
<th>描述</th>
<th>可用对象</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://flask.palletsprojects.com/en/2.0.x/appcontext/">应用</a></td>
<td>跟踪应用程序级数据(配置变量、记录器、数据库连接)</td>
<td><code>current_app</code>，<code>g</code></td>
</tr>
<tr>
<td><a href="https://flask.palletsprojects.com/en/2.0.x/reqcontext/">请求</a></td>
<td>跟踪请求级数据(URL、HTTP方法、头、请求数据、会话信息)</td>
<td><code>request</code>，<code>session</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>值得注意的是，上述每个对象通常被称为“代理”。这仅仅意味着它们是对象全局风格的代理。关于这方面的更多信息，请查看本系列的第二篇文章。</p>
</blockquote>
<p>当收到请求时，Flask处理这些上下文的创建。它们会造成混乱，因为根据应用程序所处的状态，您并不总是能够访问特定的对象。</p>
<p>我们来看几个例子。</p>
<h2 id="application-context-example">应用程序上下文示例</h2>
<p>假设您有以下Flask应用程序:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">'Welcome!'</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div>

<p>首先，让我们看看如何使用<a href="https://flask.palletsprojects.com/en/2.0.x/api/#flask.current_app"> current_app </a>对象来访问应用程序上下文。</p>
<p>在Python shell中，如果您试图在视图函数之外访问<code>current_app.config</code>对象，您应该会看到以下错误:</p>
<div class="codehilite"><pre><span/><code>$ python
&gt;&gt;&gt; from flask import current_app
&gt;&gt;&gt; current_app.config

Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, <span class="k">in</span> &lt;module&gt;
  File <span class="s2">"werkzeug/local.py"</span>, line <span class="m">347</span>, <span class="k">in</span> __getattr__
    <span class="k">return</span> getattr<span class="o">(</span>self._get_current_object<span class="o">()</span>, name<span class="o">)</span>
  File <span class="s2">"werkzeug/local.py"</span>, line <span class="m">306</span>, <span class="k">in</span> _get_current_object
    <span class="k">return</span> self.__local<span class="o">()</span>
  File <span class="s2">"flask/globals.py"</span>, line <span class="m">52</span>, <span class="k">in</span> _find_app
    raise RuntimeError<span class="o">(</span>_app_ctx_err_msg<span class="o">)</span>
RuntimeError: Working outside of application context.

This typically means that you attempted to use functionality that needed
to interface with the current application object <span class="k">in</span> some way. To solve
this, <span class="nb">set</span> up an application context with app.app_context<span class="o">()</span>.  See the
documentation <span class="k">for</span> more information.
</code></pre></div>

<p>要访问应用程序公开的对象并请求视图函数之外的上下文，您需要首先创建适当的上下文:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># without a context manager</span>
$ python

&gt;&gt;&gt; from app import app
&gt;&gt;&gt; from flask import current_app
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="nv">app_ctx</span> <span class="o">=</span> app.app_context<span class="o">()</span>
&gt;&gt;&gt; app_ctx.push<span class="o">()</span>
&gt;&gt;&gt;
&gt;&gt;&gt; current_app.config<span class="o">[</span><span class="s2">"ENV"</span><span class="o">]</span>
<span class="s1">'production'</span>
&gt;&gt;&gt; app_ctx.pop<span class="o">()</span>
&gt;&gt;&gt;
</code></pre></div>

<div class="codehilite"><pre><span/><code><span class="c1"># with a context manager</span>
$ python

&gt;&gt;&gt; from app import app
&gt;&gt;&gt; from flask import current_app
&gt;&gt;&gt;
&gt;&gt;&gt; with app.app_context<span class="o">()</span>:
...     current_app.config<span class="o">[</span><span class="s2">"ENV"</span><span class="o">]</span>
...
<span class="s1">'production'</span>
&gt;&gt;&gt;
</code></pre></div>

<h2 id="request-context-example">请求上下文示例</h2>
<p>您可以使用<a href="https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.test_request_context"> test_request_context </a>方法来创建一个请求上下文:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># without a context manager</span>
$ python

&gt;&gt;&gt; from app import app
&gt;&gt;&gt; from flask import request
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="nv">request_ctx</span> <span class="o">=</span> app.test_request_context<span class="o">()</span>
&gt;&gt;&gt; request_ctx.push<span class="o">()</span>
&gt;&gt;&gt;
&gt;&gt;&gt; request.method
<span class="s1">'GET'</span>
&gt;&gt;&gt;
&gt;&gt;&gt; request.path
<span class="s1">'/'</span>
&gt;&gt;&gt;
&gt;&gt;&gt; request_ctx.pop<span class="o">()</span>
&gt;&gt;&gt;
</code></pre></div>

<div class="codehilite"><pre><span/><code><span class="c1"># with a context manager</span>
$ python

&gt;&gt;&gt; from app import app
&gt;&gt;&gt; from flask import request
&gt;&gt;&gt;
&gt;&gt;&gt; with app.test_request_context<span class="o">(</span><span class="s1">'/'</span><span class="o">)</span>:
...     request.method
...     request.path
...
<span class="s1">'GET'</span>
<span class="s1">'/'</span>
&gt;&gt;&gt;
</code></pre></div>

<blockquote>
<p>当您想要使用请求数据而没有完整请求的开销时，通常在测试期间使用<code>test_request_context</code>。</p>
</blockquote>
<h2 id="testing-example">测试示例</h2>
<p>应用程序和请求上下文最常遇到的问题是当您的应用程序处于测试状态时:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">current_app</span>

<span class="kn">from</span> <span class="nn">app</span> <span class="kn">import</span> <span class="n">app</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">client</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">current_app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">"ENV"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"production"</span>  <span class="c1"># Error!</span>
        <span class="k">yield</span> <span class="n">client</span>


<span class="k">def</span> <span class="nf">test_index_page</span><span class="p">(</span><span class="n">client</span><span class="p">):</span>
   <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>

   <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
   <span class="k">assert</span> <span class="sa">b</span><span class="s1">'Welcome!'</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
</code></pre></div>

<p>运行时，测试将在夹具中失败:</p>
<div class="codehilite"><pre><span/><code>$ pytest
________________________ ERROR at setup of test_index_page _____________________

@pytest.fixture
def client<span class="o">()</span>:
    with app.test_client<span class="o">()</span> as client:
&gt;       assert current_app.config<span class="o">[</span><span class="s2">"ENV"</span><span class="o">]</span> <span class="o">==</span> <span class="s2">"production"</span>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    def _find_app<span class="o">()</span>:
        <span class="nv">top</span> <span class="o">=</span> _app_ctx_stack.top
        <span class="k">if</span> top is None:
&gt;           raise RuntimeError<span class="o">(</span>_app_ctx_err_msg<span class="o">)</span>
E           RuntimeError: Working outside of application context.
E
E           This typically means that you attempted to use functionality that needed
E           to interface with the current application object <span class="k">in</span> some way. To solve
E           this, <span class="nb">set</span> up an application context with app.app_context<span class="o">()</span>.  See the
E           documentation <span class="k">for</span> more information.
<span class="o">=================================</span> <span class="m">1</span> error <span class="k">in</span> <span class="m">0</span>.13s <span class="o">=================================</span>
</code></pre></div>

<p>要解决这个问题，请在访问<code>current_app</code>之前创建一个应用程序上下文<em>:</em></p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">current_app</span>

<span class="kn">from</span> <span class="nn">app</span> <span class="kn">import</span> <span class="n">app</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">client</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">():</span>  <span class="c1"># New!!</span>
            <span class="k">assert</span> <span class="n">current_app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">"ENV"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"production"</span>
        <span class="k">yield</span> <span class="n">client</span>


<span class="k">def</span> <span class="nf">test_index_page</span><span class="p">(</span><span class="n">client</span><span class="p">):</span>
   <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>

   <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
   <span class="k">assert</span> <span class="sa">b</span><span class="s1">'Welcome!'</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
</code></pre></div>

<h2 id="summary">摘要</h2>
<p>总而言之，在视图函数、CLI命令和测试函数中使用以下对象:</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>语境</th>
<th>常见错误</th>
<th>解决办法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>current_app</code></td>
<td>应用程序上下文</td>
<td>在应用程序上下文之外工作</td>
<td><code>with app.app_context():</code></td>
</tr>
<tr>
<td><code>g</code></td>
<td>应用程序上下文</td>
<td>在应用程序上下文之外工作</td>
<td><code>with app.test_request_context('/'):</code></td>
</tr>
<tr>
<td><code>request</code></td>
<td>请求上下文</td>
<td>在请求上下文之外工作</td>
<td><code>with app.test_request_context('/'):</code></td>
</tr>
<tr>
<td><code>session</code></td>
<td>请求上下文</td>
<td>在请求上下文之外工作</td>
<td><code>with app.test_request_context('/'):</code></td>
</tr>
</tbody>
</table>
<p>测试期间应使用以下方法:</p>
<table>
<thead>
<tr>
<th>烧瓶法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>test_client</code></td>
<td>Flask应用程序的测试客户端</td>
</tr>
<tr>
<td><code>test_request_context</code></td>
<td>用于测试的推送请求上下文</td>
</tr>
</tbody>
</table>
<h2 id="conclusion">结论</h2>
<p>这篇博文只是触及了应用程序和请求上下文的表面。请务必阅读本系列的第二部分以了解更多:<a href="/blog/flask-contexts-advanced/">深入了解Flask的应用和请求上下文</a></p>
<p>查看以下课程，了解如何构建、测试和部署Flask应用程序:</p>

  </div>

  </div>    
</body>
</html>