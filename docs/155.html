<html>
<head>
<title>Deploying a Flask and Vue App to Heroku with Docker and Gitlab CI </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Docker和Gitlab CI将Flask和Vue应用程序部署到Heroku</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/deploying-flask-to-heroku-with-docker-and-gitlab/#0001-01-01">https://testdriven.io/blog/deploying-flask-to-heroku-with-docker-and-gitlab/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>这篇文章着眼于如何封装一个由Flask和Vue支持的全栈web应用，并使用Gitlab CI将其部署到Heroku。</p>
<blockquote>
<p>这是一个中级教程。它假设你有Vue、Flask和Docker的基本工作知识。查看以下资源以了解更多信息:</p>
<ol>
<li>Flask:Flask、测试驱动开发(TDD)和JavaScript简介</li>
<li><a href="/developing-a-single-page-app-with-flask-and-vuejs">用Flask和Vue.js开发单页应用</a></li>
<li><a href="/courses/learn-vue/">通过构建和部署CRUD应用程序学习Vue</a></li>
<li><a href="https://docs.docker.com/engine/getstarted/">Docker入门</a></li>
</ol>
</blockquote>



<h2 id="objectives">目标</h2>
<p>本教程结束时，您将能够:</p>
<ol>
<li>使用多级构建，用单个Dockerfile将烧瓶和Vue容器化</li>
<li>使用Docker将应用程序部署到Heroku</li>
<li>配置GitLab CI以将Docker映像部署到Heroku</li>
</ol>
<h2 id="project-setup">项目设置</h2>
<p>如果你想继续，从GitHub克隆出<a href="https://github.com/testdrivenio/flask-vue-crud"> flask-vue-crud </a> repo，创建并激活一个虚拟环境，然后启动flask应用程序:</p>
<div class="codehilite"><pre><span/><code>$ git clone https://github.com/testdrivenio/flask-vue-crud
$ <span class="nb">cd</span> flask-vue-crud
$ <span class="nb">cd</span> server
$ python3.9 -m venv env
$ <span class="nb">source</span> env/bin/activate
<span class="o">(</span>env<span class="o">)</span>$

<span class="o">(</span>env<span class="o">)</span>$ pip install -r requirements.txt
<span class="o">(</span>env<span class="o">)</span>$ python app.py
</code></pre></div>

<blockquote>
<p>上述用于创建和激活虚拟环境的命令可能会因您的环境和操作系统而异。</p>
</blockquote>
<p>将您选择的浏览器指向<a href="http://localhost:5000/ping">http://localhost:5000/ping</a>。您应该看到:</p>


<p>然后，安装依赖项并在不同的终端选项卡中运行Vue应用程序:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">cd</span> client
$ npm install
$ npm run serve
</code></pre></div>

<p>导航到<a href="http://localhost:8080"> http://localhost:8080 </a>。确保基本的CRUD功能按预期工作，然后关闭两个应用程序:</p>
<p><img data-src="/static/images/gifs/blog/flask-vue/final.gif" loading="lazy" class="lazyload" alt="final app" src="../Images/140bda66d4c96397cf6bf9d8234b0c78.png" data-original-src="https://testdriven.io/static/images/gifs/blog/flask-vue/final.gif"/></p>
<blockquote>
<p>想学习如何构建这个项目吗？查看<a href="/developing-a-single-page-app-with-flask-and-vuejs">用Flask和Vue.js开发单页应用</a>的博文。</p>
</blockquote>
<h2 id="docker">码头工人</h2>
<p>先说Docker。</p>
<p>将以下Dockerfile文件添加到项目根目录。</p>
<div class="codehilite"><pre><span/><code><span class="c"># build</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:15.7.0-alpine3.10</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="s">build-vue</span>
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app</span>
<span class="k">ENV</span><span class="w"> </span>PATH /app/node_modules/.bin:<span class="nv">$PATH</span>
<span class="k">COPY</span><span class="w"> </span>./client/package*.json ./
<span class="k">RUN</span><span class="w"> </span>npm install
<span class="k">COPY</span><span class="w"> </span>./client .
<span class="k">RUN</span><span class="w"> </span>npm run build

<span class="c"># production</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">nginx:stable-alpine</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="s">production</span>
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app</span>
<span class="k">RUN</span><span class="w"> </span>apk update <span class="o">&amp;&amp;</span> apk add --no-cache python3 <span class="o">&amp;&amp;</span> <span class="se">\</span>
    python3 -m ensurepip <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -r /usr/lib/python*/ensurepip <span class="o">&amp;&amp;</span> <span class="se">\</span>
    pip3 install --upgrade pip setuptools <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="k">if</span> <span class="o">[</span> ! -e /usr/bin/pip <span class="o">]</span><span class="p">;</span> <span class="k">then</span> ln -s pip3 /usr/bin/pip <span class="p">;</span> <span class="k">fi</span> <span class="o">&amp;&amp;</span> <span class="se">\</span>
    <span class="k">if</span> <span class="o">[[</span> ! -e /usr/bin/python <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> ln -sf /usr/bin/python3 /usr/bin/python<span class="p">;</span> <span class="k">fi</span> <span class="o">&amp;&amp;</span> <span class="se">\</span>
    rm -r /root/.cache
<span class="k">RUN</span><span class="w"> </span>apk update <span class="o">&amp;&amp;</span> apk add postgresql-dev gcc python3-dev musl-dev
<span class="k">COPY</span><span class="w"> </span>--from<span class="o">=</span>build-vue /app/dist /usr/share/nginx/html
<span class="k">COPY</span><span class="w"> </span>./nginx/default.conf /etc/nginx/conf.d/default.conf
<span class="k">COPY</span><span class="w"> </span>./server/requirements.txt .
<span class="k">RUN</span><span class="w"> </span>pip install -r requirements.txt
<span class="k">RUN</span><span class="w"> </span>pip install gunicorn
<span class="k">COPY</span><span class="w"> </span>./server .
<span class="k">CMD</span><span class="w"> </span>gunicorn -b <span class="m">0</span>.0.0.0:5000 app:app --daemon <span class="o">&amp;&amp;</span> <span class="se">\</span>
      sed -i -e <span class="s1">'s/$PORT/'</span><span class="s2">"</span><span class="nv">$PORT</span><span class="s2">"</span><span class="s1">'/g'</span> /etc/nginx/conf.d/default.conf <span class="o">&amp;&amp;</span> <span class="se">\</span>
      nginx -g <span class="s1">'daemon off;'</span>
</code></pre></div>

<p>这里发生了什么事？</p>
<ol>
<li>我们使用了<a href="https://docs.docker.com/develop/develop-images/multistage-build/">多阶段构建</a>来缩小最终的图像尺寸。本质上，<code>build-vue</code>是一个临时映像，用于生成Vue应用程序的生产版本。然后，生产静态文件被复制到<code>production</code>映像，而<code>build-vue</code>映像被丢弃。</li>
<li><code>production</code>镜像通过安装Python，从<code>build-vue</code>镜像复制静态文件，复制我们的nginx配置，安装需求，运行<a href="https://gunicorn.org/"> Gunicorn </a>和<a href="https://www.nginx.com"> Nginx </a>来扩展<a href="https://hub.docker.com/_/nginx/"> nginx:stable-alpine </a>镜像。</li>
<li>记下<code>sed -i -e 's/$PORT/'"$PORT"'/g' /etc/nginx/conf.d/default.conf</code>命令。这里，我们用Heroku 提供的环境变量<code>PORT</code> <a href="https://devcenter.heroku.com/articles/dynos#web-dynos">替换<code>default.conf</code>文件中的<code>$PORT</code>。</a></li>
</ol>
<p>接下来，向项目根目录添加一个名为“nginx”的新文件夹，然后向该文件夹添加一个名为<em> default.conf </em>的新配置文件:</p>
<div class="codehilite"><pre><span/><code><span class="nt">server</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="err">listen</span><span class="w"> </span><span class="err">$PORT</span><span class="p">;</span><span class="w"/>

<span class="w">  </span><span class="err">root</span><span class="w"> </span><span class="err">/usr/share/nginx/html</span><span class="p">;</span><span class="w"/>
<span class="w">  </span><span class="err">index</span><span class="w"> </span><span class="err">index.html</span><span class="w"> </span><span class="err">index.html</span><span class="p">;</span><span class="w"/>

<span class="w">  </span><span class="err">location</span><span class="w"> </span><span class="err">/</span><span class="w"> </span><span class="err">{</span><span class="w"/>
<span class="w">    </span><span class="err">try_files</span><span class="w"> </span><span class="err">$uri</span><span class="w"> </span><span class="err">/index.html</span><span class="w"> </span><span class="err">=404</span><span class="p">;</span><span class="w"/>
<span class="w">  </span><span class="p">}</span><span class="w"/>

<span class="w">  </span><span class="nt">location</span><span class="w"> </span><span class="o">/</span><span class="nt">ping</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_pass</span><span class="w">          </span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="mf">127.0.0.1</span><span class="o">:</span><span class="mi">5000</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_http_version</span><span class="w">  </span><span class="err">1.1</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_redirect</span><span class="w">      </span><span class="err">default</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">Upgrade</span><span class="w"> </span><span class="err">$http_upgrade</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">Connection</span><span class="w"> </span><span class="err">"upgrade"</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">Host</span><span class="w"> </span><span class="err">$host</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">X-Real-IP</span><span class="w"> </span><span class="err">$remote_addr</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">X-Forwarded-For</span><span class="w"> </span><span class="err">$proxy_add_x_forwarded_for</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">X-Forwarded-Host</span><span class="w"> </span><span class="err">$server_name</span><span class="p">;</span><span class="w"/>
<span class="w">  </span><span class="p">}</span><span class="w"/>

<span class="w">  </span><span class="nt">location</span><span class="w"> </span><span class="o">/</span><span class="nt">books</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_pass</span><span class="w">          </span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="mf">127.0.0.1</span><span class="o">:</span><span class="mi">5000</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_http_version</span><span class="w">  </span><span class="err">1.1</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_redirect</span><span class="w">      </span><span class="err">default</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">Upgrade</span><span class="w"> </span><span class="err">$http_upgrade</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">Connection</span><span class="w"> </span><span class="err">"upgrade"</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">Host</span><span class="w"> </span><span class="err">$host</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">X-Real-IP</span><span class="w"> </span><span class="err">$remote_addr</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">X-Forwarded-For</span><span class="w"> </span><span class="err">$proxy_add_x_forwarded_for</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="err">proxy_set_header</span><span class="w">    </span><span class="err">X-Forwarded-Host</span><span class="w"> </span><span class="err">$server_name</span><span class="p">;</span><span class="w"/>
<span class="w">  </span><span class="p">}</span><span class="w"/>
<span class="err">}</span><span class="w"/>
</code></pre></div>

<p>要进行本地测试，首先删除<em>client/src/components/books . vue</em>和<em>client/src/components/ping . vue</em>中的<code>http://localhost:5000</code>的所有实例。例如，<code>Books</code>组件中的<code>getBooks</code>方法现在应该是这样的:</p>
<div class="codehilite"><pre><span/><code><span class="nx">getBooks</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'/books'</span><span class="p">;</span><span class="w"/>
<span class="w">  </span><span class="nx">axios</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="w"/>
<span class="w">    </span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">books</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">res</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">books</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">})</span><span class="w"/>
<span class="w">    </span><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="c1">// eslint-disable-next-line</span><span class="w"/>
<span class="w">      </span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="p">});</span><span class="w"/>
<span class="p">},</span><span class="w"/>
</code></pre></div>

<p>接下来，构建映像并在<a href="https://docs.docker.com/engine/reference/run/#detached--d">分离模式</a>下运行容器:</p>
<div class="codehilite"><pre><span/><code>$ docker build -t web:latest .
$ docker run -d --name flask-vue -e <span class="s2">"PORT=8765"</span> -p <span class="m">8007</span>:8765 web:latest
</code></pre></div>

<p>注意我们是如何传入一个名为<code>PORT</code>的环境变量的。如果一切顺利，那么我们应该在运行容器中的<em> default.conf </em>文件中看到这个变量:</p>
<div class="codehilite"><pre><span/><code>$ docker <span class="nb">exec</span> flask-vue cat ../etc/nginx/conf.d/default.conf
</code></pre></div>

<p>确保Nginx正在监听端口8765: <code>listen 8765;</code>。此外，确保该应用程序正在浏览器中的<a href="http://localhost:8007"> http://localhost:8007 </a>上运行。完成后，停止并移除正在运行的容器:</p>
<div class="codehilite"><pre><span/><code>$ docker stop flask-vue
$ docker rm flask-vue
</code></pre></div>

<h2 id="heroku">Heroku</h2>
<p>注册一个Heroku账号(如果你还没有的话)，然后安装<a href="https://devcenter.heroku.com/articles/heroku-cli"> Heroku CLI </a>(如果你还没有的话)。</p>
<p>创建新应用程序:</p>
<div class="codehilite"><pre><span/><code>$ heroku create
Creating app... <span class="k">done</span>, ⬢ lit-savannah-00898
https://lit-savannah-00898.herokuapp.com/ <span class="p">|</span> https://git.heroku.com/lit-savannah-00898.git
</code></pre></div>

<p>登录到<a href="https://devcenter.heroku.com/articles/container-registry-and-runtime"> Heroku容器注册表</a>:</p>


<p>重建图像，并使用以下格式对其进行标记:</p>
<div class="codehilite"><pre><span/><code><span class="n">registry</span><span class="p">.</span><span class="n">heroku</span><span class="p">.</span><span class="n">com</span><span class="o">/&lt;</span><span class="n">app</span><span class="o">&gt;/&lt;</span><span class="n">process</span><span class="o">-</span><span class="k">type</span><span class="o">&gt;</span><span class="w"/>
</code></pre></div>

<p>确保将<code>&lt;app&gt;</code>替换为您刚刚创建的Heroku应用的名称，将<code>&lt;process-type&gt;</code>替换为<code>web</code>，因为这将是一个<a href="https://www.heroku.com/dynos"> web dyno </a>。</p>
<p>例如:</p>
<div class="codehilite"><pre><span/><code>$ docker build -t registry.heroku.com/lit-savannah-00898/web .
</code></pre></div>

<p>将图像推送到注册表:</p>
<div class="codehilite"><pre><span/><code>$ docker push registry.heroku.com/lit-savannah-00898/web
</code></pre></div>

<p>发布图像:</p>
<div class="codehilite"><pre><span/><code>$ heroku container:release --app lit-savannah-00898 web
</code></pre></div>

<blockquote>
<p>确保将上述每个命令中的<code>lit-savannah-00898</code>替换为您的应用程序名称。</p>
</blockquote>
<p>这将运行容器。您应该可以在<a href="https://APP_NAME.herokuapp.com">https://APP _ name . heroku APP . com</a>查看应用程序。</p>
<h2 id="gitlab-ci">GitLab CI</h2>
<p><a href="https://gitlab.com/users/sign_up">注册</a>一个GitLab账号(如果需要的话)，然后<a href="https://docs.gitlab.com/ee/user/project/working_with_projects.html#create-a-project">创建一个新项目</a>(再次，如果需要的话)。</p>
<p>取回您的<a href="https://devcenter.heroku.com/articles/authentication"> Heroku认证令牌</a>:</p>


<p>然后，在项目的CI/CD设置中将令牌保存为一个名为<code>HEROKU_AUTH_TOKEN</code>的新变量:Settings &gt; CI / CD &gt; Variables。</p>
<p><img data-src="/static/images/blog/flask-vue-gitlab/gitlab-config.png" loading="lazy" class="lazyload" alt="gitlab config" src="../Images/89b45a93e11991427e58e591834e84d6.png" data-original-src="https://testdriven.io/static/images/blog/flask-vue-gitlab/gitlab-config.png"/></p>
<p>接下来，添加一个名为<em>的GitLab CI/CD配置文件。gitlab-ci.yml </em>到项目根:</p>
<div class="codehilite"><pre><span/><code><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker:stable</span><span class="w"/>
<span class="nt">services</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker:dind</span><span class="w"/>

<span class="nt">variables</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">DOCKER_DRIVER</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">overlay</span><span class="w"/>
<span class="w">  </span><span class="nt">HEROKU_APP_NAME</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">&lt;APP_NAME&gt;</span><span class="w"/>
<span class="w">  </span><span class="nt">HEROKU_REGISTRY_IMAGE</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">registry.heroku.com/${HEROKU_APP_NAME}/web</span><span class="w"/>

<span class="nt">stages</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">build</span><span class="w"/>

<span class="nt">docker-build</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">stage</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">build</span><span class="w"/>
<span class="w">  </span><span class="nt">script</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">apk add --no-cache curl</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker build</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--tag $HEROKU_REGISTRY_IMAGE</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--file ./Dockerfile</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">"."</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker login -u _ -p $HEROKU_AUTH_TOKEN registry.heroku.com</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker push $HEROKU_REGISTRY_IMAGE</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">chmod +x ./release.sh</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./release.sh</span><span class="w"/>
</code></pre></div>

<p><em> release.sh </em>:</p>
<div class="codehilite"><pre><span/><code><span class="ch">#!/bin/sh</span>


<span class="nv">IMAGE_ID</span><span class="o">=</span><span class="k">$(</span>docker inspect <span class="si">${</span><span class="nv">HEROKU_REGISTRY_IMAGE</span><span class="si">}</span> --format<span class="o">={{</span>.Id<span class="o">}}</span><span class="k">)</span>
<span class="nv">PAYLOAD</span><span class="o">=</span><span class="s1">'{"updates": [{"type": "web", "docker_image": "'</span><span class="s2">"</span><span class="nv">$IMAGE_ID</span><span class="s2">"</span><span class="s1">'"}]}'</span>

curl -n -X PATCH https://api.heroku.com/apps/<span class="nv">$HEROKU_APP_NAME</span>/formation <span class="se">\</span>
  -d <span class="s2">"</span><span class="si">${</span><span class="nv">PAYLOAD</span><span class="si">}</span><span class="s2">"</span> <span class="se">\</span>
  -H <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  -H <span class="s2">"Accept: application/vnd.heroku+json; version=3.docker-releases"</span> <span class="se">\</span>
  -H <span class="s2">"Authorization: Bearer </span><span class="si">${</span><span class="nv">HEROKU_AUTH_TOKEN</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div>

<p>在这里，我们定义了单个<code>build</code> <a href="https://docs.gitlab.com/ee/ci/yaml/#stages">阶段</a>，在这里我们:</p>
<ol>
<li>安装卷曲</li>
<li>构建并标记新图像</li>
<li>登录Heroku容器注册表</li>
<li>将图像上传到注册表</li>
<li>使用<em> release.sh </em>脚本中的映像ID，通过<a href="https://devcenter.heroku.com/articles/container-registry-and-runtime#api"> Heroku API </a>创建一个新版本</li>
</ol>
<blockquote>
<p>确保将<code>&lt;APP_NAME&gt;</code>替换为Heroku应用的名称。</p>
</blockquote>
<p>这样，提交并把你的修改推送到GitLab来触发一个新的<a href="https://docs.gitlab.com/ee/ci/pipelines/">管道</a>。这将作为单个作业运行<code>build</code>阶段。一旦完成，Heroku上将自动创建一个新版本。</p>
<p>最后，更新配置脚本以利用Docker层缓存:</p>
<div class="codehilite"><pre><span/><code><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker:stable</span><span class="w"/>
<span class="nt">services</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker:dind</span><span class="w"/>

<span class="nt">variables</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">DOCKER_DRIVER</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">overlay</span><span class="w"/>
<span class="w">  </span><span class="nt">HEROKU_APP_NAME</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">&lt;APP_NAME&gt;</span><span class="w"/>
<span class="w">  </span><span class="nt">CACHE_IMAGE</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}/${CI_PROJECT_NAME}</span><span class="w"/>
<span class="w">  </span><span class="nt">HEROKU_REGISTRY_IMAGE</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">registry.heroku.com/${HEROKU_APP_NAME}/web</span><span class="w"/>

<span class="nt">stages</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">build</span><span class="w"/>

<span class="nt">docker-build</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">stage</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">build</span><span class="w"/>
<span class="w">  </span><span class="nt">script</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">apk add --no-cache curl</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker pull $CACHE_IMAGE:build-vue || true</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker pull $CACHE_IMAGE:production || true</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker build</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--target build-vue</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--cache-from $CACHE_IMAGE:build-vue</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--tag $CACHE_IMAGE:build-vue</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--file ./Dockerfile</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">"."</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker build</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--cache-from $CACHE_IMAGE:production</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--tag $CACHE_IMAGE:production</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--tag $HEROKU_REGISTRY_IMAGE</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">--file ./Dockerfile</span><span class="w"/>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">"."</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker push $CACHE_IMAGE:build-vue</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker push $CACHE_IMAGE:production</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker login -u _ -p $HEROKU_AUTH_TOKEN registry.heroku.com</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker push $HEROKU_REGISTRY_IMAGE</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">chmod +x ./release.sh</span><span class="w"/>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./release.sh</span><span class="w"/>
</code></pre></div>

<p>现在，安装cURL后，我们:</p>
<ol>
<li>登录到<a href="https://docs.gitlab.com/ee/user/packages/container_registry/"> GitLab容器注册表</a></li>
<li>提取之前推送的图像(如果它们存在)</li>
<li>构建并标记新图像(包括<code>build-vue</code>和<code>production</code>)</li>
<li>将图像上传到GitLab容器注册表</li>
<li>登录Heroku容器注册表</li>
<li>将<code>production</code>图像上传到注册表</li>
<li>使用<em> release.sh </em>脚本中的映像ID，通过<a href="https://devcenter.heroku.com/articles/container-registry-and-runtime#api"> Heroku API </a>创建一个新版本</li>
</ol>
<blockquote>
<p>有关这种缓存模式的更多信息，请查看<a href="/blog/faster-ci-builds-with-docker-cache">用Docker缓存加快CI构建的文章</a>中的“多阶段”部分。</p>
</blockquote>
<p>对一个Vue组件进行快速更改。提交您的代码，并再次将其推送到GitLab。您的应用程序应该自动部署到Heroku！</p>
  </div>

  </div>    
</body>
</html>