<html>
<head>
<title>Low-Level Cache API in Django </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Django中的低级缓存API</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/django-low-level-cache/#0001-01-01">https://testdriven.io/blog/django-low-level-cache/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>在之前的文章中，我们查看了Django中缓存的概述，并深入研究了如何缓存Django视图以及使用不同的缓存后端。本文更深入地研究了Django中的低级缓存API。</p>
<p>--</p>
<p><strong> Django缓存文章:</strong></p>
<ol>
<li><a href="/blog/django-caching/">Django中的缓存</a></li>
<li><a href="/blog/django-low-level-cache/">Django中的低级缓存API</a>(本文！)</li>
</ol>



<h2 id="objectives">目标</h2>
<p>完成本文后，您应该能够:</p>
<ol>
<li>将Redis设置为Django缓存后端</li>
<li>使用Django的低级缓存API来缓存模型</li>
<li>使用Django数据库信号使缓存无效</li>
<li>利用Django生命周期简化缓存失效</li>
<li>与低级缓存API交互</li>
</ol>
<h2 id="django-low-level-cache">Django低级高速缓存</h2>
<p>Django中的缓存可以在不同的层次上实现(或者站点的不同部分)。您可以缓存整个站点或不同粒度级别的特定部分(按粒度降序排列):</p>

<blockquote>
<p>有关Django中不同缓存级别的更多信息，请参考Django 文章中的<a href="/blog/django-caching/#django-caching-levels">缓存。</a></p>
</blockquote>
<p>如果Django的每站点或每视图缓存不够精细，无法满足您的应用程序需求，那么您可能希望利用<a href="https://docs.djangoproject.com/en/3.2/topics/cache/#the-low-level-cache-api">低级</a>缓存API来管理对象级的缓存。</p>
<p>如果您需要缓存不同的:</p>
<ol>
<li>对以不同间隔变化的对象进行建模</li>
<li>登录用户的数据相互分离</li>
<li>计算负载繁重的外部资源</li>
<li>外部API调用</li>
</ol>
<p>所以，当你需要更多的粒度和对缓存的控制时，Django的低级缓存是很好的。它可以存放任何可以安全腌制的物品。要使用低级缓存，你可以使用内置的<code>django.core.cache.caches</code>，或者，如果你只是想使用在<em> settings.py </em>文件中定义的默认缓存，通过<code>django.core.cache.cache</code>。</p>
<h2 id="project-setup">项目设置</h2>
<p>从GitHub上的<a href="https://github.com/testdrivenio/django-low-level-cache">django-低级缓存</a> repo中克隆基础项目:</p>
<div class="codehilite"><pre><span/><code>$ git clone -b base https://github.com/testdrivenio/django-low-level-cache
$ <span class="nb">cd</span> django-low-level-cache
</code></pre></div>

<p>创建(并激活)虚拟环境，并满足以下要求:</p>
<div class="codehilite"><pre><span/><code>$ python3.9 -m venv venv
$ <span class="nb">source</span> venv/bin/activate
<span class="o">(</span>venv<span class="o">)</span>$ pip install -r requirements.txt
</code></pre></div>

<p>应用Django迁移，将一些产品数据加载到数据库中，并启动服务器:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python manage.py migrate
<span class="o">(</span>venv<span class="o">)</span>$ python manage.py seed_db
<span class="o">(</span>venv<span class="o">)</span>$ python manage.py runserver
</code></pre></div>

<p>在您的浏览器中导航到<a href="http://127.0.0.1:8000"> http://127.0.0.1:8000 </a>以检查一切是否按预期工作。</p>
<p><img data-src="/static/images/blog/django/django-caching/homepage.png" loading="lazy" class="lazyload" alt="uncached product page" src="../Images/e4ee279717bd81bf2ea4f18a8023fb59.png" data-original-src="https://testdriven.io/static/images/blog/django/django-caching/homepage.png"/></p>
<h2 id="cache-backend">缓存后端</h2>
<p>我们将使用<a href="https://redis.io"> Redis </a>作为缓存后端。</p>
<p><a href="https://redis.io/download">下载</a>并安装Redis。</p>
<blockquote>
<p>如果你用的是Mac，我们建议用<a href="https://brew.sh/">家酿</a>安装Redis:</p>
</blockquote>

<p>安装完成后，在新的终端窗口<a href="https://redis.io/topics/quickstart#starting-redis">中启动Redis服务器</a>并确保它运行在默认端口6379上。当我们告诉Django如何与Redis通信时，端口号将非常重要。</p>


<p>对于Django使用Redis作为缓存后端，需要django-redis 依赖关系。它已经安装好了，所以你只需要将自定义后端添加到<em> settings.py </em>文件中:</p>
<div class="codehilite"><pre><span/><code><span class="n">CACHES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'default'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">'BACKEND'</span><span class="p">:</span> <span class="s1">'django_redis.cache.RedisCache'</span><span class="p">,</span>
        <span class="s1">'LOCATION'</span><span class="p">:</span> <span class="s1">'redis://127.0.0.1:6379/1'</span><span class="p">,</span>
        <span class="s1">'OPTIONS'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">'CLIENT_CLASS'</span><span class="p">:</span> <span class="s1">'django_redis.client.DefaultClient'</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>现在，当您再次运行服务器时，Redis将被用作缓存后端:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python manage.py runserver
</code></pre></div>

<p>翻到代码。<em> products/views.py </em>中的<code>HomePageView</code>视图简单地列出了数据库中的所有产品:</p>
<div class="codehilite"><pre><span/><code><span class="k">class</span> <span class="nc">HomePageView</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="n">template_name</span> <span class="o">=</span> <span class="s1">'products/home.html'</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="n">product_objects</span> <span class="o">=</span> <span class="n">Product</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

        <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">'products'</span><span class="p">:</span> <span class="n">product_objects</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">render</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_name</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
</code></pre></div>

<p>让我们为产品对象添加对低级缓存API的支持。</p>
<p>首先，将导入添加到<em> products/views.py </em>的顶部:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="n">cache</span>
</code></pre></div>

<p>然后，向视图添加用于缓存产品的代码:</p>
<div class="codehilite"><pre><span/><code><span class="k">class</span> <span class="nc">HomePageView</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="n">template_name</span> <span class="o">=</span> <span class="s1">'products/home.html'</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="n">product_objects</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">)</span>      <span class="c1"># NEW</span>

        <span class="k">if</span> <span class="n">product_objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                         <span class="c1"># NEW</span>
            <span class="n">product_objects</span> <span class="o">=</span> <span class="n">Product</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">,</span> <span class="n">product_objects</span><span class="p">)</span>   <span class="c1"># NEW</span>

        <span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">'products'</span><span class="p">:</span> <span class="n">product_objects</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">render</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_name</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
</code></pre></div>

<p>这里，我们首先检查默认缓存中是否有名为<code>product_objects</code>的缓存对象:</p>
<ul>
<li>如果是这样，我们只是将它返回给模板，而没有进行数据库查询。</li>
<li>如果在我们的缓存中没有找到，我们查询数据库并用键<code>product_objects</code>将结果添加到缓存中。</li>
</ul>
<p>服务器运行时，在浏览器中导航至<a href="http://127.0.0.1:8000"> http://127.0.0.1:8000 </a>。点击<a href="https://django-debug-toolbar.readthedocs.io/"> Django调试工具栏</a>右侧菜单中的“缓存”。您应该会看到类似如下的内容:</p>
<p><img data-src="/static/images/blog/django/django-caching/cache_miss.png" loading="lazy" class="lazyload" alt="Django Debug Toolbar" src="../Images/6dcb84aaf700871241c49f352dd0f23b.png" data-original-src="https://testdriven.io/static/images/blog/django/django-caching/cache_miss.png"/></p>
<p>有两个缓存调用:</p>
<ol>
<li>第一个调用试图获取名为<code>product_objects</code>的缓存对象，由于该对象不存在，导致缓存未命中。</li>
<li>第二个调用使用相同的名称设置缓存对象，结果是所有产品的queryset。</li>
</ol>
<p>还有一个SQL查询。总的来说，页面加载大约需要313毫秒。</p>
<p>在浏览器中刷新页面:</p>
<p><img data-src="/static/images/blog/django/django-caching/cache_hit.png" loading="lazy" class="lazyload" alt="Django Debug Toolbar" src="../Images/87940dec744583002aedd365f211f30b.png" data-original-src="https://testdriven.io/static/images/blog/django/django-caching/cache_hit.png"/></p>
<p>这一次，您应该看到一个缓存命中，它获得名为<code>product_objects</code>的缓存对象。此外，没有SQL查询，页面加载大约需要234毫秒。</p>
<p>尝试添加新产品、更新现有产品和删除产品。您将不会在<a href="http://127.0.0.1:8000"> http://127.0.0.1:8000 </a>看到任何更改，直到您通过按下“Invalidate cache”按钮手动使缓存无效。</p>
<h2 id="invalidating-the-cache">使缓存失效</h2>
<p>接下来让我们看看如何自动使缓存失效。在<a href="/blog/django-caching/">之前的文章</a>中，我们研究了如何在一段时间(TTL)后使缓存失效。在本文中，我们将研究如何在模型发生变化时使缓存失效——例如，当一个产品被添加到products表中时，或者当一个现有产品被更新或删除时。</p>
<h3 id="using-django-signals">使用姜戈信号</h3>
<p>对于这个任务，我们可以使用数据库<a href="https://docs.djangoproject.com/en/3.2/topics/signals/">信号</a>:</p>
<blockquote>
<p>Django包括一个“信号调度程序”，当框架中的其他地方发生动作时，它可以帮助解耦的应用程序得到通知。简而言之，信号允许某些发送者通知一组接收者某个动作已经发生。当许多代码可能对相同的事件感兴趣时，它们特别有用。</p>
</blockquote>
<h3 id="saves-and-deletes">保存和删除</h3>
<p>要设置处理缓存失效的信号，首先更新<em> products/apps.py </em>，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">django.apps</span> <span class="kn">import</span> <span class="n">AppConfig</span>


<span class="k">class</span> <span class="nc">ProductsConfig</span><span class="p">(</span><span class="n">AppConfig</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">'products'</span>

    <span class="k">def</span> <span class="nf">ready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>                <span class="c1"># NEW</span>
        <span class="kn">import</span> <span class="nn">products.signals</span>     <span class="c1"># NEW</span>
</code></pre></div>

<p>接下来，在“产品”目录中创建一个名为<em> signals.py </em>的文件:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">django.db.models.signals</span> <span class="kn">import</span> <span class="n">post_delete</span><span class="p">,</span> <span class="n">post_save</span>
<span class="kn">from</span> <span class="nn">django.dispatch</span> <span class="kn">import</span> <span class="n">receiver</span>

<span class="kn">from</span> <span class="nn">.models</span> <span class="kn">import</span> <span class="n">Product</span>


<span class="nd">@receiver</span><span class="p">(</span><span class="n">post_delete</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="n">Product</span><span class="p">,</span> <span class="n">dispatch_uid</span><span class="o">=</span><span class="s1">'post_deleted'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">object_post_delete_handler</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
     <span class="n">cache</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">)</span>


<span class="nd">@receiver</span><span class="p">(</span><span class="n">post_save</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="n">Product</span><span class="p">,</span> <span class="n">dispatch_uid</span><span class="o">=</span><span class="s1">'posts_updated'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">object_post_save_handler</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">cache</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">)</span>
</code></pre></div>

<p>这里，我们使用来自<code>django.dispatch</code>的<code>receiver</code>装饰器来装饰两个函数，当添加或删除产品时，这两个函数分别被调用。让我们来看看论点:</p>
<ol>
<li>第一个参数是修饰函数绑定到的信号事件，可以是<code>save</code>或<code>delete</code>。</li>
<li>我们还指定了一个发送者，即接收信号的<code>Product</code>模型。</li>
<li>最后，我们传递了一个字符串作为<code>dispatch_uid</code>到<a href="https://docs.djangoproject.com/en/3.2/topics/signals/#preventing-duplicate-signals">防止重复信号</a>。</li>
</ol>
<p>因此，当针对<code>Product</code>模型进行保存或删除时，缓存对象上的<code>delete</code>方法被调用来删除<code>product_objects</code>缓存的内容。</p>
<p>要查看实际效果，请启动或重启服务器，并在浏览器中导航到<a href="http://127.0.0.1:8000"> http://127.0.0.1:8000 </a>。打开Django调试工具栏中的“缓存”标签。您应该会看到一次缓存未命中。刷新，您应该没有缓存未命中和一个缓存命中。关闭调试工具栏页面。然后，单击“新产品”按钮添加新产品。单击“保存”后，您应该会被重定向回主页。这一次，您应该看到一次缓存未命中，这表明信号起作用了。此外，你的新产品应该出现在产品列表的顶部。</p>
<h3 id="updates">更新</h3>
<p>更新一下怎么样？</p>
<p>如果您像这样更新一个项目，就会触发<code>post_save</code>信号:</p>
<div class="codehilite"><pre><span/><code><span class="n">product</span> <span class="o">=</span> <span class="n">Product</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">product</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s1">'A new title'</span>
<span class="n">product</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</code></pre></div>

<p>但是，如果您通过<code>QuerySet</code>对模型执行<code>update</code>，则<code>post_save</code>不会被触发:</p>
<div class="codehilite"><pre><span/><code><span class="n">Product</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">'A new title'</span><span class="p">)</span>
</code></pre></div>

<p>记下<code>ProductUpdateView</code>:</p>
<div class="codehilite"><pre><span/><code><span class="k">class</span> <span class="nc">ProductUpdateView</span><span class="p">(</span><span class="n">UpdateView</span><span class="p">):</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Product</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'title'</span><span class="p">,</span> <span class="s1">'price'</span><span class="p">]</span>
    <span class="n">template_name</span> <span class="o">=</span> <span class="s1">'products/product_update.html'</span>

    <span class="c1"># we overrode the post method for testing purposes</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object</span><span class="p">()</span>
        <span class="n">Product</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">title</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">POST</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'title'</span><span class="p">),</span>
            <span class="n">price</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">POST</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'price'</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">HttpResponseRedirect</span><span class="p">(</span><span class="n">reverse_lazy</span><span class="p">(</span><span class="s1">'home'</span><span class="p">))</span>
</code></pre></div>

<p>因此，为了触发<code>post_save</code>，让我们覆盖queryset <code>update()</code>方法。首先创建一个自定义<code>QuerySet</code>和一个自定义<code>Manager</code>。在<em> products/models.py </em>的顶部，添加以下几行:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="n">cache</span>             <span class="c1"># NEW</span>
<span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">QuerySet</span><span class="p">,</span> <span class="n">Manager</span>  <span class="c1"># NEW</span>
<span class="kn">from</span> <span class="nn">django.utils</span> <span class="kn">import</span> <span class="n">timezone</span>               <span class="c1"># NEW</span>
</code></pre></div>

<p>接下来，让我们将下面的代码添加到<em> products/models.py </em>的<code>Product</code>类的正上方:</p>
<div class="codehilite"><pre><span/><code><span class="k">class</span> <span class="nc">CustomQuerySet</span><span class="p">(</span><span class="n">QuerySet</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cache</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CustomQuerySet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">updated</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CustomManager</span><span class="p">(</span><span class="n">Manager</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CustomQuerySet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">using</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_db</span><span class="p">)</span>
</code></pre></div>

<p>这里，我们创建了一个自定义<code>Manager</code>，它只有一个任务:返回我们的自定义<code>QuerySet</code>。在我们的定制<code>QuerySet</code>中，我们重写了<code>update()</code>方法，首先删除缓存键，然后执行常规的<code>QuerySet</code>更新。</p>
<p>为了让我们的代码使用它，您还需要像这样更新<code>Product</code>:</p>
<div class="codehilite"><pre><span/><code><span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">created</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now_add</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">updated</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">objects</span> <span class="o">=</span> <span class="n">CustomManager</span><span class="p">()</span>           <span class="c1"># NEW</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'-created'</span><span class="p">]</span>
</code></pre></div>

<p>完整文件:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">QuerySet</span><span class="p">,</span> <span class="n">Manager</span>
<span class="kn">from</span> <span class="nn">django.utils</span> <span class="kn">import</span> <span class="n">timezone</span>


<span class="k">class</span> <span class="nc">CustomQuerySet</span><span class="p">(</span><span class="n">QuerySet</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cache</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CustomQuerySet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">updated</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CustomManager</span><span class="p">(</span><span class="n">Manager</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CustomQuerySet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">using</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_db</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">created</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now_add</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">updated</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">objects</span> <span class="o">=</span> <span class="n">CustomManager</span><span class="p">()</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'-created'</span><span class="p">]</span>
</code></pre></div>

<p>测试一下。</p>
<h3 id="using-django-lifecycle">使用Django生命周期</h3>
<p>您可以不使用数据库信号，而是使用一个名为<a href="https://rsinger86.github.io/django-lifecycle/"> Django Lifecycle </a>的第三方包，这有助于使缓存失效更容易、更易读:</p>
<blockquote>
<p>这个项目提供了一个@hook装饰器以及一个基本模型和mixin来为Django模型添加生命周期挂钩。Django提供生命周期挂钩的内置方法是Signals。然而，我的团队经常发现信号引入了不必要的间接性，并且与Django的“胖模型”方法不一致。</p>
</blockquote>
<p>要切换到使用Django生命周期，关闭服务器，然后像这样更新<em> products/app.py </em>:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">django.apps</span> <span class="kn">import</span> <span class="n">AppConfig</span>


<span class="k">class</span> <span class="nc">ProductsConfig</span><span class="p">(</span><span class="n">AppConfig</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">'products'</span>
</code></pre></div>

<p>接下来，将Django生命周期添加到<em> requirements.txt </em>:</p>
<div class="codehilite"><pre><span/><code><span class="n">Django</span><span class="o">==</span><span class="mf">3.1</span><span class="o">.</span><span class="mi">13</span><span class="w"/>
<span class="n">django</span><span class="o">-</span><span class="n">debug</span><span class="o">-</span><span class="n">toolbar</span><span class="o">==</span><span class="mf">3.2</span><span class="o">.</span><span class="mi">1</span><span class="w"/>
<span class="n">django</span><span class="o">-</span><span class="n">lifecycle</span><span class="o">==</span><span class="mf">0.9</span><span class="o">.</span><span class="mi">1</span><span class="w">         </span><span class="c1"># NEW</span><span class="w"/>
<span class="n">django</span><span class="o">-</span><span class="n">redis</span><span class="o">==</span><span class="mf">5.0</span><span class="o">.</span><span class="mi">0</span><span class="w"/>
<span class="n">redis</span><span class="o">==</span><span class="mf">3.5</span><span class="o">.</span><span class="mi">3</span><span class="w"/>
</code></pre></div>

<p>安装新要求:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install -r requirements.txt
</code></pre></div>

<p>要使用生命周期挂钩，请像这样更新<em> products/models.py </em>:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">QuerySet</span><span class="p">,</span> <span class="n">Manager</span>
<span class="kn">from</span> <span class="nn">django_lifecycle</span> <span class="kn">import</span> <span class="n">LifecycleModel</span><span class="p">,</span> <span class="n">hook</span><span class="p">,</span> <span class="n">AFTER_DELETE</span><span class="p">,</span> <span class="n">AFTER_SAVE</span>   <span class="c1"># NEW</span>
<span class="kn">from</span> <span class="nn">django.utils</span> <span class="kn">import</span> <span class="n">timezone</span>


<span class="k">class</span> <span class="nc">CustomQuerySet</span><span class="p">(</span><span class="n">QuerySet</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cache</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CustomQuerySet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">updated</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CustomManager</span><span class="p">(</span><span class="n">Manager</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CustomQuerySet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">using</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_db</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">LifecycleModel</span><span class="p">):</span>              <span class="c1"># NEW</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">created</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now_add</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">updated</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">(</span><span class="n">auto_now</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">objects</span> <span class="o">=</span> <span class="n">CustomManager</span><span class="p">()</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'-created'</span><span class="p">]</span>

    <span class="nd">@hook</span><span class="p">(</span><span class="n">AFTER_SAVE</span><span class="p">)</span>                       <span class="c1"># NEW</span>
    <span class="nd">@hook</span><span class="p">(</span><span class="n">AFTER_DELETE</span><span class="p">)</span>                     <span class="c1"># NEW</span>
    <span class="k">def</span> <span class="nf">invalidate_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>             <span class="c1"># NEW</span>
       <span class="n">cache</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">)</span>      <span class="c1"># NEW</span>
</code></pre></div>

<p>在上面的代码中，我们:</p>
<ol>
<li>首先从Django生命周期中导入必要的对象</li>
<li>然后继承自<code>LifecycleModel</code>而不是<code>django.db.models</code></li>
<li>创建了一个删除<code>product_object</code>缓存键的<code>invalidate_cache</code>方法</li>
<li>使用了<code>@hook</code>decorator来指定我们想要“挂钩”的事件</li>
</ol>
<p>通过以下方式在您的浏览器中进行测试-</p>
<ol>
<li>导航到<a href="http://127.0.0.1:8000"> http://127.0.0.1:8000 </a></li>
<li>在调试工具栏中刷新并验证是否有缓存命中</li>
<li>添加产品并验证现在是否存在缓存缺失</li>
</ol>
<p>与<code>django signals</code>一样，如果我们像前面提到的例子那样通过<code>QuerySet</code>更新，钩子不会触发:</p>
<div class="codehilite"><pre><span/><code><span class="n">Product</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">"A new title"</span><span class="p">)</span>
</code></pre></div>

<p>在这种情况下，我们仍然需要创建一个自定义的<code>Manager</code>和<code>QuerySet</code>，就像我们之前展示的那样。</p>
<p>测试编辑和删除产品。</p>
<h2 id="low-level-cache-api-methods">低级高速缓存API方法</h2>
<p>到目前为止，我们已经使用了<code>cache.get</code>、<code>cache.set</code>和<code>cache.delete</code>方法来获取、设置和删除(无效)缓存中的对象。让我们从<code>django.core.cache.cache</code>中来看看一些<a href="https://docs.djangoproject.com/en/3.2/topics/cache/#basic-usage">更多的方法</a>。</p>
<h3 id="cacheget_or_set">cache.get_or_set</h3>
<p>获取指定的键(如果存在)。如果它不存在，它设置关键点。</p>
<p><strong>语法</strong></p>
<p><code>cache.get_or_set(key, default, timeout=DEFAULT_TIMEOUT, version=None)</code></p>
<p><code>timeout</code>参数用于设置缓存的有效时间(以秒为单位)。将其设置为<code>None</code>将永久缓存该值。省略它将使用在<code>CACHES</code>设置中的<code>setting.py</code>中设置的超时(如果有的话)</p>
<p>许多缓存方法还包括一个<code>version</code>参数。使用此参数，您可以设置或访问同一缓存键的不同版本。</p>
<p><strong>例子</strong></p>
<div class="codehilite"><pre><span/><code>&gt;&gt;&gt; from django.core.cache import cache
&gt;&gt;&gt; cache.get_or_set<span class="o">(</span><span class="s1">'my_key'</span>, <span class="s1">'my new value'</span><span class="o">)</span>
<span class="s1">'my new value'</span>
</code></pre></div>

<p>我们可以在视图中使用它，而不是使用if语句:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># current implementation</span>
<span class="n">product_objects</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">)</span>

<span class="k">if</span> <span class="n">product_objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">product_objects</span> <span class="o">=</span> <span class="n">Product</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">,</span> <span class="n">product_objects</span><span class="p">)</span>


<span class="c1"># with get_or_set</span>
<span class="n">product_objects</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get_or_set</span><span class="p">(</span><span class="s1">'product_objects'</span><span class="p">,</span> <span class="n">product_objects</span><span class="p">)</span>
</code></pre></div>

<h3 id="cacheset_many">cache.set_many</h3>
<p>用于通过传递一个键值对字典来一次设置多个键。</p>
<p><strong>语法</strong></p>
<p><code>cache.set_many(dict, timeout)</code></p>
<p><strong>例子</strong></p>
<div class="codehilite"><pre><span/><code>&gt;&gt;&gt; cache.set_many<span class="o">({</span><span class="s1">'my_first_key'</span>: <span class="m">1</span>, <span class="s1">'my_second_key'</span>: <span class="m">2</span>, <span class="s1">'my_third_key'</span>: <span class="m">3</span><span class="o">})</span>
</code></pre></div>

<h3 id="cacheget_many">cache.get_many</h3>
<p>用于一次获取多个缓存对象。它返回一个字典，其中的键被指定为方法的参数，只要它们存在并且没有过期。</p>
<p><strong>语法</strong></p>
<p><code>cache.get_many(keys, version=None)</code></p>
<p><strong>例子</strong></p>
<div class="codehilite"><pre><span/><code>&gt;&gt;&gt; cache.get_many<span class="o">([</span><span class="s1">'my_key'</span>, <span class="s1">'my_first_key'</span>, <span class="s1">'my_second_key'</span>, <span class="s1">'my_third_key'</span><span class="o">])</span>
OrderedDict<span class="o">([(</span><span class="s1">'my_key'</span>, <span class="s1">'my new value'</span><span class="o">)</span>, <span class="o">(</span><span class="s1">'my_first_key'</span>, <span class="m">1</span><span class="o">)</span>, <span class="o">(</span><span class="s1">'my_second_key'</span>, <span class="m">2</span><span class="o">)</span>, <span class="o">(</span><span class="s1">'my_third_key'</span>, <span class="m">3</span><span class="o">)])</span>
</code></pre></div>

<h3 id="cachetouch">cache.touch</h3>
<p>如果您想要更新某个密钥的到期时间，可以使用此方法。超时值以秒为单位在超时参数中设置。</p>
<p><strong>语法</strong></p>
<p><code>cache.touch(key, timeout=DEFAULT_TIMEOUT, version=None)</code></p>
<p><strong>例子</strong></p>
<div class="codehilite"><pre><span/><code>&gt;&gt;&gt; cache.set<span class="o">(</span><span class="s1">'sample'</span>, <span class="s1">'just a sample'</span>, <span class="nv">timeout</span><span class="o">=</span><span class="m">120</span><span class="o">)</span>
&gt;&gt;&gt; cache.touch<span class="o">(</span><span class="s1">'sample'</span>, <span class="nv">timeout</span><span class="o">=</span><span class="m">180</span><span class="o">)</span>
</code></pre></div>

<h3 id="cacheincr-and-cachedecr">cache.incr和cache.decr</h3>
<p>这两种方法可以用来增加或减少一个已经存在的键值。如果在不存在的缓存键上使用这些方法，它将返回一个<code>ValueError</code>。</p>
<p>在未指定delta参数的情况下，该值将增加/减少1。</p>
<p><strong>语法</strong></p>
<div class="codehilite"><pre><span/><code>cache.incr(key, delta=1, version=None)

cache.decr(key, delta=1, version=None)
</code></pre></div>

<p><strong>例子</strong></p>
<div class="codehilite"><pre><span/><code>&gt;&gt;&gt; cache.set<span class="o">(</span><span class="s1">'my_first_key'</span>, <span class="m">1</span><span class="o">)</span>
&gt;&gt;&gt; cache.incr<span class="o">(</span><span class="s1">'my_first_key'</span><span class="o">)</span>
<span class="m">2</span>
&gt;&gt;&gt;
&gt;&gt;&gt; cache.incr<span class="o">(</span><span class="s1">'my_first_key'</span>, <span class="m">10</span><span class="o">)</span>
<span class="m">12</span>
</code></pre></div>

<h3 id="cacheclose">cache.close()</h3>
<p>要关闭到缓存的连接，可以使用<code>close()</code>方法。</p>
<p><strong>语法</strong></p>
<p><code>cache.close()</code></p>
<p><strong>例子</strong></p>
<p><code>cache.close()</code></p>
<h3 id="cacheclear">cache.clear</h3>
<p>要一次删除缓存中的所有键，可以使用这个方法。请记住，这将从缓存中删除所有的东西，而不仅仅是你的应用程序设置的键。</p>
<p><strong>语法</strong></p>
<p><code>cache.clear()</code></p>
<p><strong>例子</strong></p>
<p><code>cache.clear()</code></p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们研究了Django中的低级缓存API。我们扩展了一个演示项目以使用低级缓存，并且使用Django的数据库信号和Django生命周期钩子第三方包使缓存无效。</p>
<p>我们还提供了Django低级缓存API中所有可用方法的概述，以及如何使用它们的示例。</p>
<p>你可以在<a href="https://github.com/testdrivenio/django-low-level-cache">django-低级缓存</a> repo中找到最终代码。</p>
<p>--</p>
<p><strong> Django缓存文章:</strong></p>
<ol>
<li><a href="/blog/django-caching/">Django中的缓存</a></li>
<li><a href="/blog/django-low-level-cache/">Django中的低级缓存API</a>(本文！)</li>
</ol>
  </div>

  </div>    
</body>
</html>