<html>
<head>
<title>Pytest for Beginners </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>初学Pytest</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/pytest-for-beginners/#0001-01-01">https://testdriven.io/blog/pytest-for-beginners/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>自动化测试是开发过程中必不可少的一部分。</p>
<p>尽管一开始编写测试看起来像是延长了开发过程，但从长远来看，它为您节省了大量时间。</p>
<p>编写良好的测试通过确保您的代码如您所愿，降低了生产环境中出现问题的可能性。测试还能帮助你覆盖边缘案例，使重构更容易。</p>
<p>在本文中，我们将了解如何使用<a href="https://docs.pytest.org/"> pytest </a>，这样您就能够自己使用它来改进您的开发过程，并遵循更高级的pytest教程。</p>



<h2 id="objectives">目标</h2>
<p>在本文结束时，您将能够:</p>
<ol>
<li>解释pytest是什么以及如何使用它</li>
<li>用pytest自己编写一个测试</li>
<li>跟随使用pytest的更复杂的教程</li>
<li>准备测试所需的数据和/或文件</li>
<li>将测试参数化</li>
<li>测试所需的模拟功能</li>
</ol>
<h2 id="why-pytest">为什么选择pytest</h2>
<p>虽然经常被忽视，但测试是如此重要，以至于Python自带了一个名为<a href="https://docs.python.org/3/library/unittest.html"> unittest </a>的内置测试框架。不过，在unittest中编写测试可能会很复杂，所以近年来，<a href="https://docs.pytest.org/"> pytest </a>框架已经成为标准。</p>
<p>pytest的一些显著优势是:</p>
<ol>
<li>需要更少的样板代码，使您的测试套件更具可读性</li>
<li>使用普通的assert语句，而不是unittest的assertSomething方法(例如，<code>assertEquals</code>、<code>assertTrue</code>)</li>
<li>夹具系统简化了测试状态的设置和拆除</li>
<li>功能方法</li>
<li>大型社区维护的插件生态系统</li>
</ol>
<h2 id="getting-started">入门指南</h2>
<p>因为这是指南而不是教程，所以我们准备了一个简单的FastAPI应用程序，您可以在阅读本文时参考。可以从<a href="https://github.com/testdrivenio/pytest_for_beginners_test_project"> GitHub </a>中克隆。</p>
<p>在<em>基本</em>分支上，我们的API有4个端点(在<em> main.py </em>中定义),它们使用<em> calculations.py </em>中的函数返回对两个整数执行某种基本算术运算(<code>+</code> / <code>-</code> / <code>*</code> / <code>/</code>)的结果。在<em> advanced_topics </em>分支上，增加了两个功能:</p>
<ol>
<li><code>CalculationsStoreJSON</code>(在<em> store_calculations.py </em>内部)类——允许你在JSON文件中存储和检索计算结果。</li>
<li><code>get_number_fact</code>(inside<em>number _ facts . py</em>)——调用远程API来检索关于某个数字的事实。</li>
</ol>
<blockquote>
<p>理解本文不需要FastAPI知识。</p>
</blockquote>
<p>在本文的第一部分，我们将使用<em>基础知识</em>分支。</p>
<p>创建并激活虚拟环境，并安装要求:</p>
<div class="codehilite"><pre><span/><code>$ python3.10 -m venv venv
$ <span class="nb">source</span> venv/bin/activate
<span class="o">(</span>venv<span class="o">)</span>$ pip install -r requirements.txt
</code></pre></div>

<h2 id="organizing-and-naming">组织和命名</h2>
<p>为了组织您的测试，您可以使用三种可能性，所有这些都在示例项目中使用:</p>
<table>
<thead>
<tr>
<th>组织于</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python包(文件夹包含一个<em> __init__。py </em>文件)</td>
<td>"测试_计算"</td>
</tr>
<tr>
<td>组件</td>
<td><em>测试_交换_操作. py </em></td>
</tr>
<tr>
<td>班级</td>
<td><code>TestCalculationEndpoints</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>说到组织测试的最佳实践，每个程序员都有自己的偏好。</p>
<p>本文的目的不是展示最佳实践，而是向您展示所有的可能性。</p>
</blockquote>
<p>如果您遵守以下<a href="https://docs.pytest.org/en/7.1.x/explanation/goodpractices.html#conventions-for-python-test-discovery">约定</a>，pytest将自己发现测试:</p>
<ul>
<li>您将您的测试添加到一个以<code>test_</code>开始或者以<code>_test.py</code>结束的文件中(例如<code>test_foo.py</code>或者<code>foo_test.py</code></li>
<li>您可以给测试函数加上前缀<code>test_</code>(例如<code>def test_foo()</code>)</li>
<li>如果您正在使用类，您可以将您的测试作为方法添加到以<code>Test</code>(例如，<code>class TestFoo</code>)为前缀的类中</li>
</ul>
<blockquote>
<p>不遵循命名约定的测试将不会被发现，所以要小心命名。</p>
<p>值得注意的是，命名约定<a href="https://docs.pytest.org/en/7.1.x/reference/reference.html#configuration-options">可以在命令行或<a href="https://docs.pytest.org/en/7.1.x/customize.html#configuration-file-formats">配置文件</a>中更改</a>。</p>
</blockquote>
<h2 id="test-anatomy">测试解剖学</h2>
<p>让我们看看<code>test_return_sum</code>(在<em>test _ calculation _ endpoints . py</em>文件中)测试函数是什么样子的:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># tests/test_endpoints/test_calculation_endpoints.py</span>


<span class="k">def</span> <span class="nf">test_return_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="c1"># Arrange</span>
   <span class="n">test_data</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s2">"first_val"</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
      <span class="s2">"second_val"</span><span class="p">:</span> <span class="mi">8</span>
   <span class="p">}</span>
   <span class="n">client</span> <span class="o">=</span> <span class="n">TestClient</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

   <span class="c1"># Act</span>
   <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/sum/"</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="n">test_data</span><span class="p">)</span>

   <span class="c1"># Assert</span>
   <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
   <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span> <span class="o">==</span> <span class="mi">18</span>
</code></pre></div>

<p>根据pytest <a href="https://docs.pytest.org/en/7.1.x/fixture.html#what-fixtures-are">文档</a>，每个测试功能由四个步骤组成:</p>
<ol>
<li><em>安排</em>——你为考试准备一切的地方(<code>test_data = {"first_val": 10, "second_val": 8}</code>)</li>
<li><em>动作</em>——启动你想要测试的行为的奇异的、改变状态的动作(<code>client.post("/sum/", json=test_data)</code>)</li>
<li><em>断言</em>——将<em>动作的结果</em>与期望的结果(<code>assert response.json() == 18</code>)进行比较</li>
<li><em>清理</em>——清理特定于测试的数据(通常在测试更复杂特性的测试中，你可以在<a href="https://testdriven.io/tips/6114106d-9e03-4289-a2cb-c7f4d37d5051/">我们的提示</a>中看到一个例子)</li>
</ol>
<h2 id="running-tests">运行测试</h2>
<p>pytest为您提供了很多控制，让您可以决定要运行哪些测试:</p>
<ol>
<li>所有的测试</li>
<li>特定包</li>
<li>特定模块</li>
<li>特定类别</li>
<li>特效试验</li>
<li>对应于特定关键字的测试</li>
</ol>
<p>让我们看看这是如何工作的...</p>
<blockquote>
<p>如果您正在使用我们的示例应用程序，那么如果您安装了需求，那么已经安装了<code>pytest</code>。</p><p>对于您自己的项目，<code>pytest</code>可以作为任何其他带有pip的包安装:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install pytest
</code></pre></div>
</blockquote>

<h3 id="running-all-the-tests">运行所有的测试</h3>
<p>运行<code>pytest</code>命令将简单地运行pytest可以找到的所有测试:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m <span class="nv">pytest</span>

<span class="o">===============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">===============================</span>
platform darwin -- Python <span class="m">3</span>.10.4, pytest-7.1.2, pluggy-1.0.0
rootdir: /Users/michael/repos/testdriven/pytest_for_beginners_test_project
plugins: anyio-3.6.1
collected <span class="m">8</span> items

tests/test_calculations/test_anticommutative_operations.py ..               <span class="o">[</span> <span class="m">25</span>%<span class="o">]</span>
tests/test_calculations/test_commutative_operations.py ..                   <span class="o">[</span> <span class="m">50</span>%<span class="o">]</span>
tests/test_endpoints/test_calculation_endpoints.py ....                     <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">================================</span> <span class="m">8</span> passed <span class="k">in</span> <span class="m">5</span>.19s <span class="o">================================</span>
</code></pre></div>

<p>pytest将通知您找到了多少个测试，以及这些测试是在哪个模块中找到的。在我们的示例应用程序中，pytest找到了8个测试，它们都通过了。</p>
<p>在消息的底部，您可以看到有多少测试通过/失败。</p>
<h4 id="incorrect-naming-pattern">不正确的命名模式</h4>
<p>正如已经讨论过的，不遵守正确命名约定的测试将不会被发现。错误命名的测试不会产生任何错误，所以您需要注意这一点。</p>
<p>例如，如果您将<code>TestCalculationEndpoints</code>类重命名为<code>CalculationEndpointsTest</code>，那么其中的所有测试都不会运行:</p>
<div class="codehilite"><pre><span/><code><span class="o">===============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">===============================</span>
platform darwin -- Python <span class="m">3</span>.10.4, pytest-7.1.2, pluggy-1.0.0
rootdir: /Users/michael/repos/testdriven/pytest_for_beginners_test_project
plugins: anyio-3.6.1
collected <span class="m">4</span> items

tests/test_calculations/test_anticommutative_operations.py ..               <span class="o">[</span> <span class="m">50</span>%<span class="o">]</span>
tests/test_calculations/test_commutative_operations.py ..                   <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">================================</span> <span class="m">4</span> passed <span class="k">in</span> <span class="m">0</span>.15s <span class="o">================================</span>
</code></pre></div>

<p>在继续之前，将名称改回<code>TestCalculationEndpoints</code>。</p>
<h4 id="failing-test">测试失败</h4>
<p>你的测试不会总是第一次就通过。</p>
<p>破坏<code>test_calculate_sum</code>中<code>assert</code>语句的预测输出，看看失败测试的输出是什么样的:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># tests/test_calculations/test_commutative_operations.py</span>


<span class="k">def</span> <span class="nf">test_calculate_sum</span><span class="p">():</span>

    <span class="n">calculation</span> <span class="o">=</span> <span class="n">calculate_sum</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">calculation</span> <span class="o">==</span> <span class="mi">7</span> <span class="c1"># whops, a mistake</span>
</code></pre></div>

<p>运行测试。您应该会看到类似如下的内容:</p>
<div class="codehilite"><pre><span/><code><span class="o">===============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">===============================</span>
platform darwin -- Python <span class="m">3</span>.10.4, pytest-7.1.2, pluggy-1.0.0
rootdir: /Users/michael/repos/testdriven/pytest_for_beginners_test_project
plugins: anyio-3.6.1
collected <span class="m">8</span> items

tests/test_calculations/test_anticommutative_operations.py ..               <span class="o">[</span> <span class="m">25</span>%<span class="o">]</span>
tests/test_calculations/test_commutative_operations.py F.                   <span class="o">[</span> <span class="m">50</span>%<span class="o">]</span>
tests/test_endpoints/test_calculation_endpoints.py ....                     <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">====================================</span> <span class="nv">FAILURES</span> <span class="o">=====================================</span>
_______________________________ test_calculate_sum ________________________________

    def test_calculate_sum<span class="o">()</span>:

        <span class="nv">calculation</span> <span class="o">=</span> calculate_sum<span class="o">(</span><span class="m">5</span>, <span class="m">3</span><span class="o">)</span>

&gt;       assert <span class="nv">calculation</span> <span class="o">==</span> <span class="m">7</span>
E       assert <span class="nv">8</span> <span class="o">==</span> <span class="m">7</span>

tests/test_calculations/test_commutative_operations.py:8: <span class="nv">AssertionError</span>
<span class="o">=============================</span> short <span class="nb">test</span> summary <span class="nv">info</span> <span class="o">=============================</span>
FAILED tests/test_calculations/test_commutative_operations.py::test_calculate_sum
<span class="o">===========================</span> <span class="m">1</span> failed, <span class="m">7</span> passed <span class="k">in</span> <span class="m">0</span>.26s <span class="o">===========================</span>
</code></pre></div>

<p>在消息的底部，您可以看到一个<em>简短测试摘要信息</em>部分。这将告诉您哪个测试失败了，失败在哪里。在这种情况下，实际输出- <code>8</code> -与预期输出- <code>7</code>不匹配。</p>
<p>如果你向上滚动一点，失败的测试会详细显示出来，所以更容易指出哪里出错了(对更复杂的测试有帮助)。</p>
<p>在继续之前修复这个测试。</p>
<h3 id="running-tests-in-a-specific-package-or-module">在特定的包或模块中运行测试</h3>
<p>要运行一个特定的包或模块，您只需要在pytest命令中添加一个特定测试集的完整相对路径。</p>
<p><strong>对于一个包:</strong></p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests/test_calculations
</code></pre></div>

<p>该命令将运行“tests/test_calculations”包中的所有测试。</p>
<p><strong>对于模块:</strong></p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests/test_calculations/test_commutative_operations.py
</code></pre></div>

<p>该命令将运行<em>测试/测试_计算/测试_交换_操作. py </em>模块中的所有测试。</p>
<p>两者的输出将与前一个相似，除了执行的测试数量会更少。</p>
<h3 id="running-tests-in-a-specific-class">在特定类中运行测试</h3>
<p>要在pytest中访问一个特定的类，您需要写一个到它的模块的相对路径，然后在<code>::</code>之后添加这个类:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests/test_endpoints/test_calculation_endpoints.py::TestCalculationEndpoints
</code></pre></div>

<p>这个命令将执行<code>TestCalculationEndpoints</code>类中的所有测试。</p>
<h3 id="running-a-specific-test">运行特定测试</h3>
<p>您可以像访问类一样访问特定的测试，在相对路径后加上两个冒号，后跟测试名称:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests/test_calculations/test_commutative_operations.py::test_calculate_sum
</code></pre></div>

<p>如果您希望运行的函数在一个类中，则需要以如下形式运行一个测试:</p>
<p><code>relative_path_to_module::TestClass::test_method</code></p>
<p>例如:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests/test_endpoints/test_calculation_endpoints.py::TestCalculationEndpoints::test_return_sum
</code></pre></div>

<h3 id="running-tests-by-keyword">按关键字运行测试</h3>
<p>现在，假设您只想运行与组织相关的测试。因为我们在处理除法的测试名称中包含了单词“divided ”,所以您可以像这样运行这些测试:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest -k <span class="s2">"dividend"</span>
</code></pre></div>

<p>因此，8个测试中的2个将运行:</p>
<div class="codehilite"><pre><span/><code><span class="o">===============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">===============================</span>
platform darwin -- Python <span class="m">3</span>.10.4, pytest-7.1.2, pluggy-1.0.0
rootdir: /Users/michael/repos/testdriven/pytest_for_beginners_test_project
plugins: anyio-3.6.1
collected <span class="m">8</span> items / <span class="m">6</span> deselected / <span class="m">2</span> selected

tests/test_calculations/test_anticommutative_operations.py .                <span class="o">[</span> <span class="m">50</span>%<span class="o">]</span>
tests/test_endpoints/test_calculation_endpoints.py .                        <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=========================</span> <span class="m">2</span> passed, <span class="m">6</span> deselected <span class="k">in</span> <span class="m">0</span>.18s <span class="o">=========================</span>
</code></pre></div>

<blockquote>
<p>这些并不是选择特定测试子集的唯一方法。更多信息请参考<a href="https://docs.pytest.org/en/7.1.x/how-to/usage.html">官方文档</a>。</p>
</blockquote>
<h2 id="pytest-flags-worth-remembering">值得记住的pytest标志</h2>
<p>pytest包括许多<a href="https://docs.pytest.org/en/7.1.x/reference/reference.html#command-line-flags">标志</a>；您可以使用<code>pytest --help</code>命令将它们全部列出。</p>
<p>其中最有用的有:</p>
<ol>
<li><code>pytest -v</code>增加一级详细度，<code>pytest -vv</code>增加两级详细度。例如，当使用参数化(用不同的输入/输出多次运行相同的测试)时，只运行<code>pytest</code>会通知您有多少测试版本通过，有多少失败，同时添加<code>-v</code>也会输出使用了哪些参数。如果你添加<code>-vv</code>，你会看到每个测试版本的输入参数。您可以在<a href="https://docs.pytest.org/en/7.1.x/how-to/output.html#verbosity"> pytest文档</a>上看到更详细的示例。</li>
<li><code>pytest -lf</code>仅重新运行上次运行失败的测试。如果没有失败，所有的测试都将运行。</li>
<li>添加<code>-x</code>标志会导致pytest在第一次出错或测试失败时立即退出。</li>
</ol>
<h2 id="parameterizing">参数化</h2>
<p>我们讨论了基础知识，现在开始讨论更高级的话题。</p>
<blockquote>
<p>如果你正在跟进回购，将分支从<em>基础</em>切换到<em>高级_主题</em> ( <code>git checkout advanced_topics</code>)。</p>
</blockquote>
<p>有时候，一个简单的输入就足够了，但是也有很多时候你想要测试多个输入——例如，电子邮件、密码等等。</p>
<p>你可以通过<code>@pytest.mark.parametrize</code>装饰器用<a href="https://docs.pytest.org/en/7.1.x/how-to/parametrize.html">参数化</a>来添加多个输入和它们各自的输出。</p>
<p>例如，对于反交换运算，传递的数字的顺序很重要。明智的做法是涵盖更多情况，以确保该函数在所有情况下都能正常工作:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># tests/test_calculations/test_anticommutative_operations.py</span>


<span class="kn">import</span> <span class="nn">pytest</span>

<span class="kn">from</span> <span class="nn">calculations</span> <span class="kn">import</span> <span class="n">calculate_difference</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span>
    <span class="s2">"first_value, second_value, expected_output"</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_calculate_difference</span><span class="p">(</span><span class="n">first_value</span><span class="p">,</span> <span class="n">second_value</span><span class="p">,</span> <span class="n">expected_output</span><span class="p">):</span>

    <span class="n">calculation</span> <span class="o">=</span> <span class="n">calculate_difference</span><span class="p">(</span><span class="n">first_value</span><span class="p">,</span> <span class="n">second_value</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">calculation</span> <span class="o">==</span> <span class="n">expected_output</span>
</code></pre></div>

<p><code>@pytest.mark.parametrize</code>具有严格的结构形式:</p>
<ol>
<li>您向装饰者传递两个参数:<ol>
<li>参数名称以逗号分隔的字符串</li>
<li>参数值的列表，其位置对应于参数名的位置</li>
</ol>
</li>
<li>您将参数名传递给测试函数(它们不依赖于位置)</li>
</ol>
<p>如果您运行该测试，它将运行4次，每次使用不同的输入和输出:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest -v  tests/test_calculations/test_anticommutative_operations.py::test_calculate_difference

<span class="o">===============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">===============================</span>
platform darwin -- Python <span class="m">3</span>.10.4, pytest-7.1.2, pluggy-1.0.0
rootdir: /Users/michael/repos/testdriven/pytest_for_beginners_test_project
plugins: anyio-3.6.1
collected <span class="m">4</span> items

tests/test_calculations/test_anticommutative_operations.py::test_calculate_difference<span class="o">[</span><span class="m">10</span>-8-2<span class="o">]</span> PASSED <span class="o">[</span> <span class="m">25</span>%<span class="o">]</span>
tests/test_calculations/test_anticommutative_operations.py::test_calculate_difference<span class="o">[</span><span class="m">8</span>-10--2<span class="o">]</span> PASSED <span class="o">[</span> <span class="m">50</span>%<span class="o">]</span>
tests/test_calculations/test_anticommutative_operations.py::test_calculate_difference<span class="o">[</span>-10--8--2<span class="o">]</span> PASSED <span class="o">[</span> <span class="m">75</span>%<span class="o">]</span>
tests/test_calculations/test_anticommutative_operations.py::test_calculate_difference<span class="o">[</span>-8--10-2<span class="o">]</span> PASSED <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">================================</span> <span class="m">4</span> passed <span class="k">in</span> <span class="m">0</span>.01s <span class="o">================================</span>
</code></pre></div>

<h2 id="fixtures">固定装置</h2>
<p>当<em>排列</em>步骤在多个测试中完全相同时，或者如果它太复杂以至于损害了测试的可读性时，将<em>排列</em>(以及随后的<em>清理</em>)步骤移动到一个单独的<a href="https://docs.pytest.org/en/7.1.x/fixture.html">夹具</a>功能是一个好主意。</p>
<h3 id="creation">创造</h3>
<p>用<code>@pytest.fixture</code>装饰器将一个函数标记为fixture。</p>
<p>旧版本的<code>TestCalculationEndpoints</code>在每个方法中都有一个创建<code>TestClient</code>的步骤。</p>
<p>例如:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># tests/test_endpoints/test_calculation_endpoints.py</span>


<span class="k">def</span> <span class="nf">test_return_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">test_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"first_val"</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s2">"second_val"</span><span class="p">:</span> <span class="mi">8</span>
    <span class="p">}</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">TestClient</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

    <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/sum/"</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="n">test_data</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span> <span class="o">==</span> <span class="mi">18</span>
</code></pre></div>

<p>在<em> advanced_topics </em>分支中，您会看到该方法现在看起来更加清晰:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># tests/test_endpoints/test_calculation_endpoints.py</span>


<span class="k">def</span> <span class="nf">test_return_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_app</span><span class="p">):</span>
    <span class="n">test_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"first_val"</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s2">"second_val"</span><span class="p">:</span> <span class="mi">8</span>
    <span class="p">}</span>

    <span class="n">response</span> <span class="o">=</span> <span class="n">test_app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/sum/"</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="n">test_data</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span> <span class="o">==</span> <span class="mi">18</span>
</code></pre></div>

<p>后两个保持原样，所以你可以比较它们(不要在现实生活中这样做；毫无意义)。</p>
<p><code>test_return_sum</code>现在使用一个名为<code>test_app</code>的夹具，你可以在<em> conftest.py </em>文件中看到:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># tests/conftest.py</span>


<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">starlette.testclient</span> <span class="kn">import</span> <span class="n">TestClient</span>

<span class="kn">from</span> <span class="nn">main</span> <span class="kn">import</span> <span class="n">app</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">"module"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_app</span><span class="p">():</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">TestClient</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">client</span>
</code></pre></div>

<p>这是怎么回事？</p>
<ol>
<li><code>@pytest.fixture()</code>装饰器将函数<code>test_app</code>标记为fixture。当pytest读取该模块时，它会将该函数添加到fixtures列表中。测试函数可以使用列表中的任何fixture。</li>
<li>这个fixture是一个返回<code>TestClient</code>的简单函数，因此可以执行测试API调用。</li>
<li>将测试函数参数与一系列夹具进行比较。如果参数的值与fixture的名称匹配，fixture将被解析，其返回值将作为参数写入测试函数。</li>
<li>test函数使用fixture的结果进行测试，使用它的方式与使用任何其他变量值的方式相同。</li>
</ol>
<blockquote>
<p>另一个需要注意的重要事情是，函数不是传递给fixture本身，而是传递给fixture值。</p>
</blockquote>
<h3 id="scope">范围</h3>
<p>Fixtures是在测试第一次请求时创建的，但是它们是基于它们的作用域而被销毁的。夹具被破坏后，如果另一个试验需要，需要再次调用它；因此，您需要注意耗时的固定程序(例如，API调用)的范围。</p>
<p>有五个可能的<a href="https://docs.pytest.org/en/7.1.x/how-to/fixtures.html#fixture-scopes">范围</a>，从最窄到最宽:</p>
<table>
<thead>
<tr>
<th>范围</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能(默认)</td>
<td>测试结束时，夹具被破坏。</td>
</tr>
<tr>
<td>班级</td>
<td>在<strong>级</strong>最后一次测试的拆卸过程中，夹具被破坏。</td>
</tr>
<tr>
<td>组件</td>
<td>在拆卸<strong>模块</strong>中的最后一次测试时，夹具被破坏。</td>
</tr>
<tr>
<td>包裹</td>
<td>在拆卸<strong>包装</strong>中的最后一次测试时，夹具被破坏。</td>
</tr>
<tr>
<td>会议</td>
<td>夹具在测试<strong>阶段</strong>结束时被销毁。</td>
</tr>
</tbody>
</table>
<p>要更改上例中的范围，只需设置<code>scope</code>参数:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># tests/conftest.py</span>


<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">starlette.testclient</span> <span class="kn">import</span> <span class="n">TestClient</span>

<span class="kn">from</span> <span class="nn">main</span> <span class="kn">import</span> <span class="n">app</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">"function"</span><span class="p">)</span> <span class="c1"># scope changed</span>
<span class="k">def</span> <span class="nf">test_app</span><span class="p">():</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">TestClient</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">client</span>
</code></pre></div>

<blockquote>
<p>定义尽可能小的范围有多重要取决于fixture的耗时程度。创建一个<code>TestClient</code>不是很耗时，所以改变范围不会缩短测试运行。但是，例如，使用调用外部API的fixture运行10个测试可能非常耗时，所以最好使用<code>module</code>作用域。</p>
</blockquote>
<h2 id="temporary-files">临时文件</h2>
<p>当您的生产代码必须处理文件时，您的测试也是如此。</p>
<p>为了避免多个测试文件之间的干扰，甚至是应用程序的其余部分和额外的清理过程，最好使用一个唯一的临时目录。</p>
<p>在示例应用程序中，我们存储了在JSON文件上执行的所有操作，以供将来分析。现在，因为您肯定不希望在测试运行期间更改生产文件，所以您需要创建一个单独的临时JSON文件。</p>
<p>要测试的代码可以在<em> store_calculations.py </em>中找到:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># store_calculations.py</span>


<span class="kn">import</span> <span class="nn">json</span>


<span class="k">class</span> <span class="nc">CalculationsStoreJSON</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_file_path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_file_path</span> <span class="o">=</span> <span class="n">json_file_path</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_path</span> <span class="o">/</span> <span class="s2">"calculations.json"</span><span class="p">,</span> <span class="s2">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">([],</span> <span class="n">file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calculation</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_path</span><span class="o">/</span><span class="s2">"calculations.json"</span><span class="p">,</span> <span class="s2">"r+"</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">calculations</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="n">calculations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calculation</span><span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">calculations</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">list_operation_usages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_path</span> <span class="o">/</span> <span class="s2">"calculations.json"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">calculations</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">calculation</span> <span class="k">for</span> <span class="n">calculation</span> <span class="ow">in</span> <span class="n">calculations</span> <span class="k">if</span> <span class="n">calculation</span><span class="p">[</span><span class="s1">'operation'</span><span class="p">]</span> <span class="o">==</span> <span class="n">operation</span><span class="p">]</span>
</code></pre></div>

<p>注意，在初始化<code>CalculationsStoreJSON</code>时，您必须提供一个<code>json_file_path</code>，JSON文件将存储在这里。这可以是磁盘上的任何有效路径；对于产品代码和测试，您可以用同样的方式传递路径。</p>
<p>幸运的是，pytest提供了许多<a href="https://docs.pytest.org/en/7.1.x/reference/fixtures.html#built-in-fixtures">内置夹具</a>，其中一个我们可以在这里使用，叫做<a href="https://docs.pytest.org/en/7.1.x/how-to/tmp_path.html"> tmppath </a>:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># tests/test_advanced/test_calculations_storage.py</span>


<span class="kn">from</span> <span class="nn">store_calculations</span> <span class="kn">import</span> <span class="n">CalculationsStoreJSON</span>

<span class="k">def</span> <span class="nf">test_correct_calculations_listed_from_json</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">):</span>
    <span class="n">store</span> <span class="o">=</span> <span class="n">CalculationsStoreJSON</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">)</span>
    <span class="n">calculation_with_multiplication</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"value_1"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">"value_2"</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">"operation"</span><span class="p">:</span> <span class="s2">"multiplication"</span><span class="p">}</span>

    <span class="n">store</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">calculation_with_multiplication</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">store</span><span class="o">.</span><span class="n">list_operation_usages</span><span class="p">(</span><span class="s2">"multiplication"</span><span class="p">)</span> <span class="o">==</span> <span class="p">[{</span><span class="s2">"value_1"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">"value_2"</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">"operation"</span><span class="p">:</span> <span class="s2">"multiplication"</span><span class="p">}]</span>
</code></pre></div>

<p>该测试检查在使用<code>CalculationsStoreJSON.add()</code>方法将计算保存到JSON文件时，我们是否可以使用<code>UserStoreJSON.list_operation_usages()</code>检索某些操作的列表。</p>
<p>我们将<code>tmp_path</code> fixture传递给这个测试，它返回一个path ( <code>pathlib.Path</code>)对象，该对象指向基目录中的一个临时目录。</p>
<p>当使用<code>tmp_path</code>时，pytest创建一个:</p>
<ol>
<li>基本临时目录</li>
<li>对每个测试函数调用来说唯一的临时目录(在基目录中)</li>
</ol>
<blockquote>
<p>值得注意的是，为了帮助调试，pytest会在每个测试会话期间创建一个新的基本临时目录，而旧的基本目录会在3个会话之后被删除。</p>
</blockquote>
<h2 id="monkeypatching">猴子补丁</h2>
<p>使用<a href="https://en.wikipedia.org/wiki/Monkey_patch"> monkeypatching </a>，您可以在运行时动态修改一段代码的行为，而无需实际更改源代码。</p>
<p>虽然它不一定仅限于测试，但在pytest中，它用于修改被测单元内部代码部分的行为。它通常用于替换昂贵的函数调用，比如对API的HTTP调用，使用一些预定义的快速且易于控制的虚拟行为。</p>
<p>例如，不是调用真正的API来获得响应，而是返回一些在测试中使用的硬编码响应。</p>
<p>让我们深入了解一下。在我们的应用程序中，有一个函数返回从公共API中检索到的某个数字的事实:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># number_facts.py</span>


<span class="kn">import</span> <span class="nn">requests</span>

<span class="k">def</span> <span class="nf">get_number_fact</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="n">url</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"http://numbersapi.com/</span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s2">?json"</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">json_resp</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">json_resp</span><span class="p">[</span><span class="s2">"found"</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">json_resp</span><span class="p">[</span><span class="s2">"text"</span><span class="p">]</span>

    <span class="k">return</span> <span class="s2">"No fact about this number."</span>
</code></pre></div>

<p>您不想在测试期间调用API，因为:</p>
<ul>
<li>它很慢</li>
<li>这很容易出错(API可能会关闭，您的互联网连接可能很差，...)</li>
</ul>
<p>在这种情况下，您想要模拟响应，所以它返回我们感兴趣的部分<em>，而不需要</em>实际发出HTTP请求:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># tests/test_advanced/test_number_facts.py</span>


<span class="kn">import</span> <span class="nn">requests</span>

<span class="kn">from</span> <span class="nn">number_facts</span> <span class="kn">import</span> <span class="n">get_number_fact</span>


<span class="k">class</span> <span class="nc">MockedResponse</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_body</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_body</span> <span class="o">=</span> <span class="n">json_body</span>

    <span class="k">def</span> <span class="nf">json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_body</span>


<span class="k">def</span> <span class="nf">mock_get</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">MockedResponse</span><span class="p">({</span>
        <span class="s2">"text"</span><span class="p">:</span> <span class="s2">"7 is the number of days in a week."</span><span class="p">,</span>
        <span class="s2">"found"</span><span class="p">:</span> <span class="s2">"true"</span><span class="p">,</span>
    <span class="p">})</span>


<span class="k">def</span> <span class="nf">test_get_number_fact</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="n">requests</span><span class="p">,</span> <span class="s1">'get'</span><span class="p">,</span> <span class="n">mock_get</span><span class="p">)</span>

    <span class="n">number</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="n">fact</span> <span class="o">=</span> <span class="s1">'7 is the number of days in a week.'</span>

    <span class="k">assert</span> <span class="n">get_number_fact</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">==</span> <span class="n">fact</span>
</code></pre></div>

<p>这里发生了很多事情:</p>
<ol>
<li>测试函数中使用了pytest的内置<a href="https://docs.pytest.org/en/7.1.x/how-to/monkeypatch.html"> monkeypatch </a>夹具。</li>
<li>使用<code>monkeypatch.setattr</code>，我们用自己的函数<code>mock_get</code>覆盖了<code>requests</code>包的<code>get</code>函数。在这个测试的执行过程中，应用程序代码中对<code>requests.get</code>的所有调用现在都将实际调用<code>mock_get</code>。</li>
<li><code>mock_get</code>函数返回一个<code>MockedResponse</code>实例，用我们在<code>mock_get</code>函数(<code>{'"text": "7 is the number of days in a week.", "found": "true",}</code>)中分配的值替换<code>json_body</code>。</li>
<li>每次测试被调用时，不是像产品代码(<code>get_number_fact</code>)那样执行<code>requests.get("http://numbersapi.com/7?json")</code>，而是返回一个带有硬编码事实的<code>MockedResponse</code>。</li>
</ol>
<p>这样，您仍然可以验证函数的行为(从API响应中获得一个数字的事实)，而无需真正调用API。</p>
<h2 id="conclusion">结论</h2>
<p>pytest在过去几年中成为标准有许多原因，最值得注意的是:</p>
<ol>
<li>它简化了测试的编写。</li>
<li>由于其全面的输出，可以很容易地查明哪些测试失败以及失败的原因。</li>
<li>它为重复或复杂的测试准备、为测试目的创建文件以及测试隔离提供了解决方案。</li>
</ol>
<p>pytest提供了比我们在本文中讨论的更多的东西。</p>
<p>他们的文档包括有用的<a href="https://docs.pytest.org/en/7.1.x/contents.html#how-to-guides">操作指南</a>，深入涵盖了我们在这里浏览的大部分内容。他们还提供了一些<a href="https://docs.pytest.org/en/7.1.x/example/index.html#">的例子</a>。</p>
<p>pytest还附带了一个广泛的<a href="https://docs.pytest.org/en/7.0.x/reference/plugin_list.html">插件列表</a>，您可以用它来扩展pytest的功能。</p>
<p>这里有一些你可能会觉得有用的:</p>
<ul>
<li>pytest-cov 增加了对检查代码覆盖率的支持。</li>
<li>pytest-django 增加了一套测试django应用程序的有用工具。</li>
<li>pytest-xdist 允许您并行运行测试，从而缩短测试运行所需的时间。</li>
<li><a href="https://pypi.org/project/pytest-randomly/">pytest-random</a>以随机的顺序运行测试，防止它们意外地相互依赖。</li>
<li>pytest-asincio 让测试异步程序变得更加容易。</li>
<li>pytest-mock 提供了一个mocker fixture，它是标准unittest模拟包和附加实用程序的包装器。</li>
</ul>
<p>本文应该有助于您理解pytest库是如何工作的，以及使用它可以完成什么。然而，理解pytest如何工作和<strong>测试</strong>如何工作是不一样的。学习编写有意义的测试需要实践和理解你期望你的代码做什么。</p>
  </div>

  </div>    
</body>
</html>