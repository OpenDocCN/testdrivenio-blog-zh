<html>
<head>
<title>Session-based Auth with Flask for Single Page Apps </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Flask为单页应用程序进行基于会话的身份验证</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/flask-spa-auth/#0001-01-01">https://testdriven.io/blog/flask-spa-auth/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>在本文中，我们将看看如何使用基于会话的认证来认证<a href="https://en.wikipedia.org/wiki/Single-page_application">单页面应用程序</a> (SPAs)。我们将使用<a href="https://flask.palletsprojects.com/"> Flask </a>作为我们的后端，使用<a href="https://flask-login.readthedocs.io/"> Flask-Login </a>来管理会话。前端将使用<a href="https://svelte.dev/"> Svelte </a>构建，这是一个JavaScript前端框架，旨在构建丰富的用户界面。</p>
<blockquote>
<p>随意更换成不同的工具，如Angular，Vue或React。</p>
</blockquote>



<h2 id="session-vs-token-based-auth">会话与基于令牌的身份验证</h2>
<h3 id="what-are-they">它们是什么？</h3>
<p>使用基于会话的身份验证，会生成一个会话，并将ID存储在cookie中。</p>
<p>登录后，服务器会验证凭据。如果有效，它生成一个会话，存储它，然后将会话id发送回浏览器。浏览器将会话ID存储为cookie，每当向服务器发出请求时，就会发送该cookie。</p>
<p><img data-src="/static/images/blog/flask/flask-spa-auth/session_workflow.png" loading="lazy" class="lazyload" alt="session-based auth workflow" src="../Images/fa2af016022ab82e5dae1d461651b00f.png" data-original-src="https://testdriven.io/static/images/blog/flask/flask-spa-auth/session_workflow.png"/></p>
<p>基于会话的身份验证是有状态的。每次客户端向服务器发出请求时，服务器都必须在内存中定位会话，以便将会话ID绑定到相关用户。</p>
<p>另一方面，与基于会话的身份验证相比，基于令牌的身份验证相对较新。随着水疗和RESTful APIs的兴起，它获得了牵引力。</p>
<p>使用基于令牌的身份验证，在登录后，服务器验证凭据，如果有效，则创建一个签名的令牌并发送回浏览器。大多数情况下，令牌存储在localStorage中。然后，当向服务器发出请求时，客户端会将令牌添加到报头中。假设请求来自授权来源，服务器解码令牌并检查其有效性。</p>
<p><img data-src="/static/images/blog/flask/flask-spa-auth/token_workflow.png" loading="lazy" class="lazyload" alt="token-based auth workflow" src="../Images/2455f647bc1733762c9b9d71c0620221.png" data-original-src="https://testdriven.io/static/images/blog/flask/flask-spa-auth/token_workflow.png"/></p>
<p>令牌是对用户信息进行编码的字符串。</p>
<p>例如:</p>
<div class="codehilite"><pre><span/><code><span class="c1">// token header</span><span class="w"/>
<span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"alg"</span><span class="p">:</span><span class="w"> </span><span class="s2">"HS256"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"typ"</span><span class="p">:</span><span class="w"> </span><span class="s2">"JWT"</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="c1">// token payload</span><span class="w"/>
<span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"sub"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1234567890"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"John Doe"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"iat"</span><span class="p">:</span><span class="w"> </span><span class="mi">1516239022</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>令牌可以被验证和信任，因为它是使用秘密密钥或公钥/私钥对进行数字签名的。最常见的令牌类型是<a href="https://jwt.io/"> JSON Web令牌</a> (JWT)。</p>
<p>由于令牌包含服务器验证用户身份所需的所有信息，因此基于令牌的身份验证是无状态的。</p>
<blockquote>
<p>有关会话和令牌的更多信息，请查看Stack Exchange中的<a href="https://security.stackexchange.com/questions/81756/session-authentication-vs-token-authentication">会话认证与令牌认证</a>。</p>
</blockquote>
<h3 id="security-vulnerabilities">安全漏洞</h3>
<p>如前所述，基于会话的身份验证在cookie中维护客户端的状态。虽然JWT可以存储在localStorage或cookie中，但是大多数基于令牌的auth实现都将JWT存储在localStorage中。这两种方法都存在潜在的安全问题:</p>

<p>CSRF是一种针对web应用程序的攻击，攻击者试图欺骗经过身份验证的用户执行恶意操作。大多数CSRF攻击的目标是使用基于cookie的身份验证的web应用程序，因为web浏览器包括与每个请求的特定域相关联的所有cookie。因此，当发出恶意请求时，攻击者可以很容易地利用存储的cookies。</p>
<blockquote>
<p>要了解更多关于CSRF和如何在烧瓶中预防它，请查看烧瓶中的<a href="/blog/csrf-flask/"> CSRF保护</a>文章。</p>
</blockquote>
<p>XSS攻击是一种注入类型，恶意脚本被注入客户端，通常是为了绕过浏览器的同源策略。在localStorage中存储令牌的Web应用程序容易受到XSS攻击。打开浏览器并导航到任何站点。在开发者工具中打开控制台，输入<code>JSON.stringify(localStorage)</code>。按回车键。这应该以JSON序列化的形式打印localStorage元素。脚本访问localStorage就是这么容易。</p>
<blockquote>
<p>关于在哪里存储jwt的更多信息，请查看<a href="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage">在哪里存储jwt——cookie与HTML5 Web存储</a>。</p>
</blockquote>
<h2 id="setting-up-session-based-auth">设置基于会话的身份验证</h2>
<p>本质上有三种不同的方法将Flask与前端框架结合起来:</p>
<ol>
<li>通过Jinja模板提供框架</li>
<li>在同一个域上独立于Flask提供框架</li>
<li>在不同的域上独立于Flask提供框架</li>
</ol>
<blockquote>
<p>同样，你也可以随意选择苗条的前脸，比如，有棱角的，反应的，或者Vue。</p>
</blockquote>
<h2 id="frontend-served-from-flask">从长颈瓶供应的前端</h2>
<p>使用这种方法，我们将构建前端，并用Flask提供生成的<em>index.html</em>文件。</p>
<p>假设您已经安装了<a href="https://nodejs.org/en/download/package-manager/">节点</a>和<a href="https://www.npmjs.com/get-npm"> npm </a>，通过<a href="https://github.com/sveltejs/template">瘦项目模板</a>创建一个新项目:</p>
<div class="codehilite"><pre><span/><code>$ npx degit sveltejs/template flask-spa-jinja
$ <span class="nb">cd</span> flask-spa-jinja
</code></pre></div>

<p>安装依赖项:</p>


<p>创建一个名为<em> app.py </em>的文件来保存flask应用程序:</p>


<p>安装烧瓶、烧瓶登录和<a href="https://flask-wtf.readthedocs.io/">烧瓶WTF </a>:</p>
<div class="codehilite"><pre><span/><code>$ python3.10 -m venv env
$ <span class="nb">source</span> env/bin/activate
$ pip install <span class="nv">Flask</span><span class="o">==</span><span class="m">2</span>.2.2 Flask-Login<span class="o">==</span><span class="m">0</span>.6.2 Flask-WTF<span class="o">==</span><span class="m">1</span>.0.1
</code></pre></div>

<p>添加一个“templates”文件夹，并将<em> public/index.html </em>文件移动到其中。您的项目结构现在应该如下所示:</p>
<div class="codehilite"><pre><span/><code>├── .gitignore
├── README.md
├── app.py
├── package-lock.json
├── package.json
├── public
│   ├── favicon.png
│   └── global.css
├── rollup.config.js
├── scripts
│   └── setupTypeScript.js
├── src
│   ├── App.svelte
│   └── main.js
└── templates
    └── index.html
</code></pre></div>

<h3 id="flask-backend">烧瓶后端</h3>
<p>该应用程序有以下路线:</p>
<ol>
<li><code>/</code>上菜<em>index.html</em>文件</li>
<li><code>/api/login</code>让用户登录并生成会话</li>
<li><code>/api/data</code>获取已验证用户的用户数据</li>
<li><code>/api/getsession</code>检查会话是否存在</li>
<li><code>/api/logout</code>注销用户</li>
</ol>
<p>在这里抓取完整代码<a href="https://github.com/testdrivenio/flask-cookie-spa/blob/master/flask-spa-jinja/app.py">并将其添加到<em> app.py </em>文件中。</a></p>
<p>记下<code>/</code>路线的处理程序:</p>
<div class="codehilite"><pre><span/><code><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s2">"path"</span><span class="p">:</span> <span class="s2">""</span><span class="p">})</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/&lt;path:path&gt;"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">home</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s2">"index.html"</span><span class="p">)</span>
</code></pre></div>

<p>因为Flask最终提供SPA，所以CSRF cookie将被自动设置。</p>
<p>转到配置:</p>
<div class="codehilite"><pre><span/><code><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="n">DEBUG</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">SECRET_KEY</span><span class="o">=</span><span class="s2">"secret_sauce"</span><span class="p">,</span>
    <span class="n">SESSION_COOKIE_HTTPONLY</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">REMEMBER_COOKIE_HTTPONLY</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">SESSION_COOKIE_SAMESITE</span><span class="o">=</span><span class="s2">"Strict"</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div>

<p>设置为<code>True</code>的<code>HttpOnly</code>标志阻止任何客户端使用会话cookie:</p>
<div class="codehilite"><pre><span/><code><span class="n">SESSION_COOKIE_HTTPONLY</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="n">REMEMBER_COOKIE_HTTPONLY</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
</code></pre></div>

<p>我们还通过将<code>SESSION_COOKIE_SAMESITE</code>设置为<code>Strict</code>来防止任何外部请求发送cookies。</p>
<p>有关这些配置选项的更多信息，请查看Flask文档中的<a href="https://flask.palletsprojects.com/en/2.2.x/security/#set-cookie-options"> Set-Cookie选项</a>。</p>
<blockquote>
<p>确保将<code>SESSION_COOKIE_SECURE</code>和<code>REMEMBER_COOKIE_SECURE</code>设置为<code>True</code>，以将cookies限制为仅用于生产的HTTPS流量。</p>
</blockquote>
<p>更新<em> templates/index.html </em>，通过<code>url_for</code>加载静态文件:</p>
<div class="codehilite"><pre><span/><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">"en"</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">'utf-8'</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">'viewport'</span> <span class="na">content</span><span class="o">=</span><span class="s">'width=device-width,initial-scale=1'</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">"csrf-token"</span> <span class="na">content</span><span class="o">=</span><span class="s">"{{ csrf_token() }}"</span> <span class="p">/&gt;</span>

  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Svelte app<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">'icon'</span> <span class="na">type</span><span class="o">=</span><span class="s">'image/png'</span> <span class="na">href</span><span class="o">=</span><span class="s">"{{url_for('static', filename='favicon.png')}}"</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">'stylesheet'</span> <span class="na">href</span><span class="o">=</span><span class="s">"{{url_for('static', filename='global.css') }}"</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">'stylesheet'</span> <span class="na">href</span><span class="o">=</span><span class="s">"{{url_for('static', filename='build/bundle.css') }}"</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">script</span> <span class="na">defer</span> <span class="na">src</span><span class="o">=</span><span class="s">"{{url_for('static', filename='build/bundle.js') }}"</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div>

<p><code>csrf-token</code> meta标签保存由Flask应用程序生成的CSRF令牌。</p>
<h3 id="svelte-frontend">纤细的前端</h3>
<p>前端将有一个单独的组件，显示一个登录表单(当用户未经身份验证时)或一个简单的“您已通过身份验证！”消息(当用户通过身份验证时)。</p>
<p>在这里抓取完整代码<a href="https://github.com/testdrivenio/flask-spa-auth/blob/master/flask-spa-jinja/src/App.svelte">并将其添加到<em> src/App.svelte </em>文件中。</a></p>
<p>记下每个<code>fetch</code>请求的<code>credentials: "same-origin"</code>。如果URL和调用脚本在同一个源上，这将发送cookies。</p>
<p>例如:</p>
<div class="codehilite"><pre><span/><code><span class="kd">const</span><span class="w"> </span><span class="nx">whoami</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nx">fetch</span><span class="p">(</span><span class="s2">"/api/data"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nx">method</span><span class="o">:</span><span class="w"> </span><span class="s2">"GET"</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nx">headers</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="s2">"Content-Type"</span><span class="o">:</span><span class="w"> </span><span class="s2">"application/json"</span><span class="p">,</span><span class="w"/>
<span class="w">      </span><span class="s2">"X-CSRFToken"</span><span class="o">:</span><span class="w"> </span><span class="nx">csrf</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nx">credentials</span><span class="o">:</span><span class="w"> </span><span class="s2">"same-origin"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="p">})</span><span class="w"/>
<span class="w">  </span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span><span class="w"/>
<span class="w">  </span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="nx">alert</span><span class="p">(</span><span class="sb">`Welcome, </span><span class="si">${</span><span class="nx">data</span><span class="p">.</span><span class="nx">username</span><span class="si">}</span><span class="sb">!`</span><span class="p">);</span><span class="w"/>
<span class="w">  </span><span class="p">})</span><span class="w"/>
<span class="w">  </span><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span><span class="w"/>
<span class="w">  </span><span class="p">});</span><span class="w"/>
<span class="p">};</span><span class="w"/>
</code></pre></div>

<p>CSRF代币来自哪里？</p>
<p>我们将它添加到了<em> templates/index.html </em>中的meta标签中:</p>
<div class="codehilite"><pre><span/><code><span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">"csrf-token"</span> <span class="na">content</span><span class="o">=</span><span class="s">"{{ csrf_token() }}"</span> <span class="p">/&gt;</span>
</code></pre></div>

<p>然后，当<code>App</code>组件挂载时，我们将CSRF令牌分配给<code>csrf</code>变量:</p>
<div class="codehilite"><pre><span/><code><span class="kd">let</span><span class="w"> </span><span class="nx">csrf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByName</span><span class="p">(</span><span class="s2">"csrf-token"</span><span class="p">)[</span><span class="mf">0</span><span class="p">].</span><span class="nx">content</span><span class="p">;</span><span class="w"/>
</code></pre></div>

<p>接下来，更新<em> src/main.js </em>:</p>
<div class="codehilite"><pre><span/><code><span class="k">import</span><span class="w"> </span><span class="nx">App</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">'./App.svelte'</span><span class="p">;</span><span class="w"/>

<span class="kd">const</span><span class="w"> </span><span class="nx">app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">App</span><span class="p">({</span><span class="w"/>
<span class="w">  </span><span class="nx">target</span><span class="o">:</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span><span class="w"/>
<span class="p">});</span><span class="w"/>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">app</span><span class="p">;</span><span class="w"/>
</code></pre></div>

<p>当应用程序被编译时，来自<em> App.svelte </em>文件的代码被分成JavaScript和CSS文件。这些文件然后被注入到<em> src/index.html </em>，这是我们的SPA。在这种情况下，我们创建了一个新的应用程序，并使用<code>target: document.body</code>将其加载到整个HTML主体中。</p>
<h3 id="test">试验</h3>
<p>就是这样！我们准备好测试了。</p>
<p>创建一个新的构建，然后运行Flask:</p>
<div class="codehilite"><pre><span/><code>$ npm run build
$ python app.py
</code></pre></div>

<p>导航到<a href="http://localhost:5000"> http://localhost:5000 </a>。您应该会看到登录表单:</p>
<p><img data-src="/static/images/blog/flask/flask-spa-auth/login.png" loading="lazy" class="lazyload" alt="login form" src="../Images/4e033c21efb28c39c13b343f7b1d7eec.png" data-original-src="https://testdriven.io/static/images/blog/flask/flask-spa-auth/login.png"/></p>
<p>您可以使用以下方式登录:</p>
<ul>
<li>用户名:<code>test</code></li>
<li>密码:<code>test</code></li>
</ul>
<p>登录后，您可以从控制台看到会话cookie，并在HTML源代码中看到CSRF令牌的值:</p>
<p><img data-src="/static/images/blog/flask/flask-spa-auth/session.png" loading="lazy" class="lazyload" alt="session cookie" src="../Images/a1901ae89aed0509a6f89f7f31d4ba57.png" data-original-src="https://testdriven.io/static/images/blog/flask/flask-spa-auth/session.png"/></p>
<p><img data-src="/static/images/blog/flask/flask-spa-auth/csrf.png" loading="lazy" class="lazyload" alt="csrf token" src="../Images/637807c94682d3452bff06a765187152.png" data-original-src="https://testdriven.io/static/images/blog/flask/flask-spa-auth/csrf.png"/></p>
<p>如果会话cookie无效会发生什么？</p>
<p><img data-src="/static/images/blog/flask/flask-spa-auth/invalid_session.png" loading="lazy" class="lazyload" alt="invalid session cookie" src="../Images/71f500acf1dfadee0532b40a7b0e9742.png" data-original-src="https://testdriven.io/static/images/blog/flask/flask-spa-auth/invalid_session.png"/></p>
<p>你可以在这里找到这种方法的最终代码。</p>
<h2 id="frontend-served-separately-same-domain">单独提供前端服务(同一域)</h2>
<p>使用这种方法，我们将构建前端，并在同一个域上独立于Flask应用程序提供它。我们将使用Docker和Nginx在本地同一域上提供这两个应用程序。</p>
<p>这种方法与Jinja方法的最大区别是，您必须发出初始请求来获得CSRF令牌，因为它不会自动设置。</p>
<p>首先创建一个项目目录:</p>
<div class="codehilite"><pre><span/><code>$ mkdir flask-spa-same-origin <span class="o">&amp;&amp;</span> <span class="nb">cd</span> flask-spa-same-origin
</code></pre></div>

<p>现在，为后端创建一个文件夹:</p>
<div class="codehilite"><pre><span/><code>$ mkdir backend <span class="o">&amp;&amp;</span> <span class="nb">cd</span> backend
</code></pre></div>

<p>创建一个名为<em> app.py </em>的文件来保存flask应用程序:</p>


<p>添加一个<em> requirements.txt </em>文件来安装Flask、Flask-Login和Flask-WTF:</p>
<div class="codehilite"><pre><span/><code>Flask==2.2.2
Flask-Login==0.6.2
Flask-WTF==1.0.1
</code></pre></div>

<p>回到项目根，假设您已经安装了<a href="https://nodejs.org/en/download/package-manager/">节点</a>和<a href="https://www.npmjs.com/get-npm"> npm </a>，通过<a href="https://github.com/sveltejs/template">瘦项目模板</a>创建一个新项目:</p>
<div class="codehilite"><pre><span/><code>$ npx degit sveltejs/template frontend
$ <span class="nb">cd</span> frontend
</code></pre></div>

<p>安装依赖项:</p>


<p>您的项目结构现在应该如下所示:</p>
<div class="codehilite"><pre><span/><code>├── backend
│   ├── app.py
│   └── requirements.txt
└── frontend
    ├── .gitignore
    ├── README.md
    ├── package-lock.json
    ├── package.json
    ├── public
    │   ├── favicon.png
    │   ├── global.css
    │   └── index.html
    ├── rollup.config.js
    ├── scripts
    │   └── setupTypeScript.js
    └── src
        ├── App.svelte
        └── main.js
</code></pre></div>

<h3 id="flask-backend_1">烧瓶后端</h3>
<p>该应用程序有以下路线:</p>
<ol>
<li><code>/api/ping</code>进行快速的理智检查</li>
<li><code>/api/getcsrf</code>在响应头中返回一个CSRF令牌</li>
<li><code>/api/login</code>让用户登录并生成会话</li>
<li><code>/api/data</code>获取已验证用户的用户数据</li>
<li><code>/api/getsession</code>检查会话是否存在</li>
<li><code>/api/logout</code>注销用户</li>
</ol>
<p>在这里抓取完整代码<a href="https://github.com/testdrivenio/flask-cookie-spa/blob/master/flask-spa-same-origin/backend/app.py">并将其添加到<em>后端/app.py </em>文件中。</a></p>
<p>注意到:</p>
<div class="codehilite"><pre><span/><code><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/api/getcsrf"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s2">"GET"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">get_csrf</span><span class="p">():</span>
    <span class="n">token</span> <span class="o">=</span> <span class="n">generate_csrf</span><span class="p">()</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">jsonify</span><span class="p">({</span><span class="s2">"detail"</span><span class="p">:</span> <span class="s2">"CSRF cookie set"</span><span class="p">})</span>
    <span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">"X-CSRFToken"</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>
</code></pre></div>

<p>这里，我们创建了一个CSRF令牌，并将其设置在响应头中。</p>
<h3 id="svelte-frontend_1">纤细的前端</h3>
<p>该组件将再次为未经身份验证的用户显示一个登录表单，或者显示一个简单的“您已通过身份验证！”针对已验证用户的消息。</p>
<p>在这里抓取完整代码<a href="https://github.com/testdrivenio/flask-spa-auth/blob/master/flask-spa-same-origin/frontend/src/App.svelte">并将其添加到<em> frontend/src/App.svelte </em>文件中。</a></p>
<p>由于后端和前端是分离的，我们必须通过<code>/api/getcsrf</code>端点从后端手动获取令牌，并将其存储在内存中:</p>
<div class="codehilite"><pre><span/><code><span class="kd">const</span><span class="w"> </span><span class="nx">csrf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nx">fetch</span><span class="p">(</span><span class="s2">"/api/getcsrf"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nx">credentials</span><span class="o">:</span><span class="w"> </span><span class="s2">"same-origin"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="p">})</span><span class="w"/>
<span class="w">  </span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nx">csrfToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">res</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">get</span><span class="p">([</span><span class="s2">"X-CSRFToken"</span><span class="p">]);</span><span class="w"/>
<span class="w">    </span><span class="c1">// console.log(csrfToken);</span><span class="w"/>
<span class="w">  </span><span class="p">})</span><span class="w"/>
<span class="w">  </span><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span><span class="w"/>
<span class="w">  </span><span class="p">});</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>这个函数在组件挂载后被调用。</p>
<p>接下来，更新<em> frontend/src/main.js </em>:</p>
<div class="codehilite"><pre><span/><code><span class="k">import</span><span class="w"> </span><span class="nx">App</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">'./App.svelte'</span><span class="p">;</span><span class="w"/>

<span class="kd">const</span><span class="w"> </span><span class="nx">app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">App</span><span class="p">({</span><span class="w"/>
<span class="w">  </span><span class="nx">target</span><span class="o">:</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span><span class="w"/>
<span class="p">});</span><span class="w"/>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">app</span><span class="p">;</span><span class="w"/>
</code></pre></div>

<h3 id="docker">码头工人</h3>
<p>接下来，让我们对两个应用程序进行Dockerize。</p>
<h4 id="frontend-and-backend">前端和后端</h4>
<p><em>前端/Dockerfile </em>:</p>
<div class="codehilite"><pre><span/><code><span class="c"># pull the official base image</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">node:lts-alpine</span>

<span class="c"># set working directory</span>
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/usr/src/app</span>

<span class="c"># add `/usr/src/app/node_modules/.bin` to $PATH</span>
<span class="k">ENV</span><span class="w"> </span>PATH /usr/src/app/node_modules/.bin:<span class="nv">$PATH</span>
<span class="k">ENV</span><span class="w"> </span><span class="nv">HOST</span><span class="o">=</span><span class="m">0</span>.0.0.0

<span class="c"># install and cache app dependencies</span>
<span class="k">COPY</span><span class="w"> </span>package.json .
<span class="k">COPY</span><span class="w"> </span>package-lock.json .
<span class="k">RUN</span><span class="w"> </span>npm ci
<span class="k">RUN</span><span class="w"> </span>npm install <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d7a4a1b2bba3b297e4f9e7f9e7">[email protected]</a> -g --silent

<span class="c"># start app</span>
<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">"npm"</span><span class="p">,</span><span class="w"> </span><span class="s2">"run"</span><span class="p">,</span><span class="w"> </span><span class="s2">"dev"</span><span class="p">]</span>
</code></pre></div>

<p><em>后端/Dockerfile </em>:</p>
<div class="codehilite"><pre><span/><code><span class="c"># pull the official base image</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">python:3.10-slim-buster</span>

<span class="c"># set the working directory</span>
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/usr/src/app</span>

<span class="c"># set environment variables</span>
<span class="k">ENV</span><span class="w"> </span>PYTHONDONTWRITEBYTECODE <span class="m">1</span>
<span class="k">ENV</span><span class="w"> </span>PYTHONUNBUFFERED <span class="m">1</span>

<span class="c"># install dependencies</span>
<span class="k">RUN</span><span class="w"> </span>pip install --upgrade pip
<span class="k">COPY</span><span class="w"> </span>./requirements.txt .
<span class="k">RUN</span><span class="w"> </span>pip install -r requirements.txt

<span class="c"># add app</span>
<span class="k">COPY</span><span class="w"> </span>. .

<span class="c"># start app</span>
<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">"python"</span><span class="p">,</span><span class="w"> </span><span class="s2">"app.py"</span><span class="p">]</span>
</code></pre></div>

<p>向项目根目录添加一个<em> docker-compose.yml </em>文件，将两个应用程序绑定在一起:</p>
<div class="codehilite"><pre><span/><code><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">"3.8"</span><span class="w"/>

<span class="nt">services</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">backend</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./backend</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./backend:/usr/src/app</span><span class="w"/>
<span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">5000</span><span class="w"/>

<span class="w">  </span><span class="nt">frontend</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">stdin_open</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./frontend</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./frontend:/usr/src/app</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/usr/src/app/node_modules</span><span class="w"/>
<span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8080</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">backend</span><span class="w"/>
</code></pre></div>

<h4 id="nginx">Nginx</h4>
<p>为了在同一个域上运行这两个应用程序，让我们为Nginx添加一个作为反向代理的容器。在项目根目录下创建一个名为“nginx”的新文件夹。</p>
<p><em> nginx/Dockerfile </em>:</p>
<div class="codehilite"><pre><span/><code><span class="k">FROM</span><span class="w"> </span><span class="s">nginx:latest</span>
<span class="k">COPY</span><span class="w"> </span>./nginx.conf /etc/nginx/nginx.conf
</code></pre></div>

<p>同样添加一个<em> nginx/nginx.conf </em>配置文件。你可以在这里找到它的代码<a href="https://github.com/testdrivenio/flask-spa-auth/blob/master/flask-spa-same-origin/nginx/nginx.conf"/>。</p>
<p>注意两个<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#location">位置</a>块:</p>
<div class="codehilite"><pre><span/><code><span class="k">location</span><span class="w"> </span><span class="s">/api</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="kn">proxy_pass</span><span class="w">              </span><span class="s">http://backend:5000</span><span class="p">;</span><span class="w"/>
<span class="w">  </span><span class="kn">...</span><span class="w"/>
<span class="err">}</span><span class="w"/>

<span class="s">location</span><span class="w"> </span><span class="s">/</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="kn">proxy_pass</span><span class="w">              </span><span class="s">http://frontend:8080</span><span class="p">;</span><span class="w"/>
<span class="w">  </span><span class="kn">...</span><span class="w"/>
<span class="err">}</span><span class="w"/>
</code></pre></div>

<p>对<code>/</code>的请求将被转发到<code>http://frontend:8080</code> ( <code>frontend</code>是Docker合成文件中的服务名)，而对<code>/api</code>的请求将被转发到<code>http://backend:5000</code> ( <code>backend</code>是Docker合成文件中的服务名)。</p>
<p>将服务添加到<em> docker_compose.yml </em>文件中:</p>
<div class="codehilite"><pre><span/><code><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">"3.8"</span><span class="w"/>

<span class="nt">services</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">backend</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./backend</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./backend:/usr/src/app</span><span class="w"/>
<span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">5000</span><span class="w"/>

<span class="w">  </span><span class="nt">frontend</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">stdin_open</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./frontend</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./frontend:/usr/src/app</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/usr/src/app/node_modules</span><span class="w"/>
<span class="w">    </span><span class="nt">expose</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8080</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">backend</span><span class="w"/>

<span class="w">  </span><span class="nt">reverse_proxy</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./nginx</span><span class="w"/>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">81:80</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">backend</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">frontend</span><span class="w"/>
</code></pre></div>

<p>您的项目结构现在应该如下所示:</p>
<div class="codehilite"><pre><span/><code>├── backend
│   ├── Dockerfile
│   ├── app.py
│   └── requirements.txt
├── docker-compose.yml
├── frontend
│   ├── .gitignore
│   ├── Dockerfile
│   ├── README.md
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   ├── favicon.png
│   │   ├── global.css
│   │   └── index.html
│   ├── rollup.config.js
│   ├── scripts
│   │   └── setupTypeScript.js
│   └── src
│       ├── App.svelte
│       └── main.js
└── nginx
    ├── Dockerfile
    └── nginx.conf
</code></pre></div>

<h3 id="test_1">试验</h3>
<p>构建映像并运行容器:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose up -d --build
</code></pre></div>

<p>导航到<a href="http://localhost:81"> http://localhost:81 </a>。您应该会看到登录表单。</p>
<p>登录方式:</p>
<ul>
<li>用户名:<code>test</code></li>
<li>密码:<code>test</code></li>
</ul>
<p>您可以在这里找到这种方法的最终代码<a href="https://github.com/testdrivenio/flask-spa-auth/tree/master/flask-spa-same-origin">。</a></p>
<h2 id="frontend-served-separately-cross-domain">单独提供前端服务(跨域)</h2>
<p>使用这种方法，我们将构建前端，并在不同的域上独立于Flask应用程序提供它。我们将不得不通过使用<a href="https://flask-cors.readthedocs.io/"> Flask-CORS </a>允许来自前端的跨域请求来稍微放松安全性。</p>
<p>首先创建一个项目目录:</p>
<div class="codehilite"><pre><span/><code>$ mkdir flask-spa-cross-origin <span class="o">&amp;&amp;</span> <span class="nb">cd</span> flask-spa-cross-origin
</code></pre></div>

<p>现在，为后端创建一个文件夹:</p>
<div class="codehilite"><pre><span/><code>$ mkdir backend <span class="o">&amp;&amp;</span> <span class="nb">cd</span> backend
</code></pre></div>

<p>创建一个名为<em> app.py </em>的文件来保存flask应用程序:</p>


<p>安装烧瓶、烧瓶登录、烧瓶WTF和烧瓶CORS:</p>
<div class="codehilite"><pre><span/><code>$ python3.9 -m venv env
$ <span class="nb">source</span> env/bin/activate
$ pip install <span class="nv">Flask</span><span class="o">==</span><span class="m">2</span>.2.2 Flask-Login<span class="o">==</span><span class="m">0</span>.6.2 Flask-WTF<span class="o">==</span><span class="m">1</span>.0.1 Flask-Cors<span class="o">==</span><span class="m">3</span>.0.10
</code></pre></div>

<p>回到项目根，假设您已经安装了<a href="https://nodejs.org/en/download/package-manager/">节点</a>和<a href="https://www.npmjs.com/get-npm"> npm </a>，通过<a href="https://github.com/sveltejs/template">瘦项目模板</a>创建一个新项目:</p>
<div class="codehilite"><pre><span/><code>$ npx degit sveltejs/template frontend
$ <span class="nb">cd</span> frontend
</code></pre></div>

<p>安装依赖项:</p>


<p>您的项目结构现在应该如下所示:</p>
<div class="codehilite"><pre><span/><code>├── backend
│   └── app.py
└── frontend
    ├── .gitignore
    ├── README.md
    ├── package-lock.json
    ├── package.json
    ├── public
    │   ├── favicon.png
    │   ├── global.css
    │   └── index.html
    ├── rollup.config.js
    ├── scripts
    │   └── setupTypeScript.js
    └── src
        ├── App.svelte
        └── main.js
</code></pre></div>

<h3 id="flask-backend_2">烧瓶后端</h3>
<p>该应用程序有以下路线:</p>
<ol>
<li><code>/api/ping</code>进行快速的理智检查</li>
<li><code>/api/getcsrf</code>在响应头中返回一个CSRF令牌</li>
<li><code>/api/login</code>让用户登录并生成会话</li>
<li><code>/api/data</code>获取已验证用户的用户数据</li>
<li><code>/api/getsession</code>检查会话是否存在</li>
<li><code>/api/logout</code>注销用户</li>
</ol>
<p>在这里抓取完整代码<a href="https://github.com/testdrivenio/flask-cookie-spa/blob/master/flask-spa-cross-origin/backend/app.py">并将其添加到<em>后端/app.py </em>文件中。</a></p>
<p>要启用CORS，我们必须配置服务器返回适当的头:</p>
<div class="codehilite"><pre><span/><code><span class="n">cors</span> <span class="o">=</span> <span class="n">CORS</span><span class="p">(</span>
    <span class="n">app</span><span class="p">,</span>
    <span class="n">resources</span><span class="o">=</span><span class="p">{</span><span class="sa">r</span><span class="s2">"*"</span><span class="p">:</span> <span class="p">{</span><span class="s2">"origins"</span><span class="p">:</span> <span class="s2">"http://localhost:8080"</span><span class="p">}},</span>
    <span class="n">expose_headers</span><span class="o">=</span><span class="p">[</span><span class="s2">"Content-Type"</span><span class="p">,</span> <span class="s2">"X-CSRFToken"</span><span class="p">],</span>
    <span class="n">supports_credentials</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div>

<p>注意事项:</p>
<ol>
<li><code>resources={r"*": {"origins": "http://localhost:8080"}}</code>启用来自<code>http://localhost:8080</code>的所有路由和HTTP方法的跨域请求。</li>
<li><code>expose_headers=["Content-Type", "X-CSRFToken"]</code>表示可以露出<code>Content-Type</code>和<code>X-CSRFToken</code>接头。</li>
<li><code>supports_credentials=True</code>允许跨域发送cookies。</li>
</ol>
<p>标题:</p>
<div class="codehilite"><pre><span/><code>Access-Control-Allow-Origin: http://localhost:8080
Access-Control-Expose-Headers: Content-Type, X-CSRFToken
Access-Control-Allow-Credentials: true
</code></pre></div>

<p>你有没有注意到<code>SESSION_COOKIE_SAMESITE</code>被设置为<code>Lax</code>？</p>
<div class="codehilite"><pre><span/><code><span class="n">SESSION_COOKIE_SAMESITE</span><span class="o">=</span><span class="s2">"Lax"</span><span class="p">,</span>
</code></pre></div>

<p>如果我们让它保持为<code>Strict</code>，就不会从前端发送cookies。顾名思义，<code>Lax</code>稍微放松了安全性，因此对于大多数请求，cookies将跨域发送。</p>
<p>查看Flask文档中的<a href="https://flask.palletsprojects.com/en/2.2.x/security/#set-cookie-options"> Set-Cookie选项</a>以了解更多相关信息。</p>
<h3 id="svelte-frontend_2">纤细的前端</h3>
<p>在这里抓取完整代码<a href="https://github.com/testdrivenio/flask-spa-auth/blob/master/flask-spa-cross-origin/frontend/src/App.svelte">并将其添加到<em> frontend/src/App.svelte </em>文件中。</a></p>
<p>这里与相同域方法的唯一变化是将<code>credentials: "same-origin"</code>改为<code>credentials: "include"</code>,这样即使请求URL在不同的域上，cookies仍然会被发送。</p>


<p>接下来，更新<em> frontend/src/main.js </em>:</p>
<div class="codehilite"><pre><span/><code><span class="k">import</span><span class="w"> </span><span class="nx">App</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">'./App.svelte'</span><span class="p">;</span><span class="w"/>

<span class="kd">const</span><span class="w"> </span><span class="nx">app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">App</span><span class="p">({</span><span class="w"/>
<span class="w">  </span><span class="nx">target</span><span class="o">:</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span><span class="w"/>
<span class="p">});</span><span class="w"/>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">app</span><span class="p">;</span><span class="w"/>
</code></pre></div>

<h3 id="test_2">试验</h3>
<p>旋转烧瓶应用程序:</p>


<p>然后，在不同的终端窗口中，运行Svelte:</p>


<p>导航到<a href="http://localhost:8080"> http://localhost:8080 </a>。您应该会看到登录表单。</p>
<p>登录方式:</p>
<ul>
<li>用户名:<code>test</code></li>
<li>密码:<code>test</code></li>
</ul>
<p><img data-src="/static/images/blog/flask/flask-spa-auth/response_headers.png" loading="lazy" class="lazyload" alt="HTTP response headers" src="../Images/1c584105522e99681b3b6134ebed61ec.png" data-original-src="https://testdriven.io/static/images/blog/flask/flask-spa-auth/response_headers.png"/></p>
<p>如果会话cookie无效会发生什么？</p>
<p>你可以在这里找到这种方法的最终代码。</p>
<h2 id="conclusion">结论</h2>
<p>本文详细介绍了如何为单页面应用程序设置基于会话的身份验证。无论您使用会话cookie还是令牌，当客户端是浏览器时，最好使用cookie进行身份验证。虽然最好从同一个域提供这两个应用程序，但您可以通过放宽跨域安全设置，在不同的域上提供它们。</p>
<p>我们研究了三种不同的方法来将Flask与具有基于会话的授权的前端框架相结合:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>前端</th>
<th>后端</th>
</tr>
</thead>
<tbody>
<tr>
<td>从长颈瓶供应的前端</td>
<td>从meta标签中获取CSRF令牌，并在获取请求中使用<code>credentials: "same-origin"</code>。</td>
<td>将<code>SESSION_COOKIE_HTTPONLY</code>和<code>REMEMBER_COOKIE_HTTPONLY</code>设置为<code>True</code>，将<code>SESSION_COOKIE_SAMESITE</code>设置为<code>"Strict"</code>。</td>
</tr>
<tr>
<td>单独提供前端服务(同一域)</td>
<td>获取CSRF令牌并在获取请求中使用<code>credentials: "same-origin"</code>。</td>
<td>添加一个路由处理程序，用于生成在响应头中设置的CSRF令牌。将<code>SESSION_COOKIE_HTTPONLY</code>和<code>REMEMBER_COOKIE_HTTPONLY</code>设置为<code>True</code>，将<code>SESSION_COOKIE_SAMESITE</code>设置为<code>"Strict"</code>。</td>
</tr>
<tr>
<td>单独提供前端服务(跨域)</td>
<td>获取CSRF令牌并在获取请求中使用<code>credentials: "include"</code>。</td>
<td>启用CORS并添加路由处理程序，以生成在响应标头中设置的CSRF令牌。将<code>SESSION_COOKIE_HTTPONLY</code>和<code>REMEMBER_COOKIE_HTTPONLY</code>设置为<code>True</code>，将<code>SESSION_COOKIE_SAMESITE</code>设置为<code>"Lax"</code>。</td>
</tr>
</tbody>
</table>
<p>从<a href="https://github.com/testdrivenio/flask-spa-auth"> flask-spa-auth </a> repo中获取代码。</p>
  </div>

  </div>    
</body>
</html>