<html>
<head>
<title>Combining Flask and Vue </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>组合烧瓶和Vue</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/combine-flask-vue/#0001-01-01">https://testdriven.io/blog/combine-flask-vue/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p><em>如何将Vue.js与Flask结合起来？</em></p>
<p>因此，您终于有了Flask，并且对JavaScript并不陌生。你甚至开发了一些web应用程序，但是你开始意识到一些事情——你有很好的功能，但是你的UX有点乏味。你今天在很多热门网站和应用上看到的应用流程和无缝导航在哪里？如何实现这一目标？</p>
<p>随着你对网站和网络应用的投入越来越多，你可能会想给它们添加更多的客户端功能和反应。现代web开发通常通过使用前端框架来实现这一点，其中一个流行度迅速上升的框架是<a href="https://vuejs.org/"> Vue </a>(也称为Vue.js或VueJS)。</p>
<p>根据您的项目需求，有几种不同的方法来使用Flask和Vue构建web应用程序，并且每种方法都涉及不同级别的后端/前端分离。</p>
<p>在本文中，我们将看看结合Flask和Vue的三种不同方法:</p>
<ol>
<li><strong> Jinja模板</strong>:将Vue导入Jinja模板</li>
<li><strong>单页应用</strong>:构建一个单页应用(SPA)来完全分离Flask和Vue</li>
<li><strong>烧瓶蓝图</strong>:从烧瓶蓝图中提供Vue，使两者部分分离</li>
</ol>
<p><img data-src="/static/images/blog/flask/combine-flask-vue/methods_for_combining_flask_and_vue.png" loading="lazy" class="lazyload" alt="Different Ways to Build a Web App with Flask and Vue" src="../Images/ea4f48e682619793d1a4e2932d432fb1.png" data-original-src="https://testdriven.io/static/images/blog/flask/combine-flask-vue/methods_for_combining_flask_and_vue.png"/></p>
<p>我们将分析每种方法的优缺点，查看它们的最佳用例，并详细说明如何设置它们。</p>



<h2 id="jinja-template">Jinja模板</h2>
<p>无论您使用React、Vue还是Angular，这都是过渡到使用前端框架的最简单方式。</p>
<p>在很多情况下，当你为你的web应用构建一个前端时，你是围绕着前端框架本身来设计的。然而，使用这种方法，重点仍然是您的后端Flask应用程序。如果需要的话，你仍然可以使用Jinja和服务器端模板，以及Vue的一些反应功能。</p>
<p>你可以通过<a href="https://en.wikipedia.org/wiki/Content_delivery_network">内容交付网络</a> (CDN)或者通过你的应用程序自带的方式导入Vue库，同时像平常一样设置和路由Flask。</p>
<h3 id="pros">赞成的意见</h3>
<ul>
<li>你可以按照自己的方式构建应用，而不是在Vue的基础上进行调整。</li>
<li>搜索引擎优化(SEO)不需要任何额外的配置。</li>
<li>您可以利用基于cookie的身份验证来代替基于令牌的身份验证。这往往更容易，因为您不需要处理前端和后端之间的异步通信。</li>
</ul>
<h3 id="cons">骗局</h3>
<ul>
<li>你必须导入Vue并单独设置每个页面，如果你开始在越来越多的页面上添加Vue，这可能会很困难。这可能还需要一些变通方法，因为这并不是真正想要使用Flask或Vue的方式。</li>
</ul>
<h3 id="best-for">最适合</h3>
<ul>
<li>小型web应用程序实际上使用一两个HTML页面(与拥有自己的动态路由的SPA相反——参见<a href="#single-page-application"> SPA </a>方法了解更多信息)。</li>
<li>将功能构建到现有的web应用程序中。</li>
<li>在不完全致力于前端框架的情况下，为应用程序增加一些反应性。</li>
<li>不需要通过AJAX频繁与后端通信的Web应用程序。</li>
</ul>
<h3 id="additional-dependencies">其他依赖项</h3>
<p>这种方法只需要Vue库，可以通过CDN添加:</p>
<div class="codehilite"><pre><span/><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>

<h3 id="setup">设置</h3>
<p>在所有方法中，这种设置是最简单的。</p>
<p>创建一个文件夹来存放您的应用程序的所有代码。在该文件夹中，像平常一样创建一个<em> app.py </em>文件:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">render_template</span> <span class="c1"># These are all we need for our purposes</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s2">"index.html"</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">"greeting"</span><span class="p">:</span> <span class="s2">"Hello from Flask!"</span><span class="p">})</span>
</code></pre></div>

<p>我们只需要从<code>flask</code>导入<code>Flask</code>和<code>render_template</code>。</p>
<p>当我们看如何在同一个文件中同时使用Jinja和Vue渲染变量时,<code>greeting</code>变量将会再次出现。</p>
<p>接下来，创建一个“模板”文件夹来保存我们的HTML文件。在这个文件夹中，创建一个<em>index.html</em>文件。在我们的HTML文件主体中，创建一个id为<code>vm</code>的容器div。</p>
<blockquote>
<p>值得注意的是，<code>vm</code>只是一个常见的命名标准。它代表<a href="https://012.vuejs.org/guide/#ViewModel">视图模型</a>。你想叫它什么都可以；不需要是<code>vm</code>。</p>
</blockquote>
<p>在<code>div</code>中，创建两个<code>p</code>标记作为Flask和Vue变量的占位符:</p>
<ol>
<li>其中一个<code>div</code>应该包含用大括号括起来的单词“greeting”:<code>{{ greeting }}</code>。</li>
<li>另一个应该包含用括号括起来的“问候”:<code>[[ greeting ]]</code>。</li>
</ol>
<p>如果不使用单独的分隔符，在默认设置下，Flask会用您传递的任何变量替换这两个问候语(例如，“来自Flask的Hello！”).</p>
<p>以下是我们目前掌握的情况:</p>
<div class="codehilite"><pre><span/><code><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="cm">&lt;!-- The id 'vm' is just for consistency - it can be anything you want --&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">"vm"</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>{{ greeting }}<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>[[ greeting ]]<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</code></pre></div>

<p>在body标签结束之前，从官方CDN导入Vue，同时导入一个脚本来保存我们的JavaScript代码:</p>
<div class="codehilite"><pre><span/><code><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="cm">&lt;!-- The id 'vm' is just for consistency - it can be anything you want --&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">"vm"</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>{{ greeting }}<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>[[ greeting ]]<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">"{{ url_for('static', filename='index.js') }}"</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</code></pre></div>

<p>向上导航一个目录，创建一个“静态”文件夹。在名为<em> index.js </em>的文件夹中添加一个新的JavaScript文件。</p>
<p>在这个文件中，创建Vue上下文，将我们实例的<code>el</code>设置为<code>'#vm'</code>，将默认分隔符从<code>'{{', '}}'</code>更改为<code>'[[', ']]'</code>:</p>
<div class="codehilite"><pre><span/><code><span class="kd">const</span><span class="w"> </span><span class="nx">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Vue</span><span class="p">({</span><span class="w"> </span><span class="c1">// Again, vm is our Vue instance's name for consistency.</span><span class="w"/>
<span class="w">    </span><span class="nx">el</span><span class="o">:</span><span class="w"> </span><span class="s1">'#vm'</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nx">delimiters</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s1">'[['</span><span class="p">,</span><span class="w"> </span><span class="s1">']]'</span><span class="p">]</span><span class="w"/>
<span class="p">})</span><span class="w"/>
</code></pre></div>

<blockquote>
<p>实际上，我们可以使用任何想要的东西作为分隔符。事实上，如果你喜欢，你可以在Flask中<a href="https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.jinja_options">改变</a>你的Jinja模板的分隔符。</p>
</blockquote>
<p>最后，添加一个键/值为<code>greeting: 'Hello, Vue!'</code>的数据元素:</p>
<div class="codehilite"><pre><span/><code><span class="kd">const</span><span class="w"> </span><span class="nx">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Vue</span><span class="p">({</span><span class="w"> </span><span class="c1">// Again, vm is our Vue instance's name for consistency.</span><span class="w"/>
<span class="w">    </span><span class="nx">el</span><span class="o">:</span><span class="w"> </span><span class="s1">'#vm'</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nx">delimiters</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s1">'[['</span><span class="p">,</span><span class="w"> </span><span class="s1">']]'</span><span class="p">],</span><span class="w"/>
<span class="w">    </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="nx">greeting</span><span class="o">:</span><span class="w"> </span><span class="s1">'Hello, Vue!'</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="p">})</span><span class="w"/>
</code></pre></div>

<p>现在我们完成了那个文件。最终的文件夹结构应该如下所示:</p>
<div class="codehilite"><pre><span/><code>├───app.py
├───static
│   └───index.js
└───templates
    └───index.html
</code></pre></div>

<p>现在你可以回到你的根项目文件夹，用<code>flask run</code>运行应用程序。在浏览器中导航到该站点。第一行和第二行应分别替换为Flask和Vue:</p>
<div class="codehilite"><pre><span/><code>Hello from Flask!
Hello, Vue!
</code></pre></div>

<p>就是这样！您可以随意混合搭配JSON端点和HTML端点，但是要注意这可能会很快变得很难看。对于更易于管理的替代方法，参见<a href="#flask-blueprint">烧瓶蓝图</a>方法。</p>
<p>对于每个额外的HTML页面，您必须要么导入相同的JavaScript文件并考虑可能不适用于它的变量和元素，要么为每个页面创建一个新的Vue对象。一个真正的SPA将是困难的，但不是不可能的——理论上你可以写一个小的JavaScript库，异步地获取Flask提供的HTML页面/元素。</p>
<blockquote>
<p>实际上，我之前已经为此创建了自己的JavaScript库。这是一个大麻烦，老实说不值得，特别是考虑到JavaScript不会运行以这种方式导入的脚本标记，除非您自己构建功能。你也将重新发明轮子。</p>
<p>如果你想看看我对这个方法的实现，你可以在<a href="https://github.com/based-jace/load-script-async"> GitHub </a>上找到它。该库获取一个给定的HTML块，并用它替换页面上指定的HTML。如果给定的HTML不包含<code>&lt;script&gt;</code>元素(它使用regex进行检查)，它简单地使用<code>HTMLElement.innerHTML</code>来替换它。如果它包含<code>&lt;script&gt;</code>元素，它递归地添加节点，重新创建出现的任何<code>&lt;script&gt;</code>节点，允许您的JavaScript运行。</p>
<p>将类似这样的东西与History API结合使用，可以帮助您构建一个文件非常小的小型SPA。您甚至可以创建自己的服务器端呈现(SSR)功能，在页面加载时提供完整的HTML页面，然后通过AJAX请求提供部分页面。您可以在使用Nuxt 方法的<a href="#single-page-application-with-nuxt"> SPA中了解有关SSR的更多信息。</a></p>
</blockquote>
<h2 id="single-page-application">单页应用程序</h2>
<p>如果你想构建一个具有无缝用户体验(UX)的完全动态的web应用，你可以将Flask后端与Vue前端完全分离。如果你不熟悉现代前端框架，这可能需要学习一种全新的web应用程序设计思维方式。</p>
<p>把你的应用开发成一个SPA可能会降低你的搜索引擎优化。在过去，这种打击会更加引人注目，但Googlebot如何索引网站的更新至少在某种程度上否定了这一点。然而，它可能仍然会对不显示JavaScript的非谷歌搜索引擎或那些过早抓取页面的搜索引擎产生更大的影响——如果你的网站得到了很好的优化，后一种情况应该不会发生。</p>
<blockquote>
<p>关于现代水疗中SEO的更多信息，这篇文章展示了Googlebot如何索引JavaScript渲染的网站。此外，<a href="https://www.smashingmagazine.com/2019/05/vue-js-seo-reactive-websites-search-engines-bots/">这篇文章</a>深入讨论了同样的事情，以及关于其他搜索引擎的SEO的其他有用提示。</p>
</blockquote>
<p>通过这种方法，您将希望使用<a href="https://cli.vuejs.org/"> Vue CLI </a>工具生成一个完全独立的Vue应用程序。然后，Flask将用于提供一个JSON RESTful API，您的Vue SPA将通过AJAX与之通信。</p>
<h3 id="pros_1">赞成的意见</h3>
<ul>
<li>您的前端和后端将完全相互独立，因此您可以对其中一个进行更改，而不会影响另一个。<ul>
<li>这使得它们可以单独部署、开发和维护。</li>
<li>如果您愿意，您甚至可以设置许多其他前端来与您的Flask API进行交互。</li>
</ul>
</li>
<li>你的前端体验会流畅很多，更无缝。</li>
</ul>
<h3 id="cons_1">骗局</h3>
<ul>
<li>还有更多的东西需要设置和学习。</li>
<li>部署困难。</li>
<li>如果没有进一步的干预，SEO可能会受到影响(更多细节请参见带Nuxt 方法的<a href="#single-page-application-with-nuxt"> SPA)。</a></li>
<li>身份验证要复杂得多，因为您必须不断地将您的身份验证令牌(<a href="https://jwt.io/"> JWT </a>或<a href="https://paseto.io/">帕斯托</a>)传递到您的后端。</li>
</ul>
<h3 id="best-for_1">最适合</h3>
<ul>
<li>UX比搜索引擎优化更重要的应用。</li>
<li>需要被多个前端访问的后端。</li>
</ul>
<h3 id="additional-dependencies_1">其他依赖项</h3>
<ul>
<li>节点/国家预防机制</li>
<li>CLI视图</li>
<li>弗拉斯克-CORS</li>
</ul>
<blockquote>
<p>部署和容器化超出了本文的范围，但是将这种设置进行Dockerize以简化部署并不十分困难。</p>
</blockquote>
<h3 id="setup_1">设置</h3>
<p>因为我们完全将Vue从Flask中分离出来，所以这个方法需要更多的设置。我们需要在Flask中启用跨源资源共享(CORS ),因为我们的前端和后端将在不同的端口上提供服务。为了快速简单地完成这个，我们将使用<a href="https://flask-cors.readthedocs.io/"> Flask-CORS </a> Python包。</p>
<blockquote>
<p>出于安全原因，现代web浏览器不允许客户端JavaScript访问来自不同于脚本来源的资源(如JSON数据),除非它们包含特定的响应头，让浏览器知道这是可以的。</p>
</blockquote>
<p>如果你还没有安装弗拉斯克-CORS，用皮普安装。</p>
<p>让我们从我们的Flask API开始。</p>
<p>首先，创建一个文件夹来保存项目代码。在里面，创建一个名为“api”的文件夹。在文件夹中创建一个<em> app.py </em>文件。用你喜欢的文本编辑器打开文件。这次我们需要从<code>flask</code>导入<code>Flask</code>，从<code>flask_cors</code>导入<code>CORS</code>。因为我们使用<code>flask_cors</code>来实现跨源资源共享，所以用<code>CORS</code> : <code>CORS(app)</code>包装app对象(不设置新变量)。这就是我们所要做的，使CORS在我们所有的路线上的任何来源。</p>
<blockquote>
<p>尽管这对于演示来说很好，但您可能不希望任何应用程序或网站都能访问您的API。在这种情况下，您可以使用kwarg‘origins’和CORS函数来添加一个可接受的原点列表，即<code>CORS(app, origins=["origin1", "origin2"])</code></p>
<p>关于跨源资源共享的更多信息，MDN上有一些很棒的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">文档</a>。</p>
</blockquote>
<p>最后，在<code>/greeting</code>创建一个问候路由，返回一个带有单个键/值的JSON对象:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="s2">"greeting"</span><span class="p">:</span> <span class="s2">"Hello from Flask!"</span><span class="p">}</span>
</code></pre></div>

<p>以下是您应该得到的结果:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">flask_cors</span> <span class="kn">import</span> <span class="n">CORS</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">CORS</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/greeting"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greeting</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"greeting"</span><span class="p">:</span> <span class="s2">"Hello from Flask!"</span><span class="p">}</span>
</code></pre></div>

<p>这就是我们需要用Python做的一切。</p>
<p>接下来，我们将设置我们的Vue webapp。从终端打开项目的根文件夹。使用Vue CLI创建一个名为“web app”(<code>vue create webapp</code>)的Vue项目。您几乎可以使用任何您喜欢的选项，但是如果您在TypeScript中使用基于类的组件，语法看起来会有点不同。</p>
<p>当你的项目创建完成后，打开<em> App.vue </em>。</p>
<p>因为我们的目标只是看看Vue和Flask如何相互交互，所以在页面顶部，删除id为<code>app</code>的<code>div</code>中的所有元素。你应该只剩下:</p>
<div class="codehilite"><pre><span/><code><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">"app"</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</code></pre></div>

<p>在<code>#app</code>中，创建两个<code>p</code>元素:</p>
<ol>
<li>第一条的内容应该是<code>{{ greeting }}</code>。</li>
<li>秒的内容应该是<code>{{ flaskGreeting }}</code>。</li>
</ol>
<p>你最终的HTML应该是这样的:</p>
<div class="codehilite"><pre><span/><code><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">"app"</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>{{ greeting }}<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>{{ flaskGreeting }}<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</code></pre></div>

<p>在我们的<code>script</code>中，让我们添加逻辑来显示一个纯粹的客户端问候(<code>greeting</code>)和一个来自我们的API的问候(<code>flaskGreeting</code>)。</p>
<p>在Vue对象中(以<code>export default</code>开始)，创建一个<code>data</code>键。让它成为一个返回对象的函数。然后，在这个对象中，再创建两个键:<code>greeting</code>和<code>flaskGreeting</code>。<code>greeting</code>的值应该是<code>'Hello, Vue!'</code>，而<code>flaskGreeting</code>的值应该是空字符串。</p>
<p>以下是我们目前掌握的情况:</p>
<div class="codehilite"><pre><span/><code><span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s1">'App'</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nx">components</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="nx">HelloWorld</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="kd">function</span><span class="p">(){</span><span class="w"/>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">            </span><span class="nx">greeting</span><span class="o">:</span><span class="w"> </span><span class="s1">'Hello, Vue!'</span><span class="p">,</span><span class="w"/>
<span class="w">            </span><span class="nx">flaskGreeting</span><span class="o">:</span><span class="w"> </span><span class="s1">''</span><span class="w"/>
<span class="w">        </span><span class="p">}</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>最后，让我们给我们的Vue对象一个<code>created</code>生命周期钩子。只有当DOM被加载并且我们的Vue对象被创建时，这个钩子才会运行。这允许我们使用<code>fetch</code> API并与Vue交互，而没有任何冲突:</p>
<div class="codehilite"><pre><span/><code><span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nx">components</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="nx">Logo</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="kd">function</span><span class="p">(){</span><span class="w"/>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">            </span><span class="nx">greeting</span><span class="o">:</span><span class="w"> </span><span class="s1">'Hello, Vue!'</span><span class="p">,</span><span class="w"/>
<span class="w">            </span><span class="nx">flaskGreeting</span><span class="o">:</span><span class="w"> </span><span class="s1">''</span><span class="w"/>
<span class="w">        </span><span class="p">}</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nx">created</span><span class="o">:</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="p">(){</span><span class="w"/>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">gResponse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="s2">"http://localhost:5000/greeting"</span><span class="p">);</span><span class="w"/>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">gObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">gResponse</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span><span class="w"/>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">flaskGreeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gObject</span><span class="p">.</span><span class="nx">greeting</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>查看代码，我们正在对API的“问候”端点(<code>http://localhost:5000/greeting</code>)进行响应，对该响应的异步<code>.json()</code>响应进行<code>await</code>，并将Vue对象的<code>flaskGreeting</code>变量设置为返回的JSON对象的<code>greeting</code>键的值。</p>
<blockquote>
<p>对于那些不熟悉JavaScript相对较新的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch"> Fetch </a> API的人来说，它基本上是一个原生的AXIOS杀手(至少就客户端而言Node不支持它，但<a href="https://deno.land/"> Deno </a>会支持它)。此外，如果您喜欢一致性，您也可以查看<a href="https://www.npmjs.com/package/isomorphic-fetch">同构获取</a>包，以便在服务器端使用获取。</p>
</blockquote>
<p>我们结束了。因为我们的前端和后端是分开的，所以我们需要分别运行两个应用程序。</p>
<p>让我们在两个独立的终端窗口中打开项目的根文件夹。</p>
<p>首先，进入“api”目录，然后运行<code>flask run</code>。如果一切顺利，Flask API应该正在运行。在第二个终端中，切换到“webapp”目录并运行<code>npm run serve</code>。</p>
<p>一旦Vue应用启动，您应该能够从<code>localhost:8080</code>访问它。如果一切正常，您应该会收到两次问候——一次是Vue，另一次是Flask API:</p>
<div class="codehilite"><pre><span/><code>Hello, Vue!
Hello from Flask!
</code></pre></div>

<p>最终的文件树应该是这样的:</p>
<div class="codehilite"><pre><span/><code>├───app.py
├───api
│   └───app.py
└───webapp
    ... <span class="o">{{</span> Vue project <span class="o">}}</span>
</code></pre></div>

<h2 id="single-page-application-with-nuxt">使用Nuxt的单页应用程序</h2>
<p>如果SEO对您来说像UX一样重要，那么您可能希望以某种格式实现服务器端呈现(SSR)。</p>
<p>SSR使搜索引擎更容易导航和索引你的Vue应用，因为你将能够给他们一种不需要JavaScript生成的应用形式。它还可以让用户更快地与你的应用程序互动，因为你的大部分初始内容会在发送给他们之前呈现出来。换句话说，用户不必等待所有的内容都被异步加载。</p>
<blockquote>
<p>具有服务器端渲染的单页应用程序也称为通用应用程序。</p>
</blockquote>
<p>尽管可以手动实现SSR，但在本文中我们将使用<a href="https://nuxtjs.org/"> Nuxt </a>;它大大简化了事情。</p>
<p>就像使用<a href="#single-page-application"> SPA </a>方法一样，你的前端和后端将完全分离；你将只是使用Nuxt而不是Vue CLI。</p>
<h3 id="pros_2">赞成的意见</h3>
<ul>
<li>除了服务器端渲染之外，<a href="#single-page-application"> SPA </a>方法的所有优点。</li>
</ul>
<h3 id="cons_2">骗局</h3>
<ul>
<li>与<a href="#single-page-application"> SPA </a>方法一样难以设置。</li>
<li>从概念上讲，还有更多东西需要学习，因为Nuxt本质上只是Vue之上的另一层。</li>
</ul>
<h3 id="best-for_2">最适合</h3>
<ul>
<li>SEO和UX一样重要的应用。</li>
</ul>
<h3 id="additional-dependencies_2">其他依赖项</h3>
<ol>
<li>节点/国家预防机制</li>
<li>Nuxt</li>
<li>弗拉斯克-CORS</li>
</ol>
<h3 id="setup_2">设置</h3>
<p>这将非常类似于<a href="#single-page-application"> SPA </a>方法。事实上，烧瓶部分是完全相同的。继续这样做，直到创建了Flask API。</p>
<p>一旦您的API完成，在您的终端中，打开您的项目的根文件夹并运行命令<code>npx create-nuxt-app webapp</code>。这将让您以交互方式生成一个新的Nuxt项目，而无需安装任何全局依赖项。</p>
<p>这里任何选项都可以。</p>
<p>一旦你的项目生成完成，进入你的新“webapp”文件夹。在“pages”文件夹中，在文本编辑器中打开<em> index.vue </em>。类似地，删除<code>div</code>中包含类<code>container</code>的所有内容。在<code>div</code>内部，创建两个变量相同的<code>p</code>标签:<code>{{ greeting }}</code>和<code>{{ flaskGreeting }}</code>。</p>
<p>它应该是这样的:</p>
<div class="codehilite"><pre><span/><code><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">"container"</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>{{ greeting }}<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>{{ flaskGreeting }}<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</code></pre></div>

<p>现在是我们的剧本:</p>
<ul>
<li>添加一个<code>data</code>键，返回一个带有变量<code>greeting</code>和<code>flaskGreeting</code>的对象</li>
<li>添加一个<code>created</code>生命周期挂钩:<ul>
<li><code>await</code> <code>fetch</code>从我们的API获取JSON问候(在端口5000上，除非您更改了它)</li>
<li><code>await</code><code>json()</code>方法从API的响应中异步获取JSON数据</li>
<li>将Vue实例的<code>flaskGreeting</code>设置为响应的JSON对象中的<code>greeting</code>键</li>
</ul>
</li>
</ul>
<p>Vue对象应该类似于:</p>
<div class="codehilite"><pre><span/><code><span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nx">components</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="nx">Logo</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="kd">function</span><span class="p">(){</span><span class="w"/>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">            </span><span class="nx">greeting</span><span class="o">:</span><span class="w"> </span><span class="s1">'Hello, Vue!'</span><span class="p">,</span><span class="w"/>
<span class="w">            </span><span class="nx">flaskGreeting</span><span class="o">:</span><span class="w"> </span><span class="s1">''</span><span class="w"/>
<span class="w">        </span><span class="p">}</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nx">created</span><span class="o">:</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="p">(){</span><span class="w"/>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">gResponse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="s2">"http://localhost:5000/greeting"</span><span class="p">);</span><span class="w"/>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">gObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">gResponse</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span><span class="w"/>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">flaskGreeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gObject</span><span class="p">.</span><span class="nx">greeting</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>运行Nuxt/Vue应用程序和Flask API看起来也非常类似于<a href="#single-page-application"> SPA </a>方法。</p>
<p>打开两个终端窗口。在第一个内，切换到“api”并运行<code>flask run</code>命令。在第二秒钟内，切换到“webapp”并运行<code>npm run dev</code>,为您的Nuxt项目启动一个开发服务器。</p>
<p>Nuxt应用程序启动后，您应该能够从<code>localhost:3000</code>访问它:</p>
<div class="codehilite"><pre><span/><code>Hello, Vue!
Hello from Flask!
</code></pre></div>

<blockquote>
<p>在生产环境中，您可以运行<code>npm run build</code>然后运行<code>npm run start</code>来启动生产服务器。</p>
</blockquote>
<p>我们最后的圣诞树:</p>
<div class="codehilite"><pre><span/><code>├───app.py
├───api
│   └───app.py
└───webapp
    ... <span class="o">{{</span> Nuxt project <span class="o">}}</span>
</code></pre></div>

<h3 id="bonus-vue-vs-nuxt-seo-comparison">奖金:Vue与Nuxt搜索引擎优化比较</h3>
<p>我在本文前面提到了SEO的好处，但是为了向您展示我的意思，我按原样运行了两个web应用程序，并获得了两个应用程序的SEO分数。</p>
<p>两个应用程序都没有改变，下面是我们得到的结果:</p>
<p><img data-src="/static/images/blog/flask/combine-flask-vue/seo_comparison_vue_nuxt.png" loading="lazy" class="lazyload" alt="Lighthouse SEO Scores for our Vue and Nuxt App" src="../Images/a62984beab0b21837b1b1476f0992f9c.png" data-original-src="https://testdriven.io/static/images/blog/flask/combine-flask-vue/seo_comparison_vue_nuxt.png"/></p>
<p>同样，你可以做一些事情来提高你的纯Vue SEO分数。Chrome的开发工具中的Lighthouse提到了添加一个元描述，但在没有额外干预的情况下，Nuxt给了我们一个完美的SEO分数。</p>
<p>此外，您实际上可以看到Nuxt的SSR和vanilla Vue的完全异步方法之间的区别。如果你同时运行这两个应用程序，导航到它们各自的原点，<code>localhost:8080</code>和<code>localhost:3000</code>，Vue应用程序的初始问候会在你得到响应后几毫秒发生，而Nuxt的初始问候已经呈现。</p>
<p>有关Nuxt和Vue之间的差异的更多信息，您可以查看以下文章:</p>
<ol>
<li><a href="https://www.bornfight.com/blog/nuxt-js-over-vue-js-when-should-you-use-it-and-why/"> Nuxt.js over Vue.js:什么时候应该使用它，为什么</a></li>
<li><a href="https://blog.logrocket.com/how-nuxt-js-solves-the-seo-problems-in-vue-js/">nuxt . js如何解决Vue.js中的SEO问题</a>。</li>
</ol>
<h2 id="flask-blueprint">烧瓶蓝图</h2>
<p>也许你已经开发了一个小Flask应用程序，你想开发一个Vue应用程序，更多的是作为一种手段，而不是作为主要事件。</p>
<p>示例:</p>
<ol>
<li>向你的雇主或客户演示功能的原型(你可以随时替换它，或者以后把它交给前端开发人员)。</li>
<li>您只是不想处理部署完全分离的前端和后端时可能导致的潜在挫折。</li>
</ol>
<p>在这种情况下，你可以通过保留你的Flask应用程序，但在它自己的Flask蓝图内构建Vue前端来折中。</p>
<p>这看起来很像<a href="#jinja-template"> Jinja模板</a>方法，但是代码会更有条理。</p>
<h3 id="pros_3">赞成的意见</h3>
<ul>
<li>如果没有必要，就不需要构建复杂的前端。</li>
<li>类似于<a href="#jinja-template"> Jinja模板</a>方法，增加了更好的代码组织的好处。</li>
<li>以后，您可以随时根据需要扩展前端和后端。</li>
</ul>
<h3 id="cons_3">骗局</h3>
<ul>
<li>可能需要变通办法来实现完整的SPA。</li>
<li>从一个单独的前端(比如一个移动应用)访问API可能会稍微麻烦一些，因为前端和后端并不是完全分开的。</li>
</ul>
<h3 id="best-for_3">最适合</h3>
<ul>
<li>功能比UI更重要的项目。</li>
<li>你正在一个已经存在的Flask应用上构建一个前端。</li>
<li>仅由几个HTML页面组成的小型web应用程序。</li>
</ul>
<h3 id="additional-dependencies_3">其他依赖项</h3>
<p>类似于<a href="#jinja-template"> Jinja模板</a>方法，我们将使用CDN来拉入Vue库:</p>
<div class="codehilite"><pre><span/><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>

<h3 id="setup_3">设置</h3>
<p>像其他方法一样，创建一个新文件夹来存放您的代码。在其中，创建两个文件夹:“api”和“client”。直观地说，这些将分别包含我们的API和客户端(Vue)的蓝图。</p>
<p>让我们深入“api”文件夹。</p>
<p>创建一个名为<em> api.py </em>的文件。这将包含与我们的API相关的所有代码。此外，因为我们将把这个文件/文件夹作为一个模块来访问，所以创建一个<em> __init__。py </em>文件:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span>

<span class="n">api_bp</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s1">'api_bp'</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">)</span> <span class="c1"># "API Blueprint"</span>

<span class="nd">@api_bp</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/greeting"</span><span class="p">)</span> <span class="c1"># Blueprints don't use the Flask "app" context. They use their own blueprint's</span>
<span class="k">def</span> <span class="nf">greeting</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">'greeting'</span><span class="p">:</span> <span class="s1">'Hello from Flask!'</span><span class="p">}</span>
</code></pre></div>

<p><code>Blueprint</code>的第一个参数是Flask的路由系统。第二个，<code>__name__</code>，相当于Flask app的第一个参数(<code>Flask(__name__)</code>)。</p>
<p>这就是我们的API蓝图。</p>
<p>好吧。让我们深入到之前创建的“client”文件夹。这个比我们的API蓝图稍微复杂一点，但是不会比普通的Flask应用程序复杂。</p>
<p>同样，像一个普通的Flask应用程序一样，在这个文件夹中，创建一个“静态”文件夹和一个“模板”文件夹。创建一个名为<em> client.py </em>的文件，并在文本编辑器中打开它。</p>
<p>这一次，我们将向我们的<code>Blueprint</code>传递更多的参数，这样它就知道在哪里可以找到正确的静态文件和模板:</p>
<div class="codehilite"><pre><span/><code><span class="n">client_bp</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s1">'client_bp'</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">,</span> <span class="c1"># 'Client Blueprint'</span>
    <span class="n">template_folder</span><span class="o">=</span><span class="s1">'templates'</span><span class="p">,</span> <span class="c1"># Required for our purposes</span>
    <span class="n">static_folder</span><span class="o">=</span><span class="s1">'static'</span><span class="p">,</span> <span class="c1"># Again, this is required</span>
    <span class="n">static_url_path</span><span class="o">=</span><span class="s1">'/client/static'</span> <span class="c1"># Flask will be confused if you don't do this</span>
<span class="p">)</span>
</code></pre></div>

<p>添加路线并提供<em>index.html</em>模板:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Blueprint</span><span class="p">,</span> <span class="n">render_template</span>

<span class="n">client_bp</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s2">"client_bp"</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">,</span> <span class="c1"># 'Client Blueprint'</span>
    <span class="n">template_folder</span><span class="o">=</span><span class="s2">"templates"</span><span class="p">,</span> <span class="c1"># Required for our purposes</span>
    <span class="n">static_folder</span><span class="o">=</span><span class="s2">"static"</span><span class="p">,</span> <span class="c1"># Again, this is required</span>
    <span class="n">static_url_path</span><span class="o">=</span><span class="s2">"/client/static"</span> <span class="c1"># Flask will be confused if you don't do this</span>
<span class="p">)</span>

<span class="nd">@client_bp</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s2">"index.html"</span><span class="p">)</span>
</code></pre></div>

<p>非常好。我们的客户端蓝图现在已经完成。退出文件，转到蓝图的“模板”文件夹。创建一个<em>index.html</em>文件:</p>
<div class="codehilite"><pre><span/><code><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="cm">&lt;!-- The id 'vm' is just for consistency - it can be anything you want --&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">"vm"</span> <span class="na">class</span><span class="o">=</span><span class="s">"container"</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>[[ greeting ]]<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>[[ flaskGreeting ]]<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">"https://cdn.jsdelivr.net/npm/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6b1d1e0e2b59455d455a5a">[email protected]</a>"</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">"{{ url_for('client_bp.static', filename='index.js') }}"</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</code></pre></div>

<blockquote>
<p>你有没有注意到我们用括号代替了大括号？这是因为我们需要更改分隔符，以防止Flask先捕获它们。</p>
</blockquote>
<p>一旦准备好，<code>greeting</code>将由Vue呈现，而<code>flaskGreeting</code>将从我们异步请求的Flask响应中获取。</p>
<p>完成了。向“静态”文件夹添加一个名为<em> index.js </em>的新文件。创建一个名为<code>apiEndpoint</code>的变量，并将其设置为<code>api_v1</code>。如果我们以后决定改变我们的终点，这只会使一切变得更加枯燥:</p>
<div class="codehilite"><pre><span/><code><span class="kd">const</span><span class="w"> </span><span class="nx">apiEndpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'/api_v1/'</span><span class="p">;</span><span class="w"/>
</code></pre></div>

<blockquote>
<p>我们还没有为我们的端点创建逻辑。那将在最后一步到来。</p>
</blockquote>
<p>接下来，首先让Vue上下文看起来与<a href="#jinja-template"> Jinja模板</a>方法中的上下文相同:</p>
<div class="codehilite"><pre><span/><code><span class="kd">const</span><span class="w"> </span><span class="nx">apiEndpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'/api_v1/'</span><span class="p">;</span><span class="w"/>

<span class="kd">const</span><span class="w"> </span><span class="nx">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Vue</span><span class="p">({</span><span class="w"> </span><span class="c1">// Again, vm is our Vue instance's name for consistency.</span><span class="w"/>
<span class="w">    </span><span class="nx">el</span><span class="o">:</span><span class="w"> </span><span class="s1">'#vm'</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nx">delimiters</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s1">'[['</span><span class="p">,</span><span class="w"> </span><span class="s1">']]'</span><span class="p">],</span><span class="w"/>
<span class="w">    </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="nx">greeting</span><span class="o">:</span><span class="w"> </span><span class="s1">'Hello, Vue!'</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="p">})</span><span class="w"/>
</code></pre></div>

<p>同样，我们创建了Vue上下文，将实例的<code>el</code>设置为<code>'#vm'</code>，将默认分隔符从<code>'{{', '}}'</code>更改为<code>'[[', ']]'</code>，并添加了一个键/值为<code>greeting</code>的数据元素:<code>'Hello, Vue!'</code>。</p>
<p>因为我们还将从API中提取一个问候语，所以创建一个名为<code>flaskGreeting</code>的数据占位符，其值为一个空字符串:</p>
<div class="codehilite"><pre><span/><code><span class="kd">const</span><span class="w"> </span><span class="nx">apiEndpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'/api_v1/'</span><span class="p">;</span><span class="w"/>

<span class="kd">const</span><span class="w"> </span><span class="nx">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Vue</span><span class="p">({</span><span class="w"/>
<span class="w">    </span><span class="nx">el</span><span class="o">:</span><span class="w"> </span><span class="s1">'#vm'</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nx">delimiters</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s1">'[['</span><span class="p">,</span><span class="w"> </span><span class="s1">']]'</span><span class="p">],</span><span class="w"/>
<span class="w">    </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="nx">greeting</span><span class="o">:</span><span class="w"> </span><span class="s1">'Hello, Vue!'</span><span class="p">,</span><span class="w"/>
<span class="w">        </span><span class="nx">flaskGreeting</span><span class="o">:</span><span class="w"> </span><span class="s1">''</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="p">})</span><span class="w"/>
</code></pre></div>

<p>让我们给我们的Vue对象一个异步的<code>created</code>生命周期钩子:</p>
<div class="codehilite"><pre><span/><code><span class="kd">const</span><span class="w"> </span><span class="nx">apiEndpoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'/api_v1/'</span><span class="p">;</span><span class="w"/>

<span class="kd">const</span><span class="w"> </span><span class="nx">vm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Vue</span><span class="p">({</span><span class="w"/>
<span class="w">    </span><span class="nx">el</span><span class="o">:</span><span class="w"> </span><span class="s1">'#vm'</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nx">delimiters</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s1">'[['</span><span class="p">,</span><span class="w"> </span><span class="s1">']]'</span><span class="p">],</span><span class="w"/>
<span class="w">    </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="nx">greeting</span><span class="o">:</span><span class="w"> </span><span class="s1">'Hello, Vue!'</span><span class="p">,</span><span class="w"/>
<span class="w">        </span><span class="nx">flaskGreeting</span><span class="o">:</span><span class="w"> </span><span class="s1">''</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nx">created</span><span class="o">:</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="p">(){</span><span class="w"/>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">gResponse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">apiEndpoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'greeting'</span><span class="p">);</span><span class="w"/>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">gObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">gResponse</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span><span class="w"/>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">flaskGreeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">gObject</span><span class="p">.</span><span class="nx">greeting</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="p">})</span><span class="w"/>
</code></pre></div>

<p>看看代码，我们从API的“问候”端点(<code>/api_v1/greeting</code>)得到一个响应，<code>await</code>得到该响应的异步<code>.json()</code>响应，并将Vue对象的<code>flaskGreeting</code>变量设置为返回的JSON对象的<code>greeting</code>键的值。它基本上是方法1和方法2的Vue对象之间的混搭。</p>
<p>非常好。只剩下一件事要做:让我们通过添加一个<em> app.py </em>到项目根来把所有的东西放在一起。在文件中，将<code>flask</code>与蓝图一起导入:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">api.api</span> <span class="kn">import</span> <span class="n">api_bp</span>
<span class="kn">from</span> <span class="nn">client.client</span> <span class="kn">import</span> <span class="n">client_bp</span>
</code></pre></div>

<p>像平常一样创建一个Flask应用程序，并使用<code>app.register_blueprint()</code>注册蓝图:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">api.api</span> <span class="kn">import</span> <span class="n">api_bp</span>
<span class="kn">from</span> <span class="nn">client.client</span> <span class="kn">import</span> <span class="n">client_bp</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">api_bp</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s1">'/api_v1'</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">client_bp</span><span class="p">)</span>
</code></pre></div>

<p>最终文件树:</p>
<div class="codehilite"><pre><span/><code>├───app.py
├───api
│   └───__init__.py
│   └───api.py
└───client
    ├───__init__.py
    ├───static
    │   └───index.js
    └───templates
        └───index.html
</code></pre></div>

<p>就是这样！如果你用<code>flask run</code>运行你的新应用，你应该会收到两次问候——一次是Vue本身，另一次是Flask API的响应。</p>
<h2 id="summary">摘要</h2>
<p>使用Vue和Flask构建web应用程序有许多不同的方式。这完全取决于你手头的情况。</p>
<p>要问的一些问题:</p>
<ol>
<li>SEO有多重要？</li>
<li>你的开发团队是什么样的？如果您没有开发运维团队，您是否希望承担额外的复杂性，分别部署前端和后端？</li>
<li>你只是快速成型吗？</li>
</ol>
<p>希望这篇文章能引导你走向正确的方向，让你知道如何组合Vue和Flask应用程序。</p>
<p>你可以从GitHub上的<a href="https://github.com/based-jace/combining-flask-with-vue">combining-flask-with-vue</a>repo中获取最终代码。</p>
  </div>

  </div>    
</body>
</html>