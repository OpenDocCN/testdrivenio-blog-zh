<html>
<head>
<title>Securing FastAPI with JWT Token-based Authentication </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过基于JWT令牌的身份验证保护FastAPI</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/fastapi-jwt-auth/#0001-01-01">https://testdriven.io/blog/fastapi-jwt-auth/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>在本教程中，您将了解如何通过使用JSON Web令牌(jwt)启用身份验证来保护<a href="https://fastapi.tiangolo.com/"> FastAPI </a>应用程序。我们将使用<a href="https://pyjwt.readthedocs.io/"> PyJWT </a>对JWT令牌进行签名、编码和解码。</p>



<h2 id="authentication-in-fastapi">FastAPI中的身份验证</h2>
<p>身份验证是在授予用户访问安全资源的权限之前对用户进行验证的过程。当用户被认证时，用户被允许访问不对公众开放的安全资源。</p>
<p>我们将研究如何使用<a href="https://swagger.io/docs/specification/authentication/bearer-authentication/">不记名</a>(或基于令牌)认证来认证FastAPI应用程序，这涉及到生成称为不记名令牌的安全令牌。在这种情况下，承载令牌将是jwt。</p>
<blockquote>
<p><a href="https://fastapi.tiangolo.com/tutorial/security/">FastAPI</a>中的认证也可以由OAuth处理。</p>
</blockquote>
<h2 id="initial-setup">初始设置</h2>
<p>首先创建一个新文件夹来保存名为“fastapi-jwt”的项目:</p>
<div class="codehilite"><pre><span/><code>$ mkdir fastapi-jwt <span class="o">&amp;&amp;</span> <span class="nb">cd</span> fastapi-jwt
</code></pre></div>

<p>接下来，创建并激活虚拟环境:</p>
<div class="codehilite"><pre><span/><code>$ python3.11 -m venv venv
$ <span class="nb">source</span> venv/bin/activate

<span class="o">(</span>venv<span class="o">)</span>$ <span class="nb">export</span> <span class="nv">PYTHONPATH</span><span class="o">=</span><span class="nv">$PWD</span>
</code></pre></div>

<blockquote>
<p>你可以随意把virtualenv和Pip换成诗歌<a href="https://python-poetry.org">或</a><a href="https://github.com/pypa/pipenv"> Pipenv </a>。更多信息，请查看<a href="/blog/python-environments/">现代Python环境</a>。</p>
</blockquote>
<p>安装FastAPI和<a href="https://www.uvicorn.org/">uvicon</a>:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install <span class="nv">fastapi</span><span class="o">==</span><span class="m">0</span>.89.1 <span class="nv">uvicorn</span><span class="o">==</span><span class="m">0</span>.20.0
</code></pre></div>

<p>接下来，创建以下文件和文件夹:</p>
<div class="codehilite"><pre><span/><code>fastapi-jwt
├── app
│   ├── __init__.py
│   ├── api.py
│   ├── auth
│   │   └── __init__.py
│   └── model.py
└── main.py
</code></pre></div>

<blockquote>
<p>以下命令将创建项目结构:</p><div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ mkdir app <span class="o">&amp;&amp;</span> <span class="se">\</span>
        mkdir app/auth <span class="o">&amp;&amp;</span> <span class="se">\</span>
        touch app/__init__.py app/api.py <span class="o">&amp;&amp;</span> <span class="se">\</span>
        touch app/auth/__init__.py app/model.py main.py
</code></pre></div>
</blockquote>

<p>在<em> main.py </em>文件中，定义运行应用程序的入口点:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># main.py</span>

<span class="kn">import</span> <span class="nn">uvicorn</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">uvicorn</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s2">"app.api:app"</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s2">"0.0.0.0"</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8081</span><span class="p">,</span> <span class="n">reload</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p>这里，我们指示文件在端口8081上运行Uvicorn服务器，并在每次文件更改时重新加载。</p>
<p>在通过入口点文件启动服务器之前，在<em> app/api.py </em>中创建一个基本路径:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"root"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_root</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"message"</span><span class="p">:</span> <span class="s2">"Welcome to your blog!"</span><span class="p">}</span>
</code></pre></div>

<p>从终端运行入口点文件:</p>


<p>在浏览器中导航至<a href="http://localhost:8081"> http://localhost:8081 </a>。您应该看到:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Welcome to your blog!"</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<h2 id="what-are-we-building">我们在建造什么？</h2>
<p>在本教程的剩余部分，您将构建一个安全的微型博客CRUD应用程序来创建和阅读博客文章。最后，您将拥有:</p>
<p><img data-src="/static/images/blog/fastapi/fastapi-jwt-auth/final_app.png" loading="lazy" class="lazyload" alt="final app" src="../Images/45b87573ad156c22370d2833e3d2fd15.png" data-original-src="https://testdriven.io/static/images/blog/fastapi/fastapi-jwt-auth/final_app.png"/></p>
<h2 id="models">模型</h2>
<p>在我们继续之前，让我们为帖子定义一个pydantic <a href="https://pydantic-docs.helpmanual.io/usage/models/">模型</a>。</p>
<p>在<em> model.py </em>中，添加:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/model.py</span>

<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span><span class="p">,</span> <span class="n">EmailStr</span>


<span class="k">class</span> <span class="nc">PostSchema</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Config</span><span class="p">:</span>
        <span class="n">schema_extra</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"example"</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"Securing FastAPI applications with JWT."</span><span class="p">,</span>
                <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"In this tutorial, you'll learn how to secure your application by enabling authentication using JWT. We'll be using PyJWT to sign, encode and decode JWT tokens...."</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>

<h2 id="routes">路线</h2>
<h3 id="get-route">获取路线</h3>
<p>首先导入<code>PostSchema</code>，然后在<em> app/api.py </em>中添加一个虚拟帖子列表和一个空用户列表变量:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="kn">from</span> <span class="nn">app.model</span> <span class="kn">import</span> <span class="n">PostSchema</span>

<span class="n">posts</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">"id"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"Pancake"</span><span class="p">,</span>
        <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"Lorem Ipsum ..."</span>
    <span class="p">}</span>
<span class="p">]</span>

<span class="n">users</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>

<p>然后，添加路由处理程序，通过ID获取所有帖子和单个帖子:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/posts"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"posts"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_posts</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{</span> <span class="s2">"data"</span><span class="p">:</span> <span class="n">posts</span> <span class="p">}</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/posts/</span><span class="si">{id}</span><span class="s2">"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"posts"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_single_post</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">id</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">posts</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">"error"</span><span class="p">:</span> <span class="s2">"No such post with the supplied ID."</span>
        <span class="p">}</span>

    <span class="k">for</span> <span class="n">post</span> <span class="ow">in</span> <span class="n">posts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">post</span><span class="p">[</span><span class="s2">"id"</span><span class="p">]</span> <span class="o">==</span> <span class="nb">id</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">"data"</span><span class="p">:</span> <span class="n">post</span>
            <span class="p">}</span>
</code></pre></div>

<p><em> app/api.py </em>现在应该是这样的:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>

<span class="kn">from</span> <span class="nn">app.model</span> <span class="kn">import</span> <span class="n">PostSchema</span>


<span class="n">posts</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">"id"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"Pancake"</span><span class="p">,</span>
        <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"Lorem Ipsum ..."</span>
    <span class="p">}</span>
<span class="p">]</span>

<span class="n">users</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"root"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_root</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"message"</span><span class="p">:</span> <span class="s2">"Welcome to your blog!"</span><span class="p">}</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/posts"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"posts"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_posts</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{</span> <span class="s2">"data"</span><span class="p">:</span> <span class="n">posts</span> <span class="p">}</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/posts/</span><span class="si">{id}</span><span class="s2">"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"posts"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_single_post</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">id</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">posts</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">"error"</span><span class="p">:</span> <span class="s2">"No such post with the supplied ID."</span>
        <span class="p">}</span>

    <span class="k">for</span> <span class="n">post</span> <span class="ow">in</span> <span class="n">posts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">post</span><span class="p">[</span><span class="s2">"id"</span><span class="p">]</span> <span class="o">==</span> <span class="nb">id</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">"data"</span><span class="p">:</span> <span class="n">post</span>
            <span class="p">}</span>
</code></pre></div>

<p>手动测试<a href="http://localhost:8081/posts">http://localhost:8081/posts</a>和<a href="http://localhost:8081/posts/1">http://localhost:8081/posts/1</a>的路由</p>
<h3 id="post-route">邮寄路线</h3>
<p>在GET routes的正下方，添加以下用于创建新帖子的处理程序:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/posts"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"posts"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">add_post</span><span class="p">(</span><span class="n">post</span><span class="p">:</span> <span class="n">PostSchema</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="n">post</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">posts</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">posts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">dict</span><span class="p">())</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">"data"</span><span class="p">:</span> <span class="s2">"post added."</span>
    <span class="p">}</span>
</code></pre></div>

<p>在后端运行的情况下，通过位于<a href="http://localhost:8081/docs">http://localhost:8081/docs</a>的交互文档测试POST路径。</p>
<p>您也可以使用curl进行测试:</p>
<div class="codehilite"><pre><span/><code>$ curl -X POST http://localhost:8081/posts <span class="se">\</span>
    -d  <span class="s1">'{ "id": 2, "title": "Lorem Ipsum tres", "content": "content goes here"}'</span> <span class="se">\</span>
    -H <span class="s1">'Content-Type: application/json'</span>
</code></pre></div>

<p>您应该看到:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="s2">"post added."</span><span class="w"/>
<span class="w">    </span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<h2 id="jwt-authentication">JWT认证</h2>
<p>在这一节中，我们将创建一个JWT令牌处理程序和一个处理无记名令牌的类。</p>
<p>开始之前，安装<a href="https://pyjwt.readthedocs.io/"> PyJWT </a>，用于编码和解码JWT。我们还将使用和<a href="https://github.com/henriquebastos/python-decouple/"> python解耦</a>来读取环境变量:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install <span class="nv">PyJWT</span><span class="o">==</span><span class="m">2</span>.6.0 python-decouple<span class="o">==</span><span class="m">3</span>.7
</code></pre></div>

<h3 id="jwt-handler">JWT·汉德勒</h3>
<p>JWT处理程序将负责签名、编码、解码和返回JWT令牌。在“auth”文件夹中，创建一个名为<em> auth_handler.py </em>的文件:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/auth/auth_handler.py</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>

<span class="kn">import</span> <span class="nn">jwt</span>
<span class="kn">from</span> <span class="nn">decouple</span> <span class="kn">import</span> <span class="n">config</span>


<span class="n">JWT_SECRET</span> <span class="o">=</span> <span class="n">config</span><span class="p">(</span><span class="s2">"secret"</span><span class="p">)</span>
<span class="n">JWT_ALGORITHM</span> <span class="o">=</span> <span class="n">config</span><span class="p">(</span><span class="s2">"algorithm"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">token_response</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">"access_token"</span><span class="p">:</span> <span class="n">token</span>
    <span class="p">}</span>
</code></pre></div>

<p>在上面的代码块中，我们导入了<code>time</code>、<code>typing</code>、<code>jwt</code>和<code>decouple</code>模块。<code>time</code>模块负责设置令牌的到期时间。每个JWT都有失效日期和/或失效时间。<code>jwt</code>模块负责对生成的令牌串进行编码和解码。最后，<code>token_response</code>函数是一个助手函数，用于返回生成的令牌。</p>
<blockquote>
<p>JSON Web令牌被编码成来自<a href="https://jwt.io/introduction">字典负载</a>的字符串。</p>
</blockquote>
<h3 id="jwt-secret-and-algorithm">JWT秘密和算法</h3>
<p>接下来，创建一个名为<em>的环境文件。基本目录中的env </em>:</p>
<div class="codehilite"><pre><span/><code>secret=please_please_update_me_please
algorithm=HS256
</code></pre></div>

<p>环境文件中的秘密应该替换为更强的内容，并且不应该被泄露。例如:</p>
<div class="codehilite"><pre><span/><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">binascii</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">binascii</span><span class="o">.</span><span class="n">hexlify</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">24</span><span class="p">))</span>
<span class="sa">b</span><span class="s1">'deff1952d59f883ece260e8683fed21ab0ad9a53323eca4f'</span>
</code></pre></div>

<p>秘密密钥用于编码和解码JWT字符串。</p>
<p>另一方面，算法值是编码过程中使用的算法类型。</p>
<h3 id="sign-and-decode-jwt">签署和解码JWT</h3>
<p>回到<em> auth_handler.py </em>，添加JWT字符串签名函数:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/auth/auth_handler.py</span>

<span class="k">def</span> <span class="nf">signJWT</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"user_id"</span><span class="p">:</span> <span class="n">user_id</span><span class="p">,</span>
        <span class="s2">"expires"</span><span class="p">:</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mi">600</span>
    <span class="p">}</span>
    <span class="n">token</span> <span class="o">=</span> <span class="n">jwt</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">JWT_SECRET</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">JWT_ALGORITHM</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">token_response</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</code></pre></div>

<p>在<code>signJWT</code>函数中，我们定义了有效载荷、一个包含传递给函数的<code>user_id</code>的字典，以及一个从生成之时起十分钟的到期时间。接下来，我们创建了一个由有效负载、秘密和算法类型组成的令牌字符串，然后返回它。</p>
<p>接下来，添加<code>decodeJWT</code>功能:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/auth/auth_handler.py</span>

<span class="k">def</span> <span class="nf">decodeJWT</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">decoded_token</span> <span class="o">=</span> <span class="n">jwt</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">JWT_SECRET</span><span class="p">,</span> <span class="n">algorithms</span><span class="o">=</span><span class="p">[</span><span class="n">JWT_ALGORITHM</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">decoded_token</span> <span class="k">if</span> <span class="n">decoded_token</span><span class="p">[</span><span class="s2">"expires"</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
</code></pre></div>

<p><code>decodeJWT</code>函数获取令牌并在<code>jwt</code>模块的帮助下对其进行解码，然后将其存储在<code>decoded_token</code>变量中。接下来，如果到期时间有效，我们返回<code>decoded_token</code>，否则，我们返回<code>None</code>。</p>
<blockquote>
<p>JWT没有加密。它是基于64位编码和签名的。因此任何人都可以解码令牌并使用其数据。但是只有服务器可以使用<code>JWT_SECRET</code>来验证它的真实性。</p>
</blockquote>
<h2 id="user-registration-and-login">用户注册和登录</h2>
<p>接下来，让我们为处理用户注册和登录连接路由、模式和助手。</p>
<p>在<em> model.py </em>中，添加用户模式:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/model.py</span>

<span class="k">class</span> <span class="nc">UserSchema</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">fullname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">email</span><span class="p">:</span> <span class="n">EmailStr</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">password</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Config</span><span class="p">:</span>
        <span class="n">schema_extra</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"example"</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">"fullname"</span><span class="p">:</span> <span class="s2">"Abdulazeez Abdulazeez Adeshina"</span><span class="p">,</span>
                <span class="s2">"email"</span><span class="p">:</span> <span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fa9b989e8f969b809f9f80ba82d4999597">[email protected]</a>"</span><span class="p">,</span>
                <span class="s2">"password"</span><span class="p">:</span> <span class="s2">"weakpassword"</span>
            <span class="p">}</span>
        <span class="p">}</span>

<span class="k">class</span> <span class="nc">UserLoginSchema</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">email</span><span class="p">:</span> <span class="n">EmailStr</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">password</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Config</span><span class="p">:</span>
        <span class="n">schema_extra</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"example"</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">"email"</span><span class="p">:</span> <span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e6878482938a879c83839ca69ec885898b">[email protected]</a>"</span><span class="p">,</span>
                <span class="s2">"password"</span><span class="p">:</span> <span class="s2">"weakpassword"</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>

<p>接下来，更新<em> app/api.py </em>中的导入:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span><span class="p">,</span> <span class="n">Body</span>

<span class="kn">from</span> <span class="nn">app.model</span> <span class="kn">import</span> <span class="n">PostSchema</span><span class="p">,</span> <span class="n">UserSchema</span><span class="p">,</span> <span class="n">UserLoginSchema</span>
<span class="kn">from</span> <span class="nn">app.auth.auth_handler</span> <span class="kn">import</span> <span class="n">signJWT</span>
</code></pre></div>

<p>添加用户注册路径:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/user/signup"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"user"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">create_user</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">UserSchema</span> <span class="o">=</span> <span class="n">Body</span><span class="p">(</span><span class="o">...</span><span class="p">)):</span>
    <span class="n">users</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="c1"># replace with db call, making sure to hash the password first</span>
    <span class="k">return</span> <span class="n">signJWT</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="p">)</span>
</code></pre></div>

<p>因为我们使用的是<a href="https://pydantic-docs.helpmanual.io/usage/types/#pydantic-types">电子邮件验证器</a>、<code>EmailStr</code>，安装<a href="https://github.com/JoshData/python-email-validator">电子邮件验证器</a>:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install <span class="s2">"pydantic[email]"</span>
</code></pre></div>

<p>运行服务器:</p>


<p>通过位于<a href="http://localhost:8081/docs">http://localhost:8081/docs</a>的交互文档对其进行测试。</p>
<p><img data-src="/static/images/blog/fastapi/fastapi-jwt-auth/signup.png" loading="lazy" class="lazyload" alt="sign user up" src="../Images/0fa76bc98a0219441ea7d41b5ebb634e.png" data-original-src="https://testdriven.io/static/images/blog/fastapi/fastapi-jwt-auth/signup.png"/></p>
<blockquote>
<p>在生产环境中，在将用户保存到数据库之前，确保使用<a href="https://github.com/pyca/bcrypt/"> bcrypt </a>或<a href="https://passlib.readthedocs.io/"> passlib </a>散列您的密码。</p>
</blockquote>
<p>接下来，定义一个助手函数来检查用户是否存在:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="k">def</span> <span class="nf">check_user</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">UserLoginSchema</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">users</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">email</span> <span class="ow">and</span> <span class="n">user</span><span class="o">.</span><span class="n">password</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">password</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>

<p>在使用用户的电子邮件创建JWT之前，上面的函数会检查用户是否存在。</p>
<p>接下来，定义登录路径:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/user/login"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"user"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">user_login</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">UserLoginSchema</span> <span class="o">=</span> <span class="n">Body</span><span class="p">(</span><span class="o">...</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">check_user</span><span class="p">(</span><span class="n">user</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">signJWT</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">"error"</span><span class="p">:</span> <span class="s2">"Wrong login details!"</span>
    <span class="p">}</span>
</code></pre></div>

<p>通过首先创建一个用户，然后登录来测试登录路径:</p>
<p><img data-src="/static/images/blog/fastapi/fastapi-jwt-auth/login.png" loading="lazy" class="lazyload" alt="log user in" src="../Images/7829ca02228934522be4421ba5ec5569.png" data-original-src="https://testdriven.io/static/images/blog/fastapi/fastapi-jwt-auth/login.png"/></p>
<blockquote>
<p>因为用户存储在内存中，所以每次应用程序重新加载以测试登录时，您都必须创建一个新用户。</p>
</blockquote>
<h2 id="securing-routes">保护路线</h2>
<p>身份验证就绪后，让我们来保护创建路由。</p>
<h3 id="jwt-bearer">JWT持票人</h3>
<p>现在我们需要通过检查请求是否被授权来验证受保护的路由。这是通过扫描<code>Authorization</code>报头中的JWT请求来完成的。FastAPI通过<code>HTTPBearer</code>类提供基本的验证。我们可以使用这个类来提取和解析令牌。然后，我们将使用<em> app/auth/auth_handler.py </em>中定义的<code>decodeJWT</code>函数来验证它。</p>
<p>在“auth”文件夹中创建一个名为<em> auth_bearer.py </em>的新文件:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/auth/auth_bearer.py</span>

<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">Request</span><span class="p">,</span> <span class="n">HTTPException</span>
<span class="kn">from</span> <span class="nn">fastapi.security</span> <span class="kn">import</span> <span class="n">HTTPBearer</span><span class="p">,</span> <span class="n">HTTPAuthorizationCredentials</span>

<span class="kn">from</span> <span class="nn">.auth_handler</span> <span class="kn">import</span> <span class="n">decodeJWT</span>


<span class="k">class</span> <span class="nc">JWTBearer</span><span class="p">(</span><span class="n">HTTPBearer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auto_error</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">JWTBearer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">auto_error</span><span class="o">=</span><span class="n">auto_error</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">:</span> <span class="n">Request</span><span class="p">):</span>
        <span class="n">credentials</span><span class="p">:</span> <span class="n">HTTPAuthorizationCredentials</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">super</span><span class="p">(</span><span class="n">JWTBearer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">credentials</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">credentials</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s2">"Bearer"</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HTTPException</span><span class="p">(</span><span class="n">status_code</span><span class="o">=</span><span class="mi">403</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="s2">"Invalid authentication scheme."</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_jwt</span><span class="p">(</span><span class="n">credentials</span><span class="o">.</span><span class="n">credentials</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">HTTPException</span><span class="p">(</span><span class="n">status_code</span><span class="o">=</span><span class="mi">403</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="s2">"Invalid token or expired token."</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">credentials</span><span class="o">.</span><span class="n">credentials</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">HTTPException</span><span class="p">(</span><span class="n">status_code</span><span class="o">=</span><span class="mi">403</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="s2">"Invalid authorization code."</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">verify_jwt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jwtoken</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">isTokenValid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="n">decodeJWT</span><span class="p">(</span><span class="n">jwtoken</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">payload</span><span class="p">:</span>
            <span class="n">isTokenValid</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">isTokenValid</span>
</code></pre></div>

<p>因此，<code>JWTBearer</code>类是FastAPI的<a href="https://github.com/tiangolo/fastapi/blob/0.89.1/fastapi/security/http.py#L100"> HTTPBearer </a>类的一个子类，它将用于在我们的路由上保持身份验证。</p>
<h4 id="init">初始化</h4>
<p>在<code>__init__</code>方法中，我们通过将布尔值<a href="https://github.com/tiangolo/fastapi/blob/0.89.1/fastapi/security/http.py#L107"> auto_error </a>设置为<code>True</code>来启用自动错误报告。</p>
<h4 id="call">打电话</h4>
<p>在<code>__call__</code>方法中，我们定义了一个名为<code>credentials</code>的变量，类型为<a href="https://github.com/tiangolo/fastapi/blob/0.89.1/fastapi/security/http.py#L20">HTTPAuthorizationCredentials</a>，它是在调用<code>JWTBearer</code>类时创建的。然后，我们继续检查在调用该类的过程中传递的凭证是否有效:</p>
<ol>
<li>如果凭据方案不是承载方案，我们会引发无效令牌方案的异常。</li>
<li>如果传递了不记名令牌，我们验证JWT是有效的。</li>
<li>如果没有收到凭证，我们会引发无效授权错误。</li>
</ol>
<h4 id="verify">核实</h4>
<p><code>verify_jwt</code>方法验证令牌是否有效。该方法获取一个<code>jwtoken</code>字符串，然后将其传递给<code>decodeJWT</code>函数，并基于<code>decodeJWT</code>的结果返回一个布尔值。</p>
<h3 id="dependency-injection">依赖注入</h3>
<p>为了保护路由，我们将通过FastAPI的<a href="https://fastapi.tiangolo.com/tutorial/dependencies/?h=+depends#import-depends"> Depends </a>来利用依赖注入。</p>
<p>首先通过添加<code>JWTBearer</code>类和<code>Depends</code>来更新导入:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span><span class="p">,</span> <span class="n">Body</span><span class="p">,</span> <span class="n">Depends</span>

<span class="kn">from</span> <span class="nn">app.model</span> <span class="kn">import</span> <span class="n">PostSchema</span><span class="p">,</span> <span class="n">UserSchema</span><span class="p">,</span> <span class="n">UserLoginSchema</span>
<span class="kn">from</span> <span class="nn">app.auth.auth_bearer</span> <span class="kn">import</span> <span class="n">JWTBearer</span>
<span class="kn">from</span> <span class="nn">app.auth.auth_handler</span> <span class="kn">import</span> <span class="n">signJWT</span>
</code></pre></div>

<p>在<code>add_post</code>路线中，将<code>dependencies</code>参数添加到<code>@app</code>属性中，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># app/api.py</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/posts"</span><span class="p">,</span> <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="n">Depends</span><span class="p">(</span><span class="n">JWTBearer</span><span class="p">())],</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"posts"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">add_post</span><span class="p">(</span><span class="n">post</span><span class="p">:</span> <span class="n">PostSchema</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="n">post</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">posts</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">posts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">dict</span><span class="p">())</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">"data"</span><span class="p">:</span> <span class="s2">"post added."</span>
    <span class="p">}</span>
</code></pre></div>

<p>刷新交互式文档页面:</p>
<p><img data-src="/static/images/blog/fastapi/fastapi-jwt-auth/swagger_ui.png" loading="lazy" class="lazyload" alt="swagger ui" src="../Images/64337ad8756e2aca556751b02c002af3.png" data-original-src="https://testdriven.io/static/images/blog/fastapi/fastapi-jwt-auth/swagger_ui.png"/></p>
<p>通过尝试在不传入令牌的情况下访问受保护的路由来测试身份验证:</p>
<p><img data-src="/static/images/blog/fastapi/fastapi-jwt-auth/post_unauthenticated.png" loading="lazy" class="lazyload" alt="add user unauthenticated" src="../Images/edfda7070dda17ff25b03320f8cbbd21.png" data-original-src="https://testdriven.io/static/images/blog/fastapi/fastapi-jwt-auth/post_unauthenticated.png"/></p>
<p>创建新用户并复制生成的访问令牌:</p>
<p><img data-src="/static/images/blog/fastapi/fastapi-jwt-auth/access_token.png" loading="lazy" class="lazyload" alt="access token" src="../Images/8243e6eabd50e84d9f806bc08eca6c5b.png" data-original-src="https://testdriven.io/static/images/blog/fastapi/fastapi-jwt-auth/access_token.png"/></p>
<p>复制后，单击右上角的授权按钮并粘贴令牌:</p>
<p><img data-src="/static/images/blog/fastapi/fastapi-jwt-auth/authorize.png" loading="lazy" class="lazyload" alt="authorize" src="../Images/70228fdfb30897b85fce82f9ec3ca5af.png" data-original-src="https://testdriven.io/static/images/blog/fastapi/fastapi-jwt-auth/authorize.png"/></p>
<p>现在，您应该能够使用受保护的路线了:</p>
<p><img data-src="/static/images/blog/fastapi/fastapi-jwt-auth/post_authenticated.png" loading="lazy" class="lazyload" alt="add user authenticated" src="../Images/faeeba672c2d9f2d5017d33f389b228f.png" data-original-src="https://testdriven.io/static/images/blog/fastapi/fastapi-jwt-auth/post_authenticated.png"/></p>
<h2 id="conclusion">结论</h2>
<p>本教程讲述了使用JSON Web令牌保护FastAPI应用程序的过程。您可以在<a href="https://github.com/testdrivenio/fastapi-jwt"> fastapi-jwt </a>存储库中找到源代码。感谢阅读。</p>
<p>寻找一些挑战？</p>
<ol>
<li>在使用<a href="https://github.com/pyca/bcrypt/"> bcrypt </a>或<a href="https://passlib.readthedocs.io/"> passlib </a>保存密码之前，对密码进行哈希处理。</li>
<li>将用户和帖子从临时存储转移到MongoDB或Postgres之类的数据库。您可以按照<a href="https://testdriven.io/blog/fastapi-mongo/">使用FastAPI和MongoDB </a>构建CRUD应用程序中的步骤来设置MongoDB数据库并部署到Heroku。</li>
<li>添加刷新令牌，以便在新jwt过期时自动颁发它们。不知道从哪里开始？看看《烧瓶》的作者JWT对此的解释。</li>
<li>添加更新和删除帖子的路线。</li>
</ol>
  </div>

  </div>    
</body>
</html>