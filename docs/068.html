<html>
<head>
<title>Modern Test-Driven Development in Python </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python中的现代测试驱动开发</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/modern-tdd/#0001-01-01">https://testdriven.io/blog/modern-tdd/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>测试产品级代码很难。有时候，在特性开发过程中，它会占用你几乎所有的时间。更重要的是，即使你有100%的覆盖率并且测试是绿色的，你仍然不能确信新的特性将在生产中正常工作。</p>
<p>本指南将带你通过使用<a href="/test-driven-development/">测试驱动开发</a> (TDD)来开发应用程序。我们将看看您应该如何测试以及测试什么。我们将使用<a href="https://docs.pytest.org/"> pytest </a>进行测试，使用<a href="https://pydantic-docs.helpmanual.io/"> pydantic </a>验证数据并减少所需的测试数量，使用<a href="https://flask.palletsprojects.com/"> Flask </a>通过RESTful API为我们的客户提供接口。最后，您将拥有一个可以用于任何Python项目的可靠模式，这样您就可以相信通过测试实际上意味着软件可以工作。</p>
<blockquote>
<p><a href="/guides/complete-python/">完整Python </a>指南:</p>
<ol>
<li><a href="/blog/python-environments/">现代Python环境——依赖性和工作空间管理</a></li>
<li><a href="/blog/testing-python/">Python中的测试</a></li>
<li><a href="/blog/modern-tdd/">Python中的现代测试驱动开发</a>(本文！)</li>
<li><a href="/blog/python-code-quality/"> Python代码质量</a></li>
<li><a href="/blog/python-type-checking/"> Python类型检查</a></li>
<li><a href="/blog/documenting-python/">记录Python代码和项目</a></li>
<li><a href="/blog/python-project-workflow/"> Python项目工作流程</a></li>
</ol>
</blockquote>



<h2 id="objectives">目标</h2>
<p>完成本文后，您将能够:</p>
<ol>
<li>解释你应该如何测试你的软件</li>
<li>配置pytest并为测试设置一个项目结构</li>
<li>用迂腐定义数据库模型</li>
<li>使用pytest fixtures来管理测试状态和执行副作用</li>
<li>根据JSON模式定义验证JSON响应</li>
<li>用命令(修改状态，有副作用)和查询(只读，无副作用)组织数据库操作</li>
<li>使用pytest编写单元、集成和端到端测试</li>
<li>解释为什么将测试工作集中在测试行为上而不是实现细节上很重要</li>
</ol>
<h2 id="how-should-i-test-my-software">我应该如何测试我的软件？</h2>
<p>软件开发人员往往对测试非常固执己见。正因为如此，他们对测试的重要性和如何进行测试有不同的看法。也就是说，让我们看看三条指导方针,(希望)大多数开发人员都会同意，它们将帮助您编写有价值的测试:</p>
<ol>
<li>
<p>测试应该告诉你被测单元的预期行为。因此，建议保持简短和切题。<a href="https://martinfowler.com/bliki/GivenWhenThen.html">给定，WHEN，THEN </a>结构可以对此有所帮助:</p>
<ul>
<li>假设-测试的初始条件是什么？</li>
<li>什么时候发生了什么需要测试？</li>
<li>那么，预期的反应是什么？</li>
</ul>
<p>因此，您应该为测试准备好环境，执行行为，并在最后检查输出是否符合预期。</p>
</li>
<li>
<p>每个行为都应该测试一次——而且只能测试一次。多次测试相同的行为并不意味着你的软件更有可能工作。测试也需要维护。如果你对你的代码库做了一个小的改变，然后二十个测试中断了，你怎么知道哪个功能中断了？当只有一个测试失败时，找到bug就容易多了。</p>
</li>
<li>
<p>每个测试必须独立于其他测试。否则，您将很难维护和运行测试套件。</p>
</li>
</ol>
<blockquote>
<p>这位导游也固执己见。不要把任何东西当成圣杯或银弹。欢迎在Twitter ( <a href="https://twitter.com/jangiacomelli"> @jangiacomelli </a>)上联系，讨论与本指南相关的任何事情。</p>
</blockquote>
<h2 id="basic-setup">基本设置</h2>
<p>就这样，让我们把手弄脏。您已经准备好了解所有这些在现实世界中意味着什么。pytest最简单的测试如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">another_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">test_another_sum</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">another_sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div>

<p>这个例子你可能已经见过至少一次了。首先，你永远不会在你的代码库中编写测试，所以让我们把它分成两个文件和包。</p>
<p>为此项目创建一个新目录，并移入其中:</p>
<div class="codehilite"><pre><span/><code>$ mkdir testing_project
$ <span class="nb">cd</span> testing_project
</code></pre></div>

<p>接下来，创建(并激活)一个虚拟环境。</p>
<blockquote>
<p>关于管理依赖关系和虚拟环境的更多信息，请查看<a href="/blog/python-environments/">现代Python环境</a>。</p>
</blockquote>
<p>第三，安装pytest:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install pytest
</code></pre></div>

<p>之后，创建一个名为“sum”的新文件夹。添加一个<em> __init__。py </em>到新文件夹，把它变成一个包，连同一个<em>的另一个_sum.py </em>文件:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">another_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div>

<p>添加另一个名为“tests”的文件夹，并添加以下文件和文件夹:</p>
<div class="codehilite"><pre><span/><code>└── tests
    ├── __init__.py
    └── test_sum
        ├── __init__.py
        └── test_another_sum.py
</code></pre></div>

<p>您现在应该已经:</p>
<div class="codehilite"><pre><span/><code>├── sum
│   ├── __init__.py
│   └── another_sum.py
└── tests
    ├── __init__.py
    └── test_sum
        ├── __init__.py
        └── test_another_sum.py
</code></pre></div>

<p>在<em> test_another_sum.py </em>中添加:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">sum.another_sum</span> <span class="kn">import</span> <span class="n">another_sum</span>


<span class="k">def</span> <span class="nf">test_another_sum</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">another_sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div>

<p>接下来，在“测试”文件夹中添加一个空的<em> conftest.py </em>文件，用于存储pytest <a href="https://docs.pytest.org/en/stable/fixture.html">夹具</a>。</p>
<p>最后，添加一个<em>pytest . ini</em>——一个py test配置文件——到“tests”文件夹，这个文件夹也可以是空的。</p>
<p>完整的项目结构现在应该看起来像这样:</p>
<div class="codehilite"><pre><span/><code>├── sum
│   ├── __init__.py
│   └── another_sum.py
└── tests
    ├── __init__.py
    ├── conftest.py
    ├── pytest.ini
    └── test_sum
        ├── __init__.py
        └── test_another_sum.py
</code></pre></div>

<p>将您的测试放在一个包中可以让您:</p>
<ol>
<li>在所有测试中重用pytest配置</li>
<li>在所有测试中重用夹具</li>
<li>简化测试的运行</li>
</ol>
<p>您可以使用以下命令运行所有测试:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>您应该会看到测试的结果，在本例中是针对<code>test_another_sum</code>:</p>
<div class="codehilite"><pre><span/><code><span class="o">==============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">==============================</span>
platform darwin -- Python <span class="m">3</span>.10.1, pytest-7.0.1, pluggy-1.0.0
rootdir: /testing_project/tests, configfile: pytest.ini
collected <span class="m">1</span> item

tests/test_sum.py/test_another_sum.py .                                 <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">===============================</span> <span class="m">1</span> passed <span class="k">in</span> <span class="m">0</span>.01s <span class="o">===============================</span>
</code></pre></div>

<h2 id="real-application">真实应用</h2>
<p>既然您已经对如何设置和构建测试有了基本的概念，让我们构建一个简单的博客应用程序。我们将使用TDD来构建它，以查看实际测试。我们将使用<a href="https://flask.palletsprojects.com/"> Flask </a>作为我们的web框架，为了专注于测试，我们将使用<a href="https://sqlite.org/"> SQLite </a>作为我们的数据库。</p>
<p>我们的应用程序将有以下要求:</p>
<ul>
<li>可以创建文章</li>
<li>文章可以拿来</li>
<li>文章可以列出来</li>
</ul>
<p>首先，让我们创建一个新项目:</p>
<div class="codehilite"><pre><span/><code>$ mkdir blog_app
$ <span class="nb">cd</span> blog_app
</code></pre></div>

<p>其次，创建(并激活)一个虚拟环境。</p>
<p>第三，安装pytest和<a href="https://pydantic-docs.helpmanual.io/"> pydantic </a>，一个数据解析和验证库:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install pytest <span class="o">&amp;&amp;</span> pip install <span class="s2">"pydantic[email]"</span>
</code></pre></div>

<blockquote>
<p><code>pip install "pydantic[email]"</code>安装pydantic和<a href="https://github.com/JoshData/python-email-validator">电子邮件验证器</a>，用于验证电子邮件地址。</p>
</blockquote>
<p>接下来，创建以下文件和文件夹:</p>
<div class="codehilite"><pre><span/><code>blog_app
    ├── blog
    │   ├── __init__.py
    │   ├── app.py
    │   └── models.py
    └── tests
        ├── __init__.py
        ├── conftest.py
        └── pytest.ini
</code></pre></div>

<p>将以下代码添加到<em> models.py </em>中，用pydantic定义一个新的<code>Article</code>模型:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">EmailStr</span><span class="p">,</span> <span class="n">Field</span>


<span class="k">class</span> <span class="nc">NotFound</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Article</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()))</span>
    <span class="n">author</span><span class="p">:</span> <span class="n">EmailStr</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_by_id</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">article_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">"DATABASE_NAME"</span><span class="p">,</span> <span class="s2">"database.db"</span><span class="p">))</span>
        <span class="n">con</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Row</span>

        <span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">"SELECT * FROM articles WHERE id=?"</span><span class="p">,</span> <span class="p">(</span><span class="n">article_id</span><span class="p">,))</span>

        <span class="n">record</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">record</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotFound</span>

        <span class="n">article</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">record</span><span class="p">)</span>  <span class="c1"># Row can be unpacked as dict</span>
        <span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">article</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_by_title</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">"DATABASE_NAME"</span><span class="p">,</span> <span class="s2">"database.db"</span><span class="p">))</span>
        <span class="n">con</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Row</span>

        <span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">"SELECT * FROM articles WHERE title = ?"</span><span class="p">,</span> <span class="p">(</span><span class="n">title</span><span class="p">,))</span>

        <span class="n">record</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">record</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotFound</span>

        <span class="n">article</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">record</span><span class="p">)</span>  <span class="c1"># Row can be unpacked as dict</span>
        <span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">article</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">"Article"</span><span class="p">]:</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">"DATABASE_NAME"</span><span class="p">,</span> <span class="s2">"database.db"</span><span class="p">))</span>
        <span class="n">con</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Row</span>

        <span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">"SELECT * FROM articles"</span><span class="p">)</span>

        <span class="n">records</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
        <span class="n">articles</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">record</span><span class="p">)</span> <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">]</span>
        <span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">articles</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"Article"</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">"DATABASE_NAME"</span><span class="p">,</span> <span class="s2">"database.db"</span><span class="p">))</span> <span class="k">as</span> <span class="n">con</span><span class="p">:</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
                <span class="s2">"INSERT INTO articles (id,author,title,content) VALUES(?, ?, ?, ?)"</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">author</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">con</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_table</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">database_name</span><span class="o">=</span><span class="s2">"database.db"</span><span class="p">):</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">database_name</span><span class="p">)</span>

        <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="s2">"CREATE TABLE IF NOT EXISTS articles (id TEXT, author TEXT, title TEXT, content TEXT)"</span>
        <span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>

<p>这是一个<a href="https://en.wikipedia.org/wiki/Active_record_pattern">活动记录</a>样式的模型，它提供了存储、获取单篇文章和列出所有文章的方法。</p>
<blockquote>
<p>您可能想知道为什么我们没有编写测试来覆盖这个模型。我们很快就会知道为什么。</p>
</blockquote>
<h3 id="create-a-new-article">创建新文章</h3>
<p>接下来，我们来看看我们的业务逻辑。我们将编写一些助手命令和查询来将我们的逻辑从模型和API中分离出来。因为我们使用pydantic，所以我们可以很容易地基于我们的模型验证数据。</p>
<p>在“tests”文件夹中创建一个“test_article”包。然后，向其中添加一个名为<em> test_commands.py </em>的文件。</p>
<div class="codehilite"><pre><span/><code>blog_app
    ├── blog
    │   ├── __init__.py
    │   ├── app.py
    │   └── models.py
    └── tests
        ├── __init__.py
        ├── conftest.py
        ├── pytest.ini
        └── test_article
            ├── __init__.py
            └── test_commands.py
</code></pre></div>

<p>将以下测试添加到<em> test_commands.py </em>中:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">pytest</span>

<span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Article</span>
<span class="kn">from</span> <span class="nn">blog.commands</span> <span class="kn">import</span> <span class="n">CreateArticleCommand</span><span class="p">,</span> <span class="n">AlreadyExists</span>


<span class="k">def</span> <span class="nf">test_create_article</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN CreateArticleCommand with valid author, title, and content properties</span>
<span class="sd">    WHEN the execute method is called</span>
<span class="sd">    THEN a new Article must exist in the database with the same attributes</span>
<span class="sd">    """</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="n">CreateArticleCommand</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="42282d2a2c02262d276c212d2f">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super awesome article"</span>
    <span class="p">)</span>

    <span class="n">article</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>

    <span class="n">db_article</span> <span class="o">=</span> <span class="n">Article</span><span class="o">.</span><span class="n">get_by_id</span><span class="p">(</span><span class="n">article</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">db_article</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">article</span><span class="o">.</span><span class="n">id</span>
    <span class="k">assert</span> <span class="n">db_article</span><span class="o">.</span><span class="n">author</span> <span class="o">==</span> <span class="n">article</span><span class="o">.</span><span class="n">author</span>
    <span class="k">assert</span> <span class="n">db_article</span><span class="o">.</span><span class="n">title</span> <span class="o">==</span> <span class="n">article</span><span class="o">.</span><span class="n">title</span>
    <span class="k">assert</span> <span class="n">db_article</span><span class="o">.</span><span class="n">content</span> <span class="o">==</span> <span class="n">article</span><span class="o">.</span><span class="n">content</span>


<span class="k">def</span> <span class="nf">test_create_article_already_exists</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN CreateArticleCommand with a title of some article in database</span>
<span class="sd">    WHEN the execute method is called</span>
<span class="sd">    THEN the AlreadyExists exception must be raised</span>
<span class="sd">    """</span>

    <span class="n">Article</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fb919a959ebb9f949ed5989496">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super extra awesome article"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

    <span class="n">cmd</span> <span class="o">=</span> <span class="n">CreateArticleCommand</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="553f3a3d3b15313a307b363a38">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super awesome article"</span>
    <span class="p">)</span>

    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="n">AlreadyExists</span><span class="p">):</span>
        <span class="n">cmd</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
</code></pre></div>

<p>这些测试涵盖以下业务用例:</p>
<ul>
<li>应该为有效数据创建文章</li>
<li>文章标题必须是唯一的</li>
</ul>
<p>从您的项目目录运行测试，查看它们是否失败:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>现在我们可以执行我们的命令了。</p>
<p>将一个<em> commands.py </em>文件添加到“博客”文件夹中:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">EmailStr</span>

<span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Article</span><span class="p">,</span> <span class="n">NotFound</span>


<span class="k">class</span> <span class="nc">AlreadyExists</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">CreateArticleCommand</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">author</span><span class="p">:</span> <span class="n">EmailStr</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Article</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">Article</span><span class="o">.</span><span class="n">get_by_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">AlreadyExists</span>
        <span class="k">except</span> <span class="n">NotFound</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">article</span> <span class="o">=</span> <span class="n">Article</span><span class="p">(</span>
            <span class="n">author</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">author</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
            <span class="n">content</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">content</span>
        <span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">article</span>
</code></pre></div>

<h2 id="test-fixtures">测试夹具</h2>
<p>我们可以使用<a href="https://docs.pytest.org/en/stable/fixture.html"> pytest fixtures </a>在每次测试后清空数据库，并在每次测试前创建一个新的。Fixtures是用<code>@pytest.fixture</code>装饰器装饰的函数。它们通常位于<em> conftest.py </em>中，但是也可以添加到实际的测试文件中。默认情况下，这些功能会在每次测试前执行。</p>
<p>一种选择是在测试中使用它们的返回值。例如:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">random_name</span><span class="p">():</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"John"</span><span class="p">,</span> <span class="s2">"Jane"</span><span class="p">,</span> <span class="s2">"Marry"</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_fixture_usage</span><span class="p">(</span><span class="n">random_name</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">random_name</span>
</code></pre></div>

<p>因此，要在测试中使用从fixture返回的值，您只需要将fixture函数的名称作为参数添加到测试函数中。</p>
<p>另一个选择是执行一个副作用，比如创建一个数据库或者模仿一个模块。</p>
<p>您也可以使用<code>yield</code>而不是<code>return</code>在测试前和测试后运行夹具的一部分。例如:</p>
<div class="codehilite"><pre><span/><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">some_fixture</span><span class="p">():</span>
    <span class="c1"># do something before your test</span>
    <span class="k">yield</span> <span class="c1"># test runs here</span>
    <span class="c1"># do something after your test</span>
</code></pre></div>

<p>现在，将下面的fixture添加到<em> conftest.py </em>中，这将在每次测试之前创建一个新的数据库，并在测试之后删除它:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="kn">import</span> <span class="nn">pytest</span>

<span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Article</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">database</span><span class="p">():</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">"DATABASE_NAME"</span><span class="p">]</span> <span class="o">=</span> <span class="n">file_name</span>
    <span class="n">Article</span><span class="o">.</span><span class="n">create_table</span><span class="p">(</span><span class="n">database_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
</code></pre></div>

<p>将<code>autouse</code>标志设置为<code>True</code>,以便在测试套件中的每个测试之前(和之后)默认自动使用。因为我们使用数据库进行<em>所有的</em>测试，所以使用这个标志是有意义的。这样，您就不必显式地将设备名称作为参数添加到每个测试中。</p>
<blockquote>
<p>如果您碰巧不需要访问数据库进行测试，您可以使用测试标记禁用<code>autouse</code>。你可以在这里看到这个<a href="https://stackoverflow.com/a/38763328/6555866">的例子。</a></p>
</blockquote>
<p>再次运行测试:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>他们应该通过。</p>
<p>如您所见，我们的测试只测试了<code>CreateArticleCommand</code>命令。我们不测试实际的<code>Article</code>模型，因为它不负责业务逻辑。我们知道该命令按预期工作。因此，没有必要编写任何额外的测试。</p>
<h3 id="list-all-articles">列出所有文章</h3>
<p>下一个要求是列出所有文章。我们在这里将使用查询而不是命令，因此将名为<em> test_queries.py </em>的新文件添加到“test_article”文件夹中:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Article</span>
<span class="kn">from</span> <span class="nn">blog.queries</span> <span class="kn">import</span> <span class="n">ListArticlesQuery</span>


<span class="k">def</span> <span class="nf">test_list_articles</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN 2 articles stored in the database</span>
<span class="sd">    WHEN the execute method is called</span>
<span class="sd">    THEN it should return 2 articles</span>
<span class="sd">    """</span>
    <span class="n">Article</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dab0bbb4bf9abeb5bff4b9b5b7">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super extra awesome article"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="n">Article</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="503a313e3510343f357e333f3d">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"Another Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super awesome article"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

    <span class="n">query</span> <span class="o">=</span> <span class="n">ListArticlesQuery</span><span class="p">()</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span>
</code></pre></div>

<p>运行测试:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>他们应该失败。</p>
<p>将一个<em> queries.py </em>文件添加到“博客”文件夹中:</p>
<div class="codehilite"><pre><span/><code>blog_app
    ├── blog
    │   ├── __init__.py
    │   ├── app.py
    │   ├── commands.py
    │   ├── models.py
    │   └── queries.py
    └── tests
        ├── __init__.py
        ├── conftest.py
        ├── pytest.ini
        └── test_article
            ├── __init__.py
            ├── test_commands.py
            └── test_queries.py
</code></pre></div>

<p>现在我们可以实现我们的查询了:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>

<span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Article</span>


<span class="k">class</span> <span class="nc">ListArticlesQuery</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Article</span><span class="p">]:</span>
        <span class="n">articles</span> <span class="o">=</span> <span class="n">Article</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">articles</span>
</code></pre></div>

<p>尽管这里没有参数，但为了一致性，我们继承了<code>BaseModel</code>。</p>
<p>再次运行测试:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>他们现在应该通过了。</p>
<h3 id="get-article-by-id">按ID获取文章</h3>
<p>通过ID获取一篇文章的方法与列出所有文章的方法类似。为<code>GetArticleByIDQuery</code>添加一个新的测试到<em> test_queries.py </em>。：</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Article</span>
<span class="kn">from</span> <span class="nn">blog.queries</span> <span class="kn">import</span> <span class="n">ListArticlesQuery</span><span class="p">,</span> <span class="n">GetArticleByIDQuery</span>


<span class="k">def</span> <span class="nf">test_list_articles</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN 2 articles stored in the database</span>
<span class="sd">    WHEN the execute method is called</span>
<span class="sd">    THEN it should return 2 articles</span>
<span class="sd">    """</span>
    <span class="n">Article</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0b616a656e4b6f646e25686466">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super extra awesome article"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="n">Article</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a4cec5cac1e4c0cbc18ac7cbc9">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"Another Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super awesome article"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

    <span class="n">query</span> <span class="o">=</span> <span class="n">ListArticlesQuery</span><span class="p">()</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">execute</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">test_get_article_by_id</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN ID of article stored in the database</span>
<span class="sd">    WHEN the execute method is called on GetArticleByIDQuery with an ID</span>
<span class="sd">    THEN it should return the article with the same ID</span>
<span class="sd">    """</span>
    <span class="n">article</span> <span class="o">=</span> <span class="n">Article</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="355f545b5075515a501b565a58">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super extra awesome article"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

    <span class="n">query</span> <span class="o">=</span> <span class="n">GetArticleByIDQuery</span><span class="p">(</span>
        <span class="nb">id</span><span class="o">=</span><span class="n">article</span><span class="o">.</span><span class="n">id</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">query</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">article</span><span class="o">.</span><span class="n">id</span>
</code></pre></div>

<p>运行测试以确保它们失败:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>接下来，将<code>GetArticleByIDQuery</code>添加到<em> queries.py </em>:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>

<span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Article</span>


<span class="k">class</span> <span class="nc">ListArticlesQuery</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Article</span><span class="p">]:</span>
        <span class="n">articles</span> <span class="o">=</span> <span class="n">Article</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">articles</span>


<span class="k">class</span> <span class="nc">GetArticleByIDQuery</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Article</span><span class="p">:</span>
        <span class="n">article</span> <span class="o">=</span> <span class="n">Article</span><span class="o">.</span><span class="n">get_by_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">article</span>
</code></pre></div>

<p>测试现在应该通过了:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>很好。我们已经满足了上述所有要求:</p>
<ul>
<li>可以创建文章</li>
<li>文章可以拿来</li>
<li>文章可以列出来</li>
</ul>
<p>它们都覆盖着测试。因为我们在运行时使用pydantic进行数据验证，所以我们不需要很多测试来涵盖业务逻辑，因为我们不需要编写验证数据的测试。如果<code>author</code>不是有效的电子邮件，pydantic将引发一个错误。所需要做的就是将<code>author</code>属性设置为<code>EmailStr</code>类型。我们也不需要测试它，因为pydantic的维护者已经在测试它了。</p>
<p>这样，我们就可以通过一个Flask RESTful API向外界公开这个功能了。</p>
<h2 id="expose-the-api-with-flask">用烧瓶暴露API</h2>
<p>我们将介绍满足这一要求的三个端点:</p>
<ol>
<li><code>/create-article/</code> -创建新文章</li>
<li><code>/article-list/</code> -检索所有文章</li>
<li><code>/article/&lt;article_id&gt;/</code> -取一件物品</li>
</ol>
<p>首先，在“test_article”中创建一个名为“schemas”的文件夹，并向其中添加两个JSON模式，<em> Article.json </em>和<em> ArticleList.json </em>。</p>
<p><em>文章. json </em>:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://json-schema.org/draft-07/schema#"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Article"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"object"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nt">"author"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nt">"title"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"/>
<span class="w">    </span><span class="p">},</span><span class="w"/>
<span class="w">    </span><span class="nt">"content"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">      </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>
<span class="w">  </span><span class="p">},</span><span class="w"/>
<span class="w">  </span><span class="nt">"required"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"id"</span><span class="p">,</span><span class="w"> </span><span class="s2">"author"</span><span class="p">,</span><span class="w"> </span><span class="s2">"title"</span><span class="p">,</span><span class="w"> </span><span class="s2">"content"</span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p><em> ArticleList.json </em>:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://json-schema.org/draft-07/schema#"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ArticleList"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"array"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"items"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">"$ref"</span><span class="p">:</span><span class="w">  </span><span class="s2">"file:Article.json"</span><span class="p">}</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p><a href="https://json-schema.org/"> JSON模式</a>用于定义来自API端点的响应。在继续之前，安装<a href="https://github.com/Julian/jsonschema"> jsonschema </a> Python库，它将用于根据定义的模式验证JSON有效负载，并安装Flask:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install jsonschema Flask
</code></pre></div>

<p>接下来，让我们为我们的API编写集成测试。</p>
<p>将名为<em> test_app.py </em>的新文件添加到“test_article”中:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">pathlib</span>

<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">jsonschema</span> <span class="kn">import</span> <span class="n">validate</span><span class="p">,</span> <span class="n">RefResolver</span>

<span class="kn">from</span> <span class="nn">blog.app</span> <span class="kn">import</span> <span class="n">app</span>
<span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Article</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">client</span><span class="p">():</span>
    <span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">"TESTING"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">client</span>


<span class="k">def</span> <span class="nf">validate_payload</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">schema_name</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Validate payload with selected schema</span>
<span class="sd">    """</span>
    <span class="n">schemas_dir</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="si">}</span><span class="s2">/schemas"</span>
    <span class="p">)</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">schemas_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">schema_name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span><span class="o">.</span><span class="n">read_text</span><span class="p">())</span>
    <span class="n">validate</span><span class="p">(</span>
        <span class="n">payload</span><span class="p">,</span>
        <span class="n">schema</span><span class="p">,</span>
        <span class="n">resolver</span><span class="o">=</span><span class="n">RefResolver</span><span class="p">(</span>
            <span class="s2">"file://"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">schemas_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">schema_name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span><span class="o">.</span><span class="n">absolute</span><span class="p">()),</span>
            <span class="n">schema</span>  <span class="c1"># it's used to resolve the file inside schemas correctly</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">test_create_article</span><span class="p">(</span><span class="n">client</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN request data for new article</span>
<span class="sd">    WHEN endpoint /create-article/ is called</span>
<span class="sd">    THEN it should return Article in json format that matches the schema</span>
<span class="sd">    """</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">'author'</span><span class="p">:</span> <span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a8c2c7c0c6e8ccc7cd86cbc7c5">[email protected]</a>"</span><span class="p">,</span>
        <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"New Article"</span><span class="p">,</span>
        <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"Some extra awesome content"</span>
    <span class="p">}</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
        <span class="s2">"/create-article/"</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span>
            <span class="n">data</span>
        <span class="p">),</span>
        <span class="n">content_type</span><span class="o">=</span><span class="s2">"application/json"</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">validate_payload</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">,</span> <span class="s2">"Article.json"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_get_article</span><span class="p">(</span><span class="n">client</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN ID of article stored in the database</span>
<span class="sd">    WHEN endpoint /article/&lt;id-of-article&gt;/ is called</span>
<span class="sd">    THEN it should return Article in json format that matches the schema</span>
<span class="sd">    """</span>
    <span class="n">article</span> <span class="o">=</span> <span class="n">Article</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a7cdc6c9c2e7c3c8c289c4c8ca">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super extra awesome article"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">"/article/</span><span class="si">{</span><span class="n">article</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">/"</span><span class="p">,</span>
        <span class="n">content_type</span><span class="o">=</span><span class="s2">"application/json"</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">validate_payload</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">,</span> <span class="s2">"Article.json"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_list_articles</span><span class="p">(</span><span class="n">client</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN articles stored in the database</span>
<span class="sd">    WHEN endpoint /article-list/ is called</span>
<span class="sd">    THEN it should return list of Article in json format that matches the schema</span>
<span class="sd">    """</span>
    <span class="n">Article</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d0bab1beb590b4bfb5feb3bfbd">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super extra awesome article"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">"/article-list/"</span><span class="p">,</span>
        <span class="n">content_type</span><span class="o">=</span><span class="s2">"application/json"</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">validate_payload</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">,</span> <span class="s2">"ArticleList.json"</span><span class="p">)</span>
</code></pre></div>

<p>那么，这里发生了什么？</p>
<ol>
<li>首先，我们将Flask测试客户机定义为一个fixture，以便它可以在测试中使用。</li>
<li>接下来，我们添加了一个验证有效负载的函数。它需要两个参数:<ol>
<li><code>payload</code> -来自API的JSON响应</li>
<li><code>schema_name</code>—“模式”目录中模式文件的名称</li>
</ol>
</li>
<li>最后，有三个测试，每个端点一个。在每个测试中，都有一个对API的调用和对返回的有效负载的验证</li>
</ol>
<p>运行测试以确保它们在这一点上失败:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>现在我们可以编写API了。</p>
<p>更新<em> app.py </em>这样:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">jsonify</span><span class="p">,</span> <span class="n">request</span>

<span class="kn">from</span> <span class="nn">blog.commands</span> <span class="kn">import</span> <span class="n">CreateArticleCommand</span>
<span class="kn">from</span> <span class="nn">blog.queries</span> <span class="kn">import</span> <span class="n">GetArticleByIDQuery</span><span class="p">,</span> <span class="n">ListArticlesQuery</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/create-article/"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s2">"POST"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">create_article</span><span class="p">():</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="n">CreateArticleCommand</span><span class="p">(</span>
        <span class="o">**</span><span class="n">request</span><span class="o">.</span><span class="n">json</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">cmd</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span><span class="o">.</span><span class="n">dict</span><span class="p">())</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/article/&lt;article_id&gt;/"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s2">"GET"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">get_article</span><span class="p">(</span><span class="n">article_id</span><span class="p">):</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">GetArticleByIDQuery</span><span class="p">(</span>
        <span class="nb">id</span><span class="o">=</span><span class="n">article_id</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span><span class="o">.</span><span class="n">dict</span><span class="p">())</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/article-list/"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s2">"GET"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">list_articles</span><span class="p">():</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">ListArticlesQuery</span><span class="p">()</span>
    <span class="n">records</span> <span class="o">=</span> <span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">execute</span><span class="p">()]</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div>

<p>我们的路由处理器非常简单，因为所有的逻辑都被命令和查询覆盖了。具有副作用的可用操作(如突变)由命令表示——例如，创建一篇新文章。另一方面，没有副作用的动作，那些只是读取当前状态的动作，被查询所覆盖。</p>
<blockquote>
<p>本文中使用的命令和查询模式是<a href="https://www.martinfowler.com/bliki/CQRS.html"> CQRS </a>模式的简化版本。我们把CQRS和克鲁德结合在一起。</p>
<p>上面的<code>.dict()</code>方法是由pydantic的<code>BaseModel</code>提供的，我们所有的模型都继承了它。</p>
</blockquote>
<p>测试应该通过:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>我们已经讨论了快乐之路的场景。在现实世界中，我们必须预料到客户不会总是像预期的那样使用API。例如，当一个创建文章的请求在没有<code>title</code>的情况下发出时，<code>CreateArticleCommand</code>命令将引发一个<code>ValidationError</code>，这将导致一个内部服务器错误和一个HTTP状态500。这是我们想要避免的事情。因此，我们需要处理这样的错误，优雅地通知用户错误的请求。</p>
<p>让我们编写测试来涵盖这样的情况。将以下内容添加到<em> test_app.py </em>:</p>
<div class="codehilite"><pre><span/><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span>
    <span class="s2">"data"</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">"author"</span><span class="p">:</span> <span class="s2">"John Doe"</span><span class="p">,</span>
            <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"New Article"</span><span class="p">,</span>
            <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"Some extra awesome content"</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s2">"author"</span><span class="p">:</span> <span class="s2">"John Doe"</span><span class="p">,</span>
            <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"New Article"</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s2">"author"</span><span class="p">:</span> <span class="s2">"John Doe"</span><span class="p">,</span>
            <span class="s2">"title"</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"Some extra awesome content"</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_create_article_bad_request</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN request data with invalid values or missing attributes</span>
<span class="sd">    WHEN endpoint /create-article/ is called</span>
<span class="sd">    THEN it should return status 400</span>
<span class="sd">    """</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
        <span class="s2">"/create-article/"</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span>
            <span class="n">data</span>
        <span class="p">),</span>
        <span class="n">content_type</span><span class="o">=</span><span class="s2">"application/json"</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">400</span>
    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
</code></pre></div>

<p>我们使用pytest的<a href="https://docs.pytest.org/en/stable/parametrize.html#pytest-mark-parametrize-parametrizing-test-functions">参数化</a>选项，这简化了将多个输入传递给单个测试的过程。</p>
<p>此时测试应该会失败，因为我们还没有处理<code>ValidationError</code>:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<p>因此，让我们在<em> app.py </em>中为Flask应用程序添加一个错误处理程序:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">ValidationError</span>

<span class="c1"># Other code ...</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="n">ValidationError</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">handle_validation_exception</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">errors</span><span class="p">())</span>
    <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">=</span> <span class="mi">400</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="c1"># Other code ...</span>
</code></pre></div>

<p><code>ValidationError</code>有一个<code>errors</code>方法，该方法返回每个字段的所有错误列表，这些错误要么是缺失的，要么是传递了一个没有通过验证的值。我们可以简单地在主体中返回它，并将响应的状态设置为400。</p>
<p>既然错误得到了适当的处理，所有测试都应该通过:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests
</code></pre></div>

<h2 id="code-coverage">代码覆盖率</h2>
<p>现在，我们的应用程序已经测试完毕，是时候检查代码覆盖率了。因此，让我们为覆盖率安装一个名为<a href="https://pytest-cov.readthedocs.io/en/latest/"> pytest-cov </a>的pytest插件:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install pytest-cov
</code></pre></div>

<p>安装插件后，我们可以像这样检查我们的博客应用程序的代码覆盖率:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests --cov<span class="o">=</span>blog
</code></pre></div>

<p>您应该会看到类似如下的内容:</p>
<div class="codehilite"><pre><span/><code>---------- coverage: platform darwin, python <span class="m">3</span>.10.1-final-0 ----------
Name               Stmts   Miss  Cover
--------------------------------------
blog/__init__.py       <span class="m">0</span>      <span class="m">0</span>   <span class="m">100</span>%
blog/app.py           <span class="m">25</span>      <span class="m">1</span>    <span class="m">96</span>%
blog/commands.py      <span class="m">16</span>      <span class="m">0</span>   <span class="m">100</span>%
blog/models.py        <span class="m">57</span>      <span class="m">1</span>    <span class="m">98</span>%
blog/queries.py       <span class="m">12</span>      <span class="m">0</span>   <span class="m">100</span>%
--------------------------------------
TOTAL                <span class="m">110</span>      <span class="m">2</span>    <span class="m">98</span>%
</code></pre></div>

<p>98%的覆盖率够好吗？可能是吧。尽管如此，记住一件事:高覆盖率固然很好，但是测试的质量更重要。如果只有70%或更少的代码被覆盖，你应该考虑增加覆盖率。但是编写从98%到100%的测试通常是没有意义的。(同样，测试需要维护，就像您的业务逻辑一样！)</p>
<h2 id="end-to-end-tests">端到端测试</h2>
<p>在这一点上，我们有一个经过全面测试的工作API。我们现在可以看看如何编写一些端到端(e2e)测试。因为我们有一个简单的API，所以我们可以编写一个e2e测试来涵盖以下场景:</p>
<ol>
<li>创建新文章</li>
<li>列出文章</li>
<li>从列表中获取第一篇文章</li>
</ol>
<p>首先，安装<a href="https://requests.readthedocs.io/en/master/">请求</a>库:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ pip install requests
</code></pre></div>

<p>其次，向<em> test_app.py </em>添加一个新的测试:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="c1"># other code ...</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">e2e</span>
<span class="k">def</span> <span class="nf">test_create_list_get</span><span class="p">(</span><span class="n">client</span><span class="p">):</span>
    <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
        <span class="s2">"http://localhost:5000/create-article/"</span><span class="p">,</span>
        <span class="n">json</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">"author"</span><span class="p">:</span> <span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="274d484f49674348420944484a">[email protected]</a>"</span><span class="p">,</span>
            <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"New Article"</span><span class="p">,</span>
            <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"Some extra awesome content"</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">"http://localhost:5000/article-list/"</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">articles</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">"http://localhost:5000/article/</span><span class="si">{</span><span class="n">articles</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">'id'</span><span class="p">]</span><span class="si">}</span><span class="s2">/"</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
</code></pre></div>

<p>在运行这个测试之前，我们需要做两件事...</p>
<p>首先，通过将以下代码添加到<em> pytest.ini </em>中，向pytest注册一个名为<code>e2e</code>的<a href="https://docs.pytest.org/en/stable/how-to/mark.html#registering-marks">标记</a>:</p>
<div class="codehilite"><pre><span/><code><span class="k">[pytest]</span><span class="w"/>
<span class="na">markers</span><span class="w"> </span><span class="o">=</span><span class="w"/>
<span class="w">    </span><span class="na">e2e: marks tests as e2e (deselect with '-m "not e2e"')</span><span class="w"/>
</code></pre></div>

<p>pytest标记用于排除某些测试的运行，或者包括与其位置无关的选定测试。</p>
<p>要仅运行e2e测试，请运行:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests -m <span class="s1">'e2e'</span>
</code></pre></div>

<p>运行除<em> e2e </em>之外的所有测试:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests -m <span class="s1">'not e2e'</span>
</code></pre></div>

<blockquote>
<p>e2e测试的运行成本更高，而且需要启动并运行应用程序，所以你可能不想一直运行它们。</p>
</blockquote>
<p>由于我们的e2e测试击中了一个现场服务器，我们需要旋转应用程序。在新的终端窗口中导航到项目，激活虚拟环境，然后运行应用程序:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ <span class="nv">FLASK_APP</span><span class="o">=</span>blog/app.py python -m flask run
</code></pre></div>

<p>现在我们可以运行我们的e2e测试:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests -m <span class="s1">'e2e'</span>
</code></pre></div>

<p>您应该会看到一个500错误。为什么？单元测试没有通过吗？是的。问题是我们没有创建数据库表。我们在测试中使用了夹具来完成这项工作。所以让我们创建一个表和一个数据库。</p>
<p>向“博客”文件夹添加一个<em> init_db.py </em>文件:</p>
<div class="codehilite"><pre><span/><code><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">blog.models</span> <span class="kn">import</span> <span class="n">Article</span>
    <span class="n">Article</span><span class="o">.</span><span class="n">create_table</span><span class="p">()</span>
</code></pre></div>

<p>运行新脚本并再次启动服务器:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python blog/init_db.py
<span class="o">(</span>venv<span class="o">)</span>$ <span class="nv">FLASK_APP</span><span class="o">=</span>blog/app.py python -m flask run
</code></pre></div>

<blockquote>
<p>如果您在运行<em> init_db.py </em>时遇到任何问题，您可能需要设置Python路径:<code>export PYTHONPATH=$PYTHONPATH:$PWD</code>。</p>
</blockquote>
<p>测试现在应该通过了:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest tests -m <span class="s1">'e2e'</span>
</code></pre></div>

<h2 id="testing-pyramid">测试金字塔</h2>
<p>我们从单元测试(测试命令和查询)开始，然后是集成测试(测试API端点)，最后是e2e测试。在简单的应用程序中，就像在这个例子中，您可能会以类似数量的单元测试和集成测试结束。一般来说，越复杂，就单元、集成和e2e测试之间的关系而言，你越应该看到一个金字塔形状。这就是“测试金字塔”这个术语的由来。</p>
<p><a href="https://martinfowler.com/articles/practical-test-pyramid.html">测试金字塔</a>是一个可以帮助开发者创建高质量软件的框架。</p>
<p><img data-src="/static/images/blog/flask/modern-tdd/testing_pyramid.jpg" loading="lazy" class="lazyload" alt="Test pyramid" src="../Images/111429e87174023968a040c28f1860e0.png" data-original-src="https://testdriven.io/static/images/blog/flask/modern-tdd/testing_pyramid.jpg"/></p>
<p>使用测试金字塔作为指导，您通常希望测试套件中50%的测试是单元测试，30%是集成测试，20%是e2e测试。</p>
<p>定义:</p>
<ul>
<li>单元测试——测试单个代码单元</li>
<li>集成测试——多个单元一起工作的测试</li>
<li>e2e——在一个类似生产的服务器上测试整个应用程序</li>
</ul>
<p>你在金字塔中的位置越高，你的测试就越脆弱，越不可预测。更重要的是，e2e测试是迄今为止运行最慢的，所以即使它们可以让你确信你的应用程序正在做你所期望的事情，你也不应该像单元测试或集成测试那样多。</p>
<h2 id="what-is-a-unit">什么是单位？</h2>
<p>集成和e2e测试看起来很简单。关于单元测试有更多的讨论，因为你首先必须定义“单元”实际上是什么。大多数测试教程都展示了一个测试单个函数或方法的单元测试示例。生产代码从来没有这么简单。</p>
<p>首先，在定义一个单元是什么之前，让我们看看测试的意义是什么，应该测试什么。</p>
<h3 id="why-test">为什么要测试？</h3>
<p>我们编写测试的目的是:</p>
<ol>
<li>确保我们的代码按预期运行</li>
<li>保护我们的软件不受退化的影响</li>
</ol>
<p>尽管如此，当反馈周期太长时，开发人员往往会开始更多地考虑要编写的测试类型，因为时间是软件开发中的一个主要约束。这就是为什么我们希望有比其他类型的测试更多的单元测试。我们希望尽快找到并修复缺陷。</p>
<h3 id="what-to-test">考什么？</h3>
<p>现在你知道了<em>为什么</em>我们应该测试，我们现在必须看看<em>我们应该测试什么</em>。</p>
<p>我们应该测试我们软件的行为。(而且，是的:这仍然适用于TDD，而不仅仅是<a href="https://en.wikipedia.org/wiki/Behavior-driven_development"> BDD </a>。)这是因为您不应该在每次代码库发生变化时都必须改变您的测试。</p>
<p>回想一下真实世界应用程序的例子。从测试的角度来看，我们不关心文章存储在哪里。它可以是一个文本文件，一些其他的关系数据库，或者一个键/值存储——这没关系。同样，我们的应用程序有以下要求:</p>
<ul>
<li>可以创建文章</li>
<li>文章可以拿来</li>
<li>文章可以列出来</li>
</ul>
<p>只要这些需求不变，存储介质的变化就不会破坏我们的测试。类似地，我们知道只要那些测试通过，我们就知道我们的软件满足那些需求——所以它在工作。</p>
<h3 id="so-what-is-a-unit-then">那么什么是单位呢？</h3>
<p>每个函数/方法在技术上是一个单元，但是我们仍然不应该测试它们中的每一个。相反，应该将精力集中在测试模块/包中公开的函数和方法上。</p>
<p>在我们的例子中，这些是<code>execute</code>方法。我们不期望直接从Flask API调用<code>Article</code>模型，所以不要花太多精力(如果有的话)测试它。更准确地说，在我们的例子中，应该被测试的“单元”是来自命令和查询的<code>execute</code>方法。如果某个方法不打算从我们软件的其他部分或最终用户直接调用，那么它可能是实现细节。因此，我们的测试抵制对实现细节的重构，这是优秀测试的品质之一。</p>
<p>例如，如果我们将<code>get_by_id</code>和<code>get_by_title</code>的逻辑包装在一个叫做<code>_get_by_attribute</code>的“受保护”方法中，我们的测试仍然应该通过:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># other code ...</span>

<span class="k">class</span> <span class="nc">Article</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()))</span>
    <span class="n">author</span><span class="p">:</span> <span class="n">EmailStr</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_by_id</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">article_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_by_attribute</span><span class="p">(</span><span class="s2">"SELECT * FROM articles WHERE id=?"</span><span class="p">,</span> <span class="p">(</span><span class="n">article_id</span><span class="p">,))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_by_title</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_by_attribute</span><span class="p">(</span><span class="s2">"SELECT * FROM articles WHERE title = ?"</span><span class="p">,</span> <span class="p">(</span><span class="n">title</span><span class="p">,))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_by_attribute</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sql_query</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sql_query_values</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">"DATABASE_NAME"</span><span class="p">,</span> <span class="s2">"database.db"</span><span class="p">))</span>
        <span class="n">con</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Row</span>

        <span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql_query</span><span class="p">,</span> <span class="n">sql_query_values</span><span class="p">)</span>

        <span class="n">record</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">record</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotFound</span>

        <span class="n">article</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">record</span><span class="p">)</span>  <span class="c1"># Row can be unpacked as dict</span>
        <span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">article</span>

<span class="c1"># other code ..</span>
</code></pre></div>

<p>另一方面，如果你在<code>Article</code>内部做了一个突破性的改变，测试将会失败。这正是我们想要的。在这种情况下，我们既可以恢复重大变更，也可以在命令或查询中适应它。</p>
<p>因为有一件事我们正在努力:通过测试意味着工作软件。</p>
<h2 id="when-should-you-use-mocks">什么时候应该使用模拟？</h2>
<p>我们在测试中没有使用任何模拟，因为我们不需要它们。模仿模块或包中的方法或类会产生无法抵抗重构的测试，因为它们与实现细节相关联。这种测试经常出错，而且维护成本很高。另一方面，当速度成为问题时，模仿外部资源是有意义的(调用外部API、发送电子邮件、长时间运行的异步进程等)。).</p>
<p>例如，我们可以单独测试<code>Article</code>模型，并在我们对<code>CreateArticleCommand</code>的测试中模拟它，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">test_create_article</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN CreateArticleCommand with valid properties author, title and content</span>
<span class="sd">    WHEN the execute method is called</span>
<span class="sd">    THEN a new Article must exist in the database with same attributes</span>
<span class="sd">    """</span>
    <span class="n">article</span> <span class="o">=</span> <span class="n">Article</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7d171215133d191218531e1210">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super awesome article"</span>
    <span class="p">)</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span>
        <span class="n">Article</span><span class="p">,</span>
        <span class="s2">"save"</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">article</span>
    <span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="n">CreateArticleCommand</span><span class="p">(</span>
        <span class="n">author</span><span class="o">=</span><span class="s2">"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ef85808781af8b808ac18c8082">[email protected]</a>"</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">"New Article"</span><span class="p">,</span>
        <span class="n">content</span><span class="o">=</span><span class="s2">"Super awesome article"</span>
    <span class="p">)</span>

    <span class="n">db_article</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">db_article</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">article</span><span class="o">.</span><span class="n">id</span>
    <span class="k">assert</span> <span class="n">db_article</span><span class="o">.</span><span class="n">author</span> <span class="o">==</span> <span class="n">article</span><span class="o">.</span><span class="n">author</span>
    <span class="k">assert</span> <span class="n">db_article</span><span class="o">.</span><span class="n">title</span> <span class="o">==</span> <span class="n">article</span><span class="o">.</span><span class="n">title</span>
    <span class="k">assert</span> <span class="n">db_article</span><span class="o">.</span><span class="n">content</span> <span class="o">==</span> <span class="n">article</span><span class="o">.</span><span class="n">content</span>
</code></pre></div>

<p>是的，这样做很好，但是我们现在有更多的测试要维护——也就是说，之前的所有测试加上<code>Article</code>中方法的所有新测试。除此之外，<code>test_create_article</code>现在唯一测试的就是<code>save</code>返回的文章和<code>execute</code>返回的文章是一样的。当我们打破<code>Article</code>内部的东西时，这个测试仍然会通过，因为我们嘲笑它。这是我们想要避免的事情:我们想要测试软件行为，以确保它按预期工作。在这种情况下，行为被破坏，但我们的测试不会显示这一点。</p>
<h2 id="takeaways">外卖食品</h2>
<ol>
<li>没有唯一正确的方法来测试你的软件。尽管如此，当逻辑不与数据库耦合时，测试逻辑会更容易。您可以使用带有命令和查询的活动记录模式(CQRS)来帮助解决这个问题。</li>
<li>关注代码的商业价值。</li>
<li>不要测试方法只是为了说它们被测试过。你需要工作的软件，而不是经过测试的方法。TDD只是一种工具，可以更快、更可靠地交付更好的软件。代码覆盖率也是如此:尽量保持高覆盖率，但不要为了100%的覆盖率而增加测试。</li>
<li>一个测试只有当它保护你不回归，允许你重构，并且提供你快速的反馈时才有价值。因此，您应该努力使您的测试看起来像一个金字塔形状(50%单元，30%集成，20% e2e)。虽然，在简单的应用程序中，它可能看起来更像一所房子(40%的单元，40%的集成，20%的e2e)，这很好。</li>
<li>你越快发现回归，你就能越快拦截和纠正它们。你越快纠正它们，开发周期就越短。为了加速反馈，你可以在开发过程中使用pytest标记来排除e2e和其他缓慢的测试。您可以减少运行它们的频率。</li>
<li>只有在必要的时候才使用模拟(比如第三方HTTP APIs)。它们使您的测试设置更加复杂，并且总体上降低了您的测试对重构的抵抗力。此外，它们可能导致假阳性。</li>
<li>再说一次，你的测试是一种负担而不是资产；他们应该涵盖你的软件的行为，但不要过度测试。</li>
</ol>
<h2 id="conclusion">结论</h2>
<p>这里有很多东西需要消化。请记住，这些只是用来展示想法的例子。你可以将同样的想法用于<a href="https://martinfowler.com/bliki/DomainDrivenDesign.html">领域驱动设计</a>(DDD)<a href="https://en.wikipedia.org/wiki/Behavior-driven_development"/>(BDD)，以及许多其他方法。请记住，测试应该像对待任何其他代码一样对待:它们是负债而不是资产。编写测试来保护你的软件不受bug的影响，但是不要让它浪费你的时间。</p>
<h3 id="want-to-learn-more">想了解更多？</h3>

<blockquote>
<p><a href="/guides/complete-python/">完整Python </a>指南:</p>
<ol>
<li><a href="/blog/python-environments/">现代Python环境——依赖性和工作空间管理</a></li>
<li><a href="/blog/testing-python/">Python中的测试</a></li>
<li><a href="/blog/modern-tdd/">Python中的现代测试驱动开发</a>(本文！)</li>
<li><a href="/blog/python-code-quality/"> Python代码质量</a></li>
<li><a href="/blog/python-type-checking/"> Python类型检查</a></li>
<li><a href="/blog/documenting-python/">记录Python代码和项目</a></li>
<li><a href="/blog/python-project-workflow/"> Python项目工作流程</a></li>
</ol>
</blockquote>
  </div>

  </div>    
</body>
</html>