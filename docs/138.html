<html>
<head>
<title>Automating Performance Testing in Django </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Django中的自动化性能测试</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/django-performance-testing/#0001-01-01">https://testdriven.io/blog/django-performance-testing/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>低效的数据库查询是Django最常见的性能缺陷之一。尤其是N+1查询会在早期对应用程序的性能产生负面影响。当您使用针对每个记录的单独查询从关联表中选择记录，而不是在单个查询中获取所有记录时，就会出现这种情况。不幸的是，这种低效很容易被Django ORM引入。也就是说，它们是可以通过自动化测试快速发现和预防的。</p>
<p>这篇文章着眼于如何:</p>
<ol>
<li>测试一个请求执行的查询数量以及查询的持续时间</li>
<li>使用<a href="https://github.com/jmcarp/nplusone"> nplusone </a>包防止N+1次查询</li>
</ol>



<h2 id="n1-queries">N+1个查询</h2>
<blockquote>
<p>我们将在这篇文章中使用的示例应用程序可以在<a href="https://github.com/testdrivenio/django-performance-testing"> GitHub </a>上找到。</p>
</blockquote>
<p>比方说，您正在使用一个Django应用程序，它有以下模型:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># courses/models.py</span>

<span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span> <span class="nc">Course</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">author</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Author</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span>
</code></pre></div>

<p>现在，如果您的任务是创建一个新视图，用于返回所有课程的JSON响应，包括标题和作者姓名，您可以编写以下代码:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># courses/views.py</span>

<span class="kn">from</span> <span class="nn">django.http</span> <span class="kn">import</span> <span class="n">JsonResponse</span>

<span class="kn">from</span> <span class="nn">courses.models</span> <span class="kn">import</span> <span class="n">Course</span>


<span class="k">def</span> <span class="nf">all_courses</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="n">courses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">course</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">:</span>
        <span class="n">courses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">"title"</span><span class="p">:</span> <span class="n">course</span><span class="o">.</span><span class="n">title</span><span class="p">,</span> <span class="s2">"author"</span><span class="p">:</span> <span class="n">course</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">JsonResponse</span><span class="p">(</span><span class="n">courses</span><span class="p">,</span> <span class="n">safe</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

<p>这段代码可以工作，但是效率非常低，因为它会进行太多的数据库查询:</p>
<ul>
<li>1获取所有课程的查询</li>
<li>在每次迭代中获取分支的n次查询</li>
</ul>
<p>在解决这个问题之前，让我们看看进行了多少次查询，并测量执行时间。</p>
<h2 id="metrics-middleware">度量中间件</h2>
<p>您会注意到该项目包含了定制的中间件，它计算并记录每个请求的执行时间:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># core/middleware.py</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">connection</span><span class="p">,</span> <span class="n">reset_queries</span>


<span class="k">def</span> <span class="nf">metric_middleware</span><span class="p">(</span><span class="n">get_response</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">middleware</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
        <span class="n">reset_queries</span><span class="p">()</span>

        <span class="c1"># Get beginning stats</span>
        <span class="n">start_queries</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">queries</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="c1"># Process the request</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">get_response</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="c1"># Get ending stats</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">end_queries</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">queries</span><span class="p">)</span>

        <span class="c1"># Calculate stats</span>
        <span class="n">total_time</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="n">total_queries</span> <span class="o">=</span> <span class="n">end_queries</span> <span class="o">-</span> <span class="n">start_queries</span>

        <span class="c1"># Log the results</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">"debug"</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Request: </span><span class="si">{</span><span class="n">request</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">request</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Number of Queries: </span><span class="si">{</span><span class="n">total_queries</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Total time: </span><span class="si">{</span><span class="p">(</span><span class="n">total_time</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s"</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">response</span>

    <span class="k">return</span> <span class="n">middleware</span>
</code></pre></div>

<p>运行数据库种子命令，向数据库添加10名作者和100门课程:</p>
<div class="codehilite"><pre><span/><code>$ python manage.py seed_db
</code></pre></div>

<p>Django开发服务器启动并运行后，在浏览器中导航到<a href="http://localhost:8000/courses/">http://localhost:8000/courses/</a>。您应该会看到JSON响应。回到您的终端，记下指标:</p>
<div class="codehilite"><pre><span/><code>Request: GET /courses/
Number of Queries: <span class="m">101</span>
Total time: <span class="m">0</span>.10s
</code></pre></div>

<p>这是一个很大的疑问！这是非常低效的。每增加一个作者和课程都需要一个额外的数据库查询，所以随着数据库的增长，性能会继续下降。幸运的是，解决这个问题非常简单:您可以添加一个<code>select_related</code>方法来创建一个SQL join，它将在初始数据库查询中包含作者。</p>
<div class="codehilite"><pre><span/><code><span class="n">queryset</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s2">"author"</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</code></pre></div>

<p>在进行任何代码更改之前，让我们先从一些测试开始。</p>
<h2 id="performance-tests">性能测试</h2>
<p>从下面的测试开始，它使用django _ assert _ num _ queriespy test fixture来确保当数据库中存在一个或多个作者和课程记录时，数据库只被命中一次:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">json</span>

<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">faker</span> <span class="kn">import</span> <span class="n">Faker</span>
<span class="kn">from</span> <span class="nn">django.test</span> <span class="kn">import</span> <span class="n">override_settings</span>

<span class="kn">from</span> <span class="nn">courses.models</span> <span class="kn">import</span> <span class="n">Course</span><span class="p">,</span> <span class="n">Author</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">django_db</span>
<span class="k">def</span> <span class="nf">test_number_of_sql_queries_all_courses</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">django_assert_num_queries</span><span class="p">):</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">Faker</span><span class="p">()</span>

    <span class="n">author_name</span> <span class="o">=</span> <span class="n">fake</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
    <span class="n">author</span> <span class="o">=</span> <span class="n">Author</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">author_name</span><span class="p">)</span>
    <span class="n">author</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="n">course_title</span> <span class="o">=</span> <span class="n">fake</span><span class="o">.</span><span class="n">sentence</span><span class="p">(</span><span class="n">nb_words</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">course</span> <span class="o">=</span> <span class="n">Course</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">course_title</span><span class="p">,</span> <span class="n">author</span><span class="o">=</span><span class="n">author</span><span class="p">)</span>
    <span class="n">course</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">django_assert_num_queries</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/courses/"</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">res</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="n">author_name</span> <span class="o">=</span> <span class="n">fake</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="n">author</span> <span class="o">=</span> <span class="n">Author</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">author_name</span><span class="p">)</span>
        <span class="n">author</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="n">course_title</span> <span class="o">=</span> <span class="n">fake</span><span class="o">.</span><span class="n">sentence</span><span class="p">(</span><span class="n">nb_words</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">course</span> <span class="o">=</span> <span class="n">Course</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">course_title</span><span class="p">,</span> <span class="n">author</span><span class="o">=</span><span class="n">author</span><span class="p">)</span>
        <span class="n">course</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/courses/"</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">res</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
</code></pre></div>

<blockquote>
<p>不使用pytest？使用<a href="https://docs.djangoproject.com/en/3.2/topics/testing/tools/#django.test.TransactionTestCase.assertNumQueries"> assertNumQueries </a>测试方法代替<code>django_assert_num_queries</code>。</p>
</blockquote>
<p>此外，我们还可以使用<a href="https://github.com/jmcarp/nplusone"> nplusone </a>来防止引入未来的N+1个查询。在安装完包并将其添加到设置文件之后，您可以使用<code>@override_settings</code>装饰器将它添加到您的测试中:</p>
<div class="codehilite"><pre><span/><code><span class="o">...</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">django_db</span>
<span class="nd">@override_settings</span><span class="p">(</span><span class="n">NPLUSONE_RAISE</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_number_of_sql_queries_all_courses</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">django_assert_num_queries</span><span class="p">):</span>
    <span class="o">...</span>
</code></pre></div>

<p>或者，如果您想在整个测试套件中自动启用nplusone，那么将以下内容添加到您的测试根<em> conftest.py </em>文件中:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">django.conf</span> <span class="kn">import</span> <span class="n">settings</span>


<span class="k">def</span> <span class="nf">pytest_configure</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">settings</span><span class="o">.</span><span class="n">NPLUSONE_RAISE</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></div>

<p>回到示例应用程序，然后运行测试。您应该会看到以下错误:</p>
<div class="codehilite"><pre><span/><code>nplusone.core.exceptions.NPlusOneError: Potential n+1 query detected on <span class="sb">`</span>Course.author<span class="sb">`</span>
</code></pre></div>

<p>现在，进行推荐的更改——添加<code>select_related</code>方法——然后再次运行测试。他们现在应该通过了。</p>
<h2 id="conclusion">结论</h2>
<p>这篇文章介绍了如何使用<a href="https://github.com/jmcarp/nplusone"> nplusone </a>包在代码库中自动阻止N+1个查询，并使用<code>django_assert_num_queries</code> pytest fixture测试执行的查询数量。</p>
<p>随着应用程序的增长和用户的增加，这应该有助于防止性能瓶颈。如果您将它添加到现有的代码库中，您可能需要花费一些时间来修复中断的查询，以便它们具有恒定的数据库命中次数。如果在修复和优化之后仍然遇到性能问题，您可能需要添加额外的缓存层，对数据库的某些部分进行反规范化，和/或配置数据库索引。</p>
  </div>

  </div>    
</body>
</html>