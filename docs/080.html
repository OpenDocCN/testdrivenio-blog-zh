<html>
<head>
<title>Testing Flask Applications with Pytest </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Pytest测试烧瓶应用</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/flask-pytest/#0001-01-01">https://testdriven.io/blog/flask-pytest/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>这篇文章是用<a href="https://docs.pytest.org/en/latest/"> pytest </a>测试烧瓶应用的指南。</p>
<p>我们将首先看看为什么测试对于创建可维护的软件很重要，以及在测试时应该关注什么。然后，我们将详细介绍如何:</p>
<ul>
<li>使用pytest创建并运行烧瓶特定的单元和功能测试</li>
<li>利用夹具来初始化测试功能的状态</li>
<li>使用coverage.py检查测试的覆盖率</li>
</ul>
<blockquote>
<p>本文中测试的Flask应用程序的源代码(以及详细的安装说明)可以在GitLab上的<a href="https://gitlab.com/patkennedy79/flask_user_management_example">https://git lab . com/patkennedy 79/Flask _ user _ management _ example</a>中找到。</p>
</blockquote>



<h2 id="objectives">目标</h2>
<p>完成本文后，您将能够:</p>
<ol>
<li>解释在Flask应用程序中测试什么</li>
<li>描述pytest和unittest之间的区别</li>
<li>用pytest编写烧瓶特定的单元和功能测试函数</li>
<li>使用pytest运行测试</li>
<li>创建用于初始化测试功能状态的夹具</li>
<li>用coverage.py确定测试的代码覆盖率</li>
</ol>
<h2 id="why-write-tests">为什么要写测试？</h2>
<p>总的来说，测试有助于确保你的应用程序能像最终用户期望的那样工作。</p>
<p>具有高测试覆盖率的软件项目从来都不是完美的，但是它是软件质量的一个很好的初始指示器。此外，可测试的代码通常是一个好的软件架构的标志，这就是高级开发人员在整个开发生命周期中考虑测试的原因。</p>
<p>测试可以分为三个层次:</p>
<ul>
<li>单位</li>
<li>功能(或集成)</li>
<li>端到端</li>
</ul>
<p>单元测试测试独立于依赖项的单个代码单元的功能。它们是防止代码库中出现错误和不一致的第一道防线。他们从程序员的角度出发，从内到外进行测试。</p>
<p>功能测试对软件产品的多个组件进行测试，以确保这些组件能够正常工作。通常，这些测试关注用户将要使用的功能。他们从最终用户的角度，由外向内进行测试。</p>
<p>单元测试和功能测试都是<a href="/test-driven-development/">测试驱动开发(TDD) </a>过程的基础部分。</p>
<p>测试提高了代码的可维护性。</p>
<p>可维护性是指对您的代码进行错误修复或增强，或者对将来某个时候需要更新您的代码的其他开发人员进行修复或增强。</p>
<p>测试应该与<a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成</a> (CI)过程相结合，以确保您的测试不断地被执行，最好是在每次提交到您的存储库时。一套可靠的测试对于在开发过程的早期<strong>快速捕捉缺陷至关重要，在</strong>最终用户在生产中遇到它们之前。</p>
<h2 id="what-to-test">考什么？</h2>
<p>你应该测试什么？</p>
<p>同样，单元测试应该集中在孤立地测试小的代码单元。</p>
<p>例如，在Flask应用程序中，您可以使用单元测试来测试:</p>
<ol>
<li>数据库模型(通常在<em> models.py </em>中定义)</li>
<li>视图函数调用的实用函数</li>
</ol>
<p>同时，功能测试应该关注视图功能是如何操作的。</p>
<p>例如:</p>
<ol>
<li>名义条件(GET、POST等。)用于查看功能</li>
<li>对于视图函数，可以正确处理无效的HTTP方法</li>
<li>向视图函数传递了无效数据</li>
</ol>
<p>关注终端用户将与之交互的测试场景。你的产品的用户体验是最重要的！</p>
<h2 id="pytest-vs-unittest">pytestvs.unittest</h2>
<p>pytest是Python的一个测试框架，用于编写、组织和运行测试用例。在建立了基本的测试结构之后，pytest使得编写测试变得非常容易，并且为运行测试提供了很大的灵活性。pytest满足良好测试环境的关键方面:</p>
<ul>
<li>编写测试很有趣</li>
<li>通过使用助手函数(fixtures ),可以快速编写测试</li>
<li>可以用一个命令来执行测试</li>
<li>测试运行迅速</li>
</ul>
<blockquote>
<p>pytest太不可思议了！我强烈推荐使用它来测试任何用Python编写的应用程序或脚本。</p>
<p>如果你真的对学习pytest的各个方面感兴趣，我强烈推荐Brian Okken写的《用pytest进行Python测试》。</p>
</blockquote>
<p>Python有一个名为<a href="https://docs.python.org/3/library/unittest.html"> unittest </a>的内置测试框架，这也是测试的一个很好的选择。unittest模块的灵感来自于<a href="https://en.wikipedia.org/wiki/XUnit"> xUnit </a>测试框架。</p>
<p>它提供了以下内容:</p>
<ul>
<li>用于构建单元测试的工具，包括一整套用于执行检查的<code>assert</code>语句</li>
<li>用于开发单元测试和单元测试套件的结构</li>
<li>用于执行测试的测试运行器</li>
</ul>
<p>pytest和unittest的主要区别是:</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>pytest</th>
<th>unittest</th>
</tr>
</thead>
<tbody>
<tr>
<td>装置</td>
<td>第三方库</td>
<td>核心标准库的一部分</td>
</tr>
<tr>
<td>测试设置和拆卸</td>
<td>固定装置</td>
<td><code>setUp()</code>和<code>tearDown()</code>方法</td>
</tr>
<tr>
<td>断言格式</td>
<td>内置断言</td>
<td><code>assert*</code>风格<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual">方法</a></td>
</tr>
<tr>
<td>结构</td>
<td>功能的</td>
<td>面向对象</td>
</tr>
</tbody>
</table>
<p>这两种框架都适合测试Flask项目。但是，我更喜欢pytest，因为它:</p>
<ol>
<li>需要更少的样板代码，因此您的测试套件将更具可读性。</li>
<li>支持简单的<code>assert</code>语句，与unittest中的<code>assertSomething</code>方法——如<code>assertEquals</code>、<code>assertTrue</code>和<code>assertContains</code>——相比，它可读性更好，也更容易记住。</li>
<li>更新更频繁，因为它不是Python标准库的一部分。</li>
<li>简化测试状态的设置和拆除。</li>
<li>使用功能方法。</li>
<li>支撑<a href="https://docs.pytest.org/en/latest/how-to/fixtures.html">夹具</a>。</li>
</ol>
<h2 id="testing">测试</h2>
<h3 id="project-structure">项目结构</h3>
<p>我喜欢将所有的测试用例组织在一个单独的“tests”文件夹中，与应用程序文件在同一层。</p>
<p>此外，我非常喜欢通过将单元测试和功能测试作为单独的子文件夹来区分它们。这种结构为您提供了只运行单元测试(或者只运行功能测试)的灵活性。</p>
<p>下面是“测试”目录的结构示例:</p>
<div class="codehilite"><pre><span/><code>└── tests
    ├── conftest.py
    ├── functional
    │   ├── __init__.py
    │   ├── test_stocks.py
    │   └── test_users.py
    └── unit
        ├── __init__.py
        └── test_models.py
</code></pre></div>

<p>下面是“tests”文件夹如何适应一个典型的带有<a href="https://flask.palletsprojects.com/en/2.0.x/blueprints/">蓝图</a>的Flask项目:</p>
<div class="codehilite"><pre><span/><code>├── app.py
├── project
│   ├── __init__.py
│   ├── models.py
│   └── ...blueprint folders...
├── requirements.txt
├── tests
│   ├── conftest.py
│   ├── functional
│   │   ├── __init__.py
│   │   ├── test_stocks.py
│   │   └── test_users.py
│   └── unit
│       ├── __init__.py
│       └── test_models.py
└── venv
</code></pre></div>

<h3 id="unit-test-example">单元测试示例</h3>
<p>我们要编写的第一个测试是针对<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/project/models.py"><em>project/models . py</em></a>的单元测试，它包含数据库的<a href="https://www.sqlalchemy.org"> SQLAlchemy </a>接口。</p>
<blockquote>
<p>该测试不访问底层数据库；它只检查SQLAlchemy使用的接口类。</p>
</blockquote>
<p>由于这个测试是单元测试，所以应该在<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/tests/unit/test_models.py"><em>tests/unit/test _ models . py</em></a>中实现:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">project.models</span> <span class="kn">import</span> <span class="n">User</span>


<span class="k">def</span> <span class="nf">test_new_user</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN a User model</span>
<span class="sd">    WHEN a new User is created</span>
<span class="sd">    THEN check the email, hashed_password, and role fields are defined correctly</span>
<span class="sd">    """</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s1">'<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="750514011e101b1b10110c424c351218141c195b161a18">[email protected]</a>'</span><span class="p">,</span> <span class="s1">'FlaskIsAwesome'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="o">==</span> <span class="s1">'<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="86f6e7f2ede3e8e8e3e2ffb1bfc6e1ebe7efeaa8e5e9eb">[email protected]</a>'</span>
    <span class="k">assert</span> <span class="n">user</span><span class="o">.</span><span class="n">hashed_password</span> <span class="o">!=</span> <span class="s1">'FlaskIsAwesome'</span>
    <span class="k">assert</span> <span class="n">user</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="s1">'user'</span>
</code></pre></div>

<p>让我们仔细看看这个测试。</p>
<p>导入之后，我们从测试内容的描述开始:</p>
<div class="codehilite"><pre><span/><code><span class="sd">"""</span>
<span class="sd">GIVEN a User model</span>
<span class="sd">WHEN a new User is created</span>
<span class="sd">THEN check the email, hashed_password, and role fields are defined correctly</span>
<span class="sd">"""</span>
</code></pre></div>

<blockquote>
<p>为什么一个测试函数要包含这么多的注释？</p>
<p>我发现测试是项目中最难维护的方面之一。通常，测试套件的代码(包括注释的级别)远没有被测试代码的质量高。</p>
<p>一个用于描述每个测试功能的公共结构有助于可维护性，它使某人(另一个开发人员，您未来的自己)更容易快速理解每个测试的目的。</p>
<p>通常的做法是使用GIVEN-WHEN-THEN结构:</p>
<ul>
<li>假设-测试的初始条件是什么？</li>
<li>什么时候发生了什么需要测试？</li>
<li>那么，预期的反应是什么？</li>
</ul>
<p>更多信息，请查看马丁·福勒的文章<a href="https://martinfowler.com/bliki/GivenWhenThen.html"> GivenWhenThen </a>和布莱恩·奥肯的书<a href="https://pragprog.com/titles/bopytest2/python-testing-with-pytest-second-edition/"> Python测试与pytest </a>。</p>
</blockquote>
<p>接下来，我们进行实际测试:</p>


<p>在用构造函数的有效参数创建一个新的<code>user</code>之后，检查<code>user</code>的属性以确保它被正确创建。</p>
<h3 id="functional-test-examples">功能测试示例</h3>
<p>我们要编写的第二个测试是对<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/project/recipes/routes.py"> <em>项目/食谱/路线. py </em> </a>的功能测试，它包含了对<code>recipes</code>蓝图的查看功能。</p>
<p>由于这个测试是一个功能测试，所以应该在<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/tests/functional/test_recipes.py"><em>tests/functional/test _ recipes . py</em></a>中实现:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">project</span> <span class="kn">import</span> <span class="n">create_app</span>


<span class="k">def</span> <span class="nf">test_home_page</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN a Flask application configured for testing</span>
<span class="sd">    WHEN the '/' page is requested (GET)</span>
<span class="sd">    THEN check that the response is valid</span>
<span class="sd">    """</span>
    <span class="n">flask_app</span> <span class="o">=</span> <span class="n">create_app</span><span class="p">(</span><span class="s1">'flask_test.cfg'</span><span class="p">)</span>

    <span class="c1"># Create a test client using the Flask application configured for testing</span>
    <span class="k">with</span> <span class="n">flask_app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">test_client</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">test_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
        <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Welcome to the"</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
        <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Flask User Management Example!"</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
        <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Need an account?"</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
        <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Existing user?"</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
</code></pre></div>

<p>这个项目使用<a href="https://flask.palletsprojects.com/en/2.0.x/patterns/appfactories/">应用程序工厂模式</a>来创建Flask应用程序。因此，首先需要导入<code>create_app()</code>函数:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">project</span> <span class="kn">import</span> <span class="n">create_app</span>
</code></pre></div>

<p>测试函数<code>test_home_page()</code>以测试内容的给定时间描述开始。接下来，创建一个Flask应用程序(<code>flask_app</code>):</p>
<div class="codehilite"><pre><span/><code><span class="n">flask_app</span> <span class="o">=</span> <span class="n">create_app</span><span class="p">(</span><span class="s1">'flask_test.cfg'</span><span class="p">)</span>
</code></pre></div>

<p>为了创建合适的测试环境，Flask提供了一个<a href="https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.test_client"> test_client </a>助手。这将创建一个Flask应用程序的测试版本，我们用它来对“/”URL进行GET调用。然后，我们检查返回的状态代码是否正常(200)以及响应是否包含以下字符串:</p>
<ul>
<li>欢迎使用Flask用户管理示例！</li>
<li>需要账户吗？</li>
<li>现有用户？</li>
</ul>
<p>这些检查与我们希望用户在导航到“/”URL时看到的内容相匹配:</p>
<p><img data-src="/static/images/blog/flask/flask-pytest/flask_user_management_homepage.png" loading="lazy" class="lazyload" alt="Flask User Management Home Page" src="../Images/69cb5beb8352999636691a2f9064d604.png" data-original-src="https://testdriven.io/static/images/blog/flask/flask-pytest/flask_user_management_homepage.png"/></p>
<p>非正常功能测试的一个示例是在访问“/”URL时使用无效的HTTP方法(POST ):</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">test_home_page_post</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN a Flask application configured for testing</span>
<span class="sd">    WHEN the '/' page is is posted to (POST)</span>
<span class="sd">    THEN check that a '405' status code is returned</span>
<span class="sd">    """</span>
    <span class="n">flask_app</span> <span class="o">=</span> <span class="n">create_app</span><span class="p">(</span><span class="s1">'flask_test.cfg'</span><span class="p">)</span>

    <span class="c1"># Create a test client using the Flask application configured for testing</span>
    <span class="k">with</span> <span class="n">flask_app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">test_client</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">test_client</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">405</span>
        <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Flask User Management Example!"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
</code></pre></div>

<p>该测试检查对“/”URL的POST请求是否会导致返回错误代码405(不允许使用方法)。</p>
<p>花点时间回顾一下这两个功能测试...您是否在这两个测试函数之间看到了一些重复的代码？你是否看到了很多初始化测试函数所需状态的代码？我们可以使用夹具来解决这些问题。</p>
<h2 id="fixtures">固定装置</h2>
<p>为了以可预测和可重复的方式运行测试，fixture将测试初始化到一个已知的状态。</p>
<h3 id="xunit">xUnit</h3>
<p>编写和执行测试的经典方法遵循<a href="https://en.wikipedia.org/wiki/XUnit"> xUnit </a>类型的测试框架，其中每个测试运行如下:</p>
<ol>
<li><code>SetUp()</code></li>
<li>...运行测试用例...</li>
<li><code>TearDown()</code></li>
</ol>
<p><code>SetUp()</code>和<code>TearDown()</code>方法总是为测试套件中的每个单元测试运行。这种方法导致测试套件中的每个测试都处于相同的初始状态，这没有提供太多的灵活性。</p>
<h3 id="advantages-of-fixtures">固定装置的优点</h3>
<p>测试夹具方法比传统的安装/拆卸方法提供了更大的灵活性。</p>
<blockquote>
<p>pytest-flask 通过提供一套用于测试flask应用程序的通用夹具来方便测试Flask应用程序。这个库在本教程中没有用到，因为我想向<strong>展示</strong>如何创建支持测试Flask应用的夹具。</p>
</blockquote>
<p>首先，fixtures被定义为函数(应该有一个描述性的名称来描述它们的用途)。</p>
<p>第二，可以运行多个fixtures来设置测试功能的初始状态。事实上，固定物甚至可以调用其他固定物！因此，您可以将它们组合在一起以创建所需的状态。</p>
<p>最后，设备可以在不同的范围内运行:</p>
<ul>
<li><code>function</code> -每个测试功能运行一次(默认范围)</li>
<li><code>class</code> -每个测试类运行一次</li>
<li><code>module</code> -每个模块运行一次(例如，一个测试文件)</li>
<li><code>session</code> -每个会话运行一次</li>
</ul>
<p>例如，如果您有一个模块范围的fixture，那么在模块中的测试函数运行之前，该fixture将运行一次(且仅运行一次)。</p>
<blockquote>
<p>夹具应该在<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/tests/conftest.py"><em>tests/conftest . py</em></a>中创建。</p>
</blockquote>
<h3 id="unit-test-example_1">单元测试示例</h3>
<p>为了帮助测试<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/project/models.py"> <em>项目/models.py </em> </a>中的<code>User</code>类，我们可以向<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/tests/conftest.py#L6"><em>tests/conftest . py</em></a>添加一个fixture，用于创建一个<code>User</code>对象进行测试:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">project.models</span> <span class="kn">import</span> <span class="n">User</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s1">'module'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">new_user</span><span class="p">():</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s1">'<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ccbcadb8a7a9a2a2a9a8b5fbf58caba1ada5a0e2afa3a1">[email protected]</a>'</span><span class="p">,</span> <span class="s1">'FlaskIsAwesome'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">user</span>
</code></pre></div>

<p><code>@pytest.fixture</code>装饰器指定这个函数是一个具有<code>module</code>级作用域的fixture。换句话说，这个夹具将被称为每个测试模块一个。</p>
<p>这个fixture，<code>new_user</code>，使用构造函数的有效参数创建了一个<code>User</code>的实例。<code>user</code>然后被传递给测试函数(<code>return user</code>)。</p>
<p>我们可以通过使用<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/tests/unit/test_models.py#L22"><em>tests/unit/test _ models . py</em></a>中的<code>new_user</code> fixture来简化前面的<code>test_new_user()</code>测试函数:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">test_new_user_with_fixture</span><span class="p">(</span><span class="n">new_user</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN a User model</span>
<span class="sd">    WHEN a new User is created</span>
<span class="sd">    THEN check the email, hashed_password, authenticated, and role fields are defined correctly</span>
<span class="sd">    """</span>
    <span class="k">assert</span> <span class="n">new_user</span><span class="o">.</span><span class="n">email</span> <span class="o">==</span> <span class="s1">'<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7b0b1a0f101e15151e1f024c423b1c161a121755181416">[email protected]</a>'</span>
    <span class="k">assert</span> <span class="n">new_user</span><span class="o">.</span><span class="n">hashed_password</span> <span class="o">!=</span> <span class="s1">'FlaskIsAwesome'</span>
    <span class="k">assert</span> <span class="n">new_user</span><span class="o">.</span><span class="n">role</span> <span class="o">==</span> <span class="s1">'user'</span>
</code></pre></div>

<p>通过使用fixture，测试函数被简化为针对<code>User</code>对象执行检查的<code>assert</code>语句。</p>
<h3 id="functional-test-examples_1">功能测试示例</h3>
<h4 id="fixture">固定装置</h4>
<p>为了帮助测试Flask项目中的所有视图函数，可以在<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/tests/conftest.py#L12"><em>tests/conftest . py</em></a>中创建一个fixture:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">project</span> <span class="kn">import</span> <span class="n">create_app</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s1">'module'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_client</span><span class="p">():</span>
    <span class="n">flask_app</span> <span class="o">=</span> <span class="n">create_app</span><span class="p">(</span><span class="s1">'flask_test.cfg'</span><span class="p">)</span>

    <span class="c1"># Create a test client using the Flask application configured for testing</span>
    <span class="k">with</span> <span class="n">flask_app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">testing_client</span><span class="p">:</span>
        <span class="c1"># Establish an application context</span>
        <span class="k">with</span> <span class="n">flask_app</span><span class="o">.</span><span class="n">app_context</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">testing_client</span>  <span class="c1"># this is where the testing happens!</span>
</code></pre></div>

<p>这个fixture使用上下文管理器创建测试客户机:</p>
<div class="codehilite"><pre><span/><code><span class="k">with</span> <span class="n">flask_app</span><span class="o">.</span><span class="n">test_client</span><span class="p">()</span> <span class="k">as</span> <span class="n">testing_client</span><span class="p">:</span>
</code></pre></div>

<p>接下来，应用程序上下文被推送到堆栈上，供测试函数使用:</p>
<div class="codehilite"><pre><span/><code><span class="k">with</span> <span class="n">flask_app</span><span class="o">.</span><span class="n">app_context</span><span class="p">():</span>
    <span class="k">yield</span> <span class="n">testing_client</span>  <span class="c1"># this is where the testing happens!</span>
</code></pre></div>

<blockquote>
<p>要了解Flask中应用程序上下文的更多信息，请参考以下博客文章:</p>

</blockquote>
<p><code>yield testing_client</code>语句意味着执行被传递给测试函数。</p>
<h4 id="using-the-fixture">使用夹具</h4>
<p>我们可以用<a href="https://gitlab.com/patkennedy79/flask_user_management_example/-/blob/main/tests/functional/test_recipes.py#L43"><em>tests/functional/test _ recipes . py</em></a>中的<code>test_client</code> fixture来简化之前的功能测试:</p>
<div class="codehilite"><pre><span/><code><span class="k">def</span> <span class="nf">test_home_page_with_fixture</span><span class="p">(</span><span class="n">test_client</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN a Flask application configured for testing</span>
<span class="sd">    WHEN the '/' page is requested (GET)</span>
<span class="sd">    THEN check that the response is valid</span>
<span class="sd">    """</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">test_client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">200</span>
    <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Welcome to the"</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
    <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Flask User Management Example!"</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
    <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Need an account?"</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
    <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Existing user?"</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>


<span class="k">def</span> <span class="nf">test_home_page_post_with_fixture</span><span class="p">(</span><span class="n">test_client</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    GIVEN a Flask application</span>
<span class="sd">    WHEN the '/' page is is posted to (POST)</span>
<span class="sd">    THEN check that a '405' status code is returned</span>
<span class="sd">    """</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">test_client</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="mi">405</span>
    <span class="k">assert</span> <span class="sa">b</span><span class="s2">"Flask User Management Example!"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span>
</code></pre></div>

<p>您是否注意到许多重复的代码都不见了？通过利用<code>test_client</code> fixture，每个测试函数都被简化为HTTP调用(GET或POST)和检查响应的断言。</p>
<p>我真的发现使用fixture有助于将测试功能集中在实际的测试上，因为测试初始化是在fixture中处理的。</p>
<h3 id="running-the-tests">运行测试</h3>
<p>要运行测试，导航到Flask项目的顶层文件夹，并通过Python解释器运行pytest:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m <span class="nv">pytest</span>
<span class="o">=============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">==============================</span>

tests/functional/test_recipes.py ....                                    <span class="o">[</span> <span class="m">30</span>%<span class="o">]</span>
tests/functional/test_users.py .....                                     <span class="o">[</span> <span class="m">69</span>%<span class="o">]</span>
tests/unit/test_models.py ....                                           <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span> <span class="m">13</span> passed <span class="k">in</span> <span class="m">0</span>.46s <span class="o">==============================</span>
</code></pre></div>

<blockquote>
<p>为什么要通过Python解释器运行pytest？</p>
<p>主要优点是当前目录(例如，Flask项目的顶层文件夹)被添加到系统路径中。这避免了pytest找不到源代码的任何问题。</p>
</blockquote>
<p>pytest将递归地搜索您的项目结构，找到以<code>test_*.py</code>开头的Python文件，然后在这些文件中运行以<code>test_</code>开头的函数。不需要配置来识别测试文件的位置！</p>
<p>要查看已运行测试的更多详细信息:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest -v
<span class="o">=============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">==============================</span>

tests/functional/test_recipes.py::test_home_page PASSED                  <span class="o">[</span>  <span class="m">7</span>%<span class="o">]</span>
tests/functional/test_recipes.py::test_home_page_post PASSED             <span class="o">[</span> <span class="m">15</span>%<span class="o">]</span>
tests/functional/test_recipes.py::test_home_page_with_fixture PASSED     <span class="o">[</span> <span class="m">23</span>%<span class="o">]</span>
tests/functional/test_recipes.py::test_home_page_post_with_fixture PASSED <span class="o">[</span> <span class="m">30</span>%<span class="o">]</span>
tests/functional/test_users.py::test_login_page PASSED                   <span class="o">[</span> <span class="m">38</span>%<span class="o">]</span>
tests/functional/test_users.py::test_valid_login_logout PASSED           <span class="o">[</span> <span class="m">46</span>%<span class="o">]</span>
tests/functional/test_users.py::test_invalid_login PASSED                <span class="o">[</span> <span class="m">53</span>%<span class="o">]</span>
tests/functional/test_users.py::test_valid_registration PASSED           <span class="o">[</span> <span class="m">61</span>%<span class="o">]</span>
tests/functional/test_users.py::test_invalid_registration PASSED         <span class="o">[</span> <span class="m">69</span>%<span class="o">]</span>
tests/unit/test_models.py::test_new_user PASSED                          <span class="o">[</span> <span class="m">76</span>%<span class="o">]</span>
tests/unit/test_models.py::test_new_user_with_fixture PASSED             <span class="o">[</span> <span class="m">84</span>%<span class="o">]</span>
tests/unit/test_models.py::test_setting_password PASSED                  <span class="o">[</span> <span class="m">92</span>%<span class="o">]</span>
tests/unit/test_models.py::test_user_id PASSED                           <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span> <span class="m">13</span> passed <span class="k">in</span> <span class="m">0</span>.62s <span class="o">==============================</span>
</code></pre></div>

<p>如果您只想运行特定类型的测试:</p>
<ul>
<li><code>python -m pytest tests/unit/</code></li>
<li><code>python -m pytest tests/functional/</code></li>
</ul>
<h3 id="fixtures-in-action">运行中的装置</h3>
<p>为了真正了解什么时候运行<code>test_client()</code> fixture，pytest可以提供fixture和test的调用结构，并带有<code>--setup-show</code>参数:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest --setup-show tests/functional/test_recipes.py
<span class="o">======================================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">=====================================</span>

tests/functional/test_recipes.py
  ...
  SETUP    M test_client
      functional/test_recipes.py::test_home_page_with_fixture <span class="o">(</span>fixtures used: test_client<span class="o">)</span>.
      functional/test_recipes.py::test_home_page_post_with_fixture <span class="o">(</span>fixtures used: test_client<span class="o">)</span>.
  TEARDOWN M <span class="nv">test_client</span>

<span class="o">=======================================</span> <span class="m">4</span> passed <span class="k">in</span> <span class="m">0</span>.18s <span class="o">======================================</span>
</code></pre></div>

<p><code>test_client</code> fixture有一个“模块”范围，所以它在<em>tests/functional/test _ recipes . py</em>中的两个<em> _with_fixture </em>测试之前执行。</p>
<p>如果您将<code>test_client</code>夹具的范围更改为“功能”范围:</p>
<div class="codehilite"><pre><span/><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s1">'function'</span><span class="p">)</span>
</code></pre></div>

<p>然后<code>test_client</code>夹具将在两个<em> _with_fixture </em>测试之前运行:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest --setup-show tests/functional/test_recipes.py
<span class="o">=======================================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">======================================</span>

tests/functional/test_recipes.py
        ...
        SETUP    F test_client
        functional/test_recipes.py::test_home_page_with_fixture <span class="o">(</span>fixtures used: test_client<span class="o">)</span>.
        TEARDOWN F test_client
        SETUP    F test_client
        functional/test_recipes.py::test_home_page_post_with_fixture <span class="o">(</span>fixtures used: test_client<span class="o">)</span>.
        TEARDOWN F <span class="nv">test_client</span>

<span class="o">========================================</span> <span class="m">4</span> passed <span class="k">in</span> <span class="m">0</span>.21s <span class="o">=======================================</span>
</code></pre></div>

<p>因为我们希望<code>test_client</code> fixture在这个模块中只运行一次，所以将作用域恢复为“module”。</p>
<h2 id="code-coverage">代码覆盖率</h2>
<p>在开发测试时，最好能了解实际测试了多少源代码。这个概念被称为<a href="https://en.wikipedia.org/wiki/Code_coverage">代码覆盖率</a>。</p>
<blockquote>
<p>我需要非常明确的是，拥有一组覆盖100%源代码的测试并不意味着代码得到了正确的测试。</p>
<p>这个标准意味着有大量的测试，并且在开发测试上投入了大量的精力。测试的质量仍然需要通过代码检查来检查。</p>
<p>也就是说，另一个极端，这是一个最小集合(或者没有！)的测试，要糟糕得多！</p>
</blockquote>
<p>有两个优秀的包可以用来确定代码覆盖率:<a href="https://coverage.readthedocs.io"> coverage.py </a>和<a href="https://pytest-cov.readthedocs.io/en/latest/"> pytest-cov </a>。</p>
<blockquote>
<p>我推荐使用pytest-cov，因为它与pytest无缝集成。它构建在来自Ned Batchelder的coverage.py之上，这是Python代码覆盖率的标准。</p>
</blockquote>
<p>在检查代码覆盖率时运行pytest需要使用<code>--cov</code>参数来指示要检查哪个Python包(Flask项目结构中的<code>project</code>)的覆盖率:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest --cov<span class="o">=</span><span class="nv">project</span>
<span class="o">=============================</span> <span class="nb">test</span> session <span class="nv">starts</span> <span class="o">==============================</span>

tests/functional/test_recipes.py ....                                    <span class="o">[</span> <span class="m">30</span>%<span class="o">]</span>
tests/functional/test_users.py .....                                     <span class="o">[</span> <span class="m">69</span>%<span class="o">]</span>
tests/unit/test_models.py ....                                           <span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

---------- coverage: platform darwin, python <span class="m">3</span>.8.5-final-0 -----------
Name                          Stmts   Miss  Cover
-------------------------------------------------
project/__init__.py              <span class="m">27</span>      <span class="m">0</span>   <span class="m">100</span>%
project/models.py                <span class="m">32</span>      <span class="m">2</span>    <span class="m">94</span>%
project/recipes/__init__.py       <span class="m">3</span>      <span class="m">0</span>   <span class="m">100</span>%
project/recipes/routes.py         <span class="m">5</span>      <span class="m">0</span>   <span class="m">100</span>%
project/users/__init__.py         <span class="m">3</span>      <span class="m">0</span>   <span class="m">100</span>%
project/users/forms.py           <span class="m">18</span>      <span class="m">1</span>    <span class="m">94</span>%
project/users/routes.py          <span class="m">50</span>      <span class="m">4</span>    <span class="m">92</span>%
-------------------------------------------------
TOTAL                           <span class="m">138</span>      <span class="m">7</span>    <span class="m">95</span>%

<span class="o">==============================</span> <span class="m">13</span> passed <span class="k">in</span> <span class="m">0</span>.86s <span class="o">==============================</span>
</code></pre></div>

<p>即使在检查代码覆盖率时，参数仍然可以传递给pytest:</p>
<div class="codehilite"><pre><span/><code><span class="o">(</span>venv<span class="o">)</span>$ python -m pytest --setup-show --cov<span class="o">=</span>project
</code></pre></div>

<h2 id="conclusion">结论</h2>
<p>这篇文章作为测试烧瓶应用程序的指南，重点关注:</p>
<ul>
<li>为什么您应该编写测试</li>
<li>你应该测试什么</li>
<li>如何编写单元和功能测试</li>
<li>如何使用pytest运行测试</li>
<li>如何创建夹具来初始化测试功能的状态</li>
</ul>
<blockquote>
<p>如果您有兴趣了解有关Flask的更多信息，请查看我关于如何构建、测试和部署Flask应用程序的课程:</p>
<p><a href="/courses/learn-flask/">用Python和Flask开发Web应用</a></p>
</blockquote>
  </div>

  </div>    
</body>
</html>