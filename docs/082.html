<html>
<head>
<title>Serving a Machine Learning Model with FastAPI and Streamlit </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用FastAPI和Streamlit为机器学习模型提供服务</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/fastapi-streamlit/#0001-01-01">https://testdriven.io/blog/fastapi-streamlit/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>机器学习是目前的热门话题。随着科技公司朝着人工智能和机器学习的方向发展，以尽早兑现，该领域已经变得非常大。这些公司中的许多都创建了自己的机器学习解决方案，并使用基于订阅的模式将其出售给其他人。</p>
<p>由于大多数机器学习模型都是用Python开发的，因此为它们提供服务的web框架通常也是基于Python的。很长一段时间，Flask这个微框架就是goto框架。但这种情况正在改变。一个旨在弥补Flask几乎所有不足的新框架正变得越来越流行。它叫做<a href="https://fastapi.tiangolo.com/"> FastAPI </a>。</p>
<p>FastAPI比Flask快，因为它将异步函数处理程序带到了表中:</p>
<p><img data-src="/static/images/blog/fastapi/fastapi-streamlit/speed.png" loading="lazy" class="lazyload" alt="Web Framework Benchmarks" src="../Images/e21e91c3b79413f377a2dd5e2fc52caf.png" data-original-src="https://testdriven.io/static/images/blog/fastapi/fastapi-streamlit/speed.png"/></p>
<p><small>来源:<a href="https://www.techempower.com/benchmarks/#section=data-r19&amp;hw=ph&amp;test=fortune"> TechEmpower Web框架基准</a> </small></p>
<p>从上图可以看出，FastAPI几乎比Flask快3倍。</p>
<blockquote>
<p>第三个位置由<a href="https://www.starlette.io/">小明星</a>担任，FastAPI就是建立在这个位置上的。</p>
</blockquote>
<p>FastAPI还支持通过<a href="https://pydantic-docs.helpmanual.io/"> pydantic </a>和<a href="https://fastapi.tiangolo.com/features/#automatic-docs">自动API文档</a>进行数据验证。</p>
<blockquote>
<p>查看官方文档中的<a href="https://fastapi.tiangolo.com/features/">功能</a>指南，了解更多信息。我们也鼓励大家回顾一下<a href="https://fastapi.tiangolo.com/alternatives/">的替代方案、灵感和比较</a>，其中详细介绍了FastAPI与其他web框架和技术的比较。</p>
</blockquote>
<p>与此同时，Streamlit是一个应用程序框架，使数据科学家和机器学习工程师可以轻松创建与机器学习模型交互的强大用户界面。</p>
<blockquote>
<p>虽然Streamlit可以用于生产，但它最适合快速原型制作。通过使用FastAPI提供模型，在原型获得批准后，您可以使用Dash或React快速转移到生产就绪的UI。</p>
</blockquote>
<p>这样，我们将基于实时风格转换的<a href="https://cs.stanford.edu/people/jcjohns/eccv16/">感知损失和超分辨率</a>论文以及<a href="https://web.eecs.umich.edu/~justincj/">贾斯廷·约翰逊</a>的<a href="https://github.com/jcjohnson/fast-neural-style">预训练模型</a>构建一个<a href="https://en.wikipedia.org/wiki/Neural_Style_Transfer">风格转换</a>应用程序。我们将使用FastAPI作为后端来服务我们的预测，Streamlit用于用户界面，而<a href="https://en.wikipedia.org/wiki/OpenCV"> OpenCV </a>用于进行实际的预测。Docker也将被使用。</p>
<blockquote>
<p>OpenCV的深度神经网络(DNN)模块的一个强大功能是，它可以从Torch、TensorFlow和Caffe加载训练好的模型，有效地节省了我们安装这些依赖项的麻烦。</p>
</blockquote>



<h2 id="objectives">目标</h2>
<p>本教程结束时，您将能够:</p>
<ol>
<li>用Python和FastAPI开发异步API</li>
<li>用FastAPI提供机器学习模型</li>
<li>使用Streamlit开发用户界面</li>
<li>用Docker容器化FastAPI和简化it</li>
<li>利用asyncio在请求/响应流之外的后台执行代码</li>
</ol>
<h2 id="project-setup">项目设置</h2>
<p>创建名为“style-transfer”的项目文件夹:</p>
<div class="codehilite"><pre><span/><code>$ mkdir style-transfer
$ <span class="nb">cd</span> style-transfer
</code></pre></div>

<p>然后，用“style-transfer”新建两个文件夹:</p>
<div class="codehilite"><pre><span/><code>$ mkdir frontend
$ mkdir backend
</code></pre></div>

<p>添加<em> __init__。py </em>文件到每个文件夹。</p>
<h2 id="fastapi-backend">FastAPI Backend</h2>
<p>向“后端”添加一个名为<em> main.py </em>的新文件:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># backend/main.py</span>

<span class="kn">import</span> <span class="nn">uuid</span>

<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">uvicorn</span>
<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">File</span>
<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>
<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">UploadFile</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="kn">import</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">inference</span>


<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">read_root</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"message"</span><span class="p">:</span> <span class="s2">"Welcome from the API"</span><span class="p">}</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/</span><span class="si">{style}</span><span class="s2">"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_image</span><span class="p">(</span><span class="n">style</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="n">UploadFile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="o">...</span><span class="p">)):</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">file</span><span class="p">))</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">STYLES</span><span class="p">[</span><span class="n">style</span><span class="p">]</span>
    <span class="n">output</span><span class="p">,</span> <span class="n">resized</span> <span class="o">=</span> <span class="n">inference</span><span class="o">.</span><span class="n">inference</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"/storage/</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span><span class="si">}</span><span class="s2">.jpg"</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"name"</span><span class="p">:</span> <span class="n">name</span><span class="p">}</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">uvicorn</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s2">"main:app"</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s2">"0.0.0.0"</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8080</span><span class="p">)</span>
</code></pre></div>

<p>这是我们的服务器。FastAPI创建了两个端点，一个是虚拟的(<code>"/"</code>)，另一个是为我们的预测服务的(<code>"/{style}"</code>)。服务端点接受一个名称作为URL参数。我们使用九个不同的训练模型来执行风格转换，因此path参数会告诉我们选择哪个模型。该图像通过POST请求作为文件被接受，并发送给<code>inference</code>函数。一旦推理完成，文件就存储在本地文件系统中，路径作为响应发送。</p>
<p>接下来，将以下配置添加到名为<em> backend/config.py </em>的新文件中:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># backend/config.py</span>

<span class="n">MODEL_PATH</span> <span class="o">=</span> <span class="s2">"./models/"</span>

<span class="n">STYLES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"candy"</span><span class="p">:</span> <span class="s2">"candy"</span><span class="p">,</span>
    <span class="s2">"composition 6"</span><span class="p">:</span> <span class="s2">"composition_vii"</span><span class="p">,</span>
    <span class="s2">"feathers"</span><span class="p">:</span> <span class="s2">"feathers"</span><span class="p">,</span>
    <span class="s2">"la_muse"</span><span class="p">:</span> <span class="s2">"la_muse"</span><span class="p">,</span>
    <span class="s2">"mosaic"</span><span class="p">:</span> <span class="s2">"mosaic"</span><span class="p">,</span>
    <span class="s2">"starry night"</span><span class="p">:</span> <span class="s2">"starry_night"</span><span class="p">,</span>
    <span class="s2">"the scream"</span><span class="p">:</span> <span class="s2">"the_scream"</span><span class="p">,</span>
    <span class="s2">"the wave"</span><span class="p">:</span> <span class="s2">"the_wave"</span><span class="p">,</span>
    <span class="s2">"udnie"</span><span class="p">:</span> <span class="s2">"udnie"</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>

<p>引入时，风格转移是一个游戏改变者。唯一的缺点是，必须对图像进行训练以获得一种风格。这意味着，要得到一个有风格的图像，你需要在得到一个更好的结果之前多次运行原始图像。2016年，<a href="https://cs.stanford.edu/people/jcjohns/eccv16/">实时风格传输和超分辨率的感知损失</a>论文介绍了快速风格传输，这意味着你可以在一次通过中对任何图像进行风格化。我们将对作者提供的经过训练的模型使用相同的技术。</p>
<p>现在，我们需要下载模型。向名为<em> download_models.sh </em>的项目根目录添加一个脚本:</p>
<div class="codehilite"><pre><span/><code><span class="nv">BASE_URL</span><span class="o">=</span><span class="s2">"https://cs.stanford.edu/people/jcjohns/fast-neural-style/models/"</span>

mkdir -p backend/models/
<span class="nb">cd</span> backend/models/
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/instance_norm/candy.t7"</span>
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/instance_norm/la_muse.t7"</span>
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/instance_norm/mosaic.t7"</span>
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/instance_norm/feathers.t7"</span>
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/instance_norm/the_scream.t7"</span>
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/instance_norm/udnie.t7"</span>
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/eccv16/the_wave.t7"</span>
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/eccv16/starry_night.t7"</span>
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/eccv16/la_muse.t7"</span>
curl -O <span class="s2">"</span><span class="nv">$BASE_URL</span><span class="s2">/eccv16/composition_vii.t7"</span>
</code></pre></div>

<p>下载:</p>


<p>将<code>inference</code>函数添加到<em> backend/inference.py </em>:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># backend/inference.py</span>

<span class="kn">import</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">cv2</span>


<span class="k">def</span> <span class="nf">inference</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
    <span class="n">model_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">MODEL_PATH</span><span class="si">}{</span><span class="n">model</span><span class="si">}</span><span class="s2">.t7"</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">dnn</span><span class="o">.</span><span class="n">readNetFromTorch</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>

    <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">new_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">640</span> <span class="o">/</span> <span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span>
    <span class="n">resized_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">new_width</span><span class="p">,</span> <span class="mi">640</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_AREA</span><span class="p">)</span>

    <span class="c1"># Create our blob from the image</span>
    <span class="c1"># Then perform a forward pass run of the network</span>
    <span class="c1"># The Mean values for the ImageNet training set are R=103.93, G=116.77, B=123.68</span>

    <span class="n">inp_blob</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">dnn</span><span class="o">.</span><span class="n">blobFromImage</span><span class="p">(</span>
        <span class="n">resized_image</span><span class="p">,</span>
        <span class="mf">1.0</span><span class="p">,</span>
        <span class="p">(</span><span class="n">new_width</span><span class="p">,</span> <span class="mi">640</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">103.93</span><span class="p">,</span> <span class="mf">116.77</span><span class="p">,</span> <span class="mf">123.68</span><span class="p">),</span>
        <span class="n">swapRB</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">crop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">model</span><span class="o">.</span><span class="n">setInput</span><span class="p">(</span><span class="n">inp_blob</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>

    <span class="c1"># Reshape the output Tensor,</span>
    <span class="c1"># add back the mean substruction,</span>
    <span class="c1"># re-order the channels</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">103.93</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">116.77</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">123.68</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">resized_image</span>
</code></pre></div>

<p>这里，我们加载了Torch模型，执行了大小调整，并将其转换为所需的blob格式。然后，我们将预处理后的图像传递到网络/模型中，并获得输出。后处理的图像和调整大小的图像作为输出返回。</p>
<p>最后，将依赖项添加到需求文件中:</p>
<div class="codehilite"><pre><span/><code># backend/requirements.txt

fastapi
numpy
opencv-python
pillow
python-multipart
uvicorn
</code></pre></div>

<p>后端到此为止。让我们配置Docker，然后进行测试。</p>
<h2 id="docker-setup">Docker设置</h2>
<p>首先，将一个<em> Dockerfile </em>添加到“后端”文件夹:</p>
<div class="codehilite"><pre><span/><code><span class="c"># backend/Dockerfile</span>

<span class="k">FROM</span><span class="w"> </span><span class="s">python:3.10.1-slim</span>

<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app</span>

<span class="k">RUN</span><span class="w"> </span>apt-get update
<span class="k">RUN</span><span class="w"> </span>apt-get install <span class="se">\</span>
    <span class="s1">'ffmpeg'</span><span class="se">\</span>
    <span class="s1">'libsm6'</span><span class="se">\</span>
    <span class="s1">'libxext6'</span>  -y

<span class="k">COPY</span><span class="w"> </span>requirements.txt .
<span class="k">RUN</span><span class="w"> </span>pip install -r requirements.txt

<span class="k">COPY</span><span class="w"> </span>. .

<span class="k">EXPOSE</span><span class="w"> </span><span class="s">8080</span>

<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">"python"</span><span class="p">,</span><span class="w"> </span><span class="s2">"main.py"</span><span class="p">]</span>
</code></pre></div>

<blockquote>
<p>OpenCV需要ffmpeg '，' libsm6 '和' libxext6 '。</p>
</blockquote>
<p>从终端的“后端”文件夹中，构建映像:</p>
<div class="codehilite"><pre><span/><code>$ docker build -t backend .
</code></pre></div>

<p>运行容器:</p>
<div class="codehilite"><pre><span/><code>$ docker run -p <span class="m">8080</span>:8080 backend

INFO:     Started server process <span class="o">[</span><span class="m">1</span><span class="o">]</span>
INFO:     Waiting <span class="k">for</span> application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8080 <span class="o">(</span>Press CTRL+C to quit<span class="o">)</span>
</code></pre></div>

<p>在浏览器中，导航至<a href="http://localhost:8080/"> http://localhost:8080/ </a>。您应该看到:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Welcome from the API"</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>完成后杀死容器。</p>
<h2 id="streamlit-frontend">细流前端</h2>
<p>对于UI，添加一个<em> main.py </em>文件到“前端”文件夹:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># frontend/main.py</span>

<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">streamlit</span> <span class="k">as</span> <span class="nn">st</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="n">STYLES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"candy"</span><span class="p">:</span> <span class="s2">"candy"</span><span class="p">,</span>
    <span class="s2">"composition 6"</span><span class="p">:</span> <span class="s2">"composition_vii"</span><span class="p">,</span>
    <span class="s2">"feathers"</span><span class="p">:</span> <span class="s2">"feathers"</span><span class="p">,</span>
    <span class="s2">"la_muse"</span><span class="p">:</span> <span class="s2">"la_muse"</span><span class="p">,</span>
    <span class="s2">"mosaic"</span><span class="p">:</span> <span class="s2">"mosaic"</span><span class="p">,</span>
    <span class="s2">"starry night"</span><span class="p">:</span> <span class="s2">"starry_night"</span><span class="p">,</span>
    <span class="s2">"the scream"</span><span class="p">:</span> <span class="s2">"the_scream"</span><span class="p">,</span>
    <span class="s2">"the wave"</span><span class="p">:</span> <span class="s2">"the_wave"</span><span class="p">,</span>
    <span class="s2">"udnie"</span><span class="p">:</span> <span class="s2">"udnie"</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># https://discuss.streamlit.io/t/version-0-64-0-deprecation-warning-for-st-file-uploader-decoding/4465</span>
<span class="n">st</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s2">"deprecation.showfileUploaderEncoding"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="c1"># defines an h1 header</span>
<span class="n">st</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Style transfer web app"</span><span class="p">)</span>

<span class="c1"># displays a file uploader widget</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">file_uploader</span><span class="p">(</span><span class="s2">"Choose an image"</span><span class="p">)</span>

<span class="c1"># displays the select widget for the styles</span>
<span class="n">style</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">selectbox</span><span class="p">(</span><span class="s2">"Choose the style"</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">STYLES</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

<span class="c1"># displays a button</span>
<span class="k">if</span> <span class="n">st</span><span class="o">.</span><span class="n">button</span><span class="p">(</span><span class="s2">"Style Transfer"</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">style</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"file"</span><span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="sa">f</span><span class="s2">"http://backend:8080/</span><span class="si">{</span><span class="n">style</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">)</span>
        <span class="n">img_path</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"name"</span><span class="p">))</span>
        <span class="n">st</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
</code></pre></div>

<p>注意上面的代码注释。简而言之，我们创建了一个上传图像小部件和一个显示来自<code>STYLES</code>字典的每种样式的选择下拉列表。我们还添加了一个按钮，当按下该按钮时，会将图像作为POST请求负载发送到后端的<code>http://backend:8080/{style}</code>。在从后端接收到响应中的图像路径时，图像被打开并显示。</p>
<blockquote>
<p>参考Streamlit的<a href="https://docs.streamlit.io/en/stable/getting_started.html">入门</a>指南和<a href="https://docs.streamlit.io/en/stable/api.html"> API参考</a>以获得显示文本和数据以及添加与小部件的基本交互的帮助。</p>
</blockquote>
<p>将<a href="https://pypi.org/project/streamlit/"> Streamlit依赖关系</a>添加到<em> requirements.txt </em>文件中:</p>
<div class="codehilite"><pre><span/><code># frontend/requirements.txt

streamlit==1.2.0
</code></pre></div>

<h2 id="docker-compose">复合坞站</h2>
<p>接下来，让我们对接前端，并用Docker Compose将两个容器连接在一起。</p>
<p><em>前端/Dockerfile </em>:</p>
<div class="codehilite"><pre><span/><code><span class="c"># frontend/Dockerfile</span>

<span class="k">FROM</span><span class="w"> </span><span class="s">python:3.10.1-slim</span>

<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app</span>

<span class="k">COPY</span><span class="w"> </span>requirements.txt .
<span class="k">RUN</span><span class="w"> </span>pip install -r requirements.txt

<span class="k">COPY</span><span class="w"> </span>. .

<span class="k">EXPOSE</span><span class="w"> </span><span class="s">8501</span>

<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">"streamlit"</span><span class="p">,</span><span class="w"> </span><span class="s2">"run"</span><span class="p">,</span><span class="w"> </span><span class="s2">"main.py"</span><span class="p">]</span>
</code></pre></div>

<p><em>码头-化合物. yml </em>:</p>
<div class="codehilite"><pre><span/><code><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">'3'</span><span class="w"/>

<span class="nt">services</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">frontend</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">frontend</span><span class="w"/>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8501:8501</span><span class="w"/>
<span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">backend</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">        </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./storage:/storage</span><span class="w"/>
<span class="w">  </span><span class="nt">backend</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">backend</span><span class="w"/>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">8080:8080</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./storage:/storage</span><span class="w"/>
</code></pre></div>

<p>这里最重要的是，我们将主机的存储映射到每个容器的存储。这对于共享路径很重要，对于在容器旋转时持久化数据也很重要。</p>
<p>因此，后端和前端都可以从同一个共享卷访问映像:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># backend</span>
<span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"/storage/</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span><span class="si">}</span><span class="s2">.jpg"</span>
<span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
<span class="k">return</span> <span class="p">{</span><span class="s2">"name"</span><span class="p">:</span> <span class="n">name</span><span class="p">}</span>

<span class="c1"># frontend</span>
<span class="n">img_path</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"name"</span><span class="p">))</span>
</code></pre></div>

<p>要进行测试，从项目根目录开始，构建映像并启动两个容器:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose up -d --build
</code></pre></div>

<p>导航到<a href="http://localhost:8501"> http://localhost:8501 </a>:</p>
<p><img data-src="https://j.gifs.com/ROAxyE.gif" loading="lazy" class="lazyload" alt="Demo App" src="../Images/9948958338f9a8a4f4825c51b5d981e5.png" data-original-src="https://j.gifs.com/ROAxyE.gif"/></p>
<h2 id="async-model-serving">异步模型服务</h2>
<p>既然您已经看到了如何使用FastAPI、Streamlit和OpenCV来执行样式转换，那么让我们做一个小实验。</p>
<p>FastAPI最强大的特性之一是它支持异步函数。因此，让我们利用一个异步函数将输入图像转换成多种样式。我们将同步处理第一种样式，然后在后台处理其余模型时发回响应。</p>
<p>向<em> backend/main.py </em>添加以下函数:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># backend/main.py</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">generate_remaining_models</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">executor</span> <span class="o">=</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span>
    <span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="k">await</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
        <span class="n">executor</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">process_image</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">process_image</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
        <span class="n">output</span><span class="p">,</span> <span class="n">resized</span> <span class="o">=</span> <span class="n">inference</span><span class="o">.</span><span class="n">inference</span><span class="p">(</span><span class="n">models</span><span class="p">[</span><span class="n">model</span><span class="p">],</span> <span class="n">image</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"."</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'_'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">models</span><span class="p">[</span><span class="n">model</span><span class="p">]</span><span class="si">}</span><span class="s2">.jpg"</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
</code></pre></div>

<p><code>generate_remaining_models</code>函数使用<a href="https://docs.python.org/3/library/asyncio.html"> asyncio </a>生成其余的每种风格。</p>
<blockquote>
<p>查看<a href="/blog/concurrency-parallelism-asyncio/#asyncio">用并发性、并行性和asyncio加速Python的速度</a>一文，了解关于asyncio的更多信息。</p>
</blockquote>
<p>添加以下导入内容:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
</code></pre></div>

<p>更新<code>get_image</code>函数，以便它在发送回响应之前创建异步任务:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># backend/main.py</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/</span><span class="si">{style}</span><span class="s2">"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_image</span><span class="p">(</span><span class="n">style</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="n">UploadFile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="o">...</span><span class="p">)):</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">file</span><span class="p">))</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">STYLES</span><span class="p">[</span><span class="n">style</span><span class="p">]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">output</span><span class="p">,</span> <span class="n">resized</span> <span class="o">=</span> <span class="n">inference</span><span class="o">.</span><span class="n">inference</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"/storage/</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span><span class="si">}</span><span class="s2">.jpg"</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="n">models</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">STYLES</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">models</span><span class="p">[</span><span class="n">style</span><span class="p">]</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">generate_remaining_models</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"name"</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">"time"</span><span class="p">:</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">}</span>
</code></pre></div>

<p>一旦做出第一个预测，我们将从原始样式的副本中删除该样式。然后将剩余的样式传递给<code>generate_remaining_models</code>。</p>
<p>添加导入:</p>


<p>接下来，更新<em> frontend/main.py </em>中下面的<code>if</code>语句块:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># frontend/main.py</span>

<span class="k">if</span> <span class="n">st</span><span class="o">.</span><span class="n">button</span><span class="p">(</span><span class="s2">"Style Transfer"</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">style</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"file"</span><span class="p">:</span> <span class="n">image</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="sa">f</span><span class="s2">"http://backend:8080/</span><span class="si">{</span><span class="n">style</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">files</span><span class="p">)</span>
        <span class="n">img_path</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"name"</span><span class="p">))</span>
        <span class="n">st</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="n">displayed_styles</span> <span class="o">=</span> <span class="p">[</span><span class="n">style</span><span class="p">]</span>
        <span class="n">displayed</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">STYLES</span><span class="p">)</span>

        <span class="n">st</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"Generating other models..."</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">displayed</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">style</span> <span class="ow">in</span> <span class="n">STYLES</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">style</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">displayed_styles</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">img_path</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'name'</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">STYLES</span><span class="p">[</span><span class="n">style</span><span class="p">]</span><span class="si">}</span><span class="s2">.jpg"</span>
                        <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                        <span class="n">st</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
                        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">displayed</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">displayed_styles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">style</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
</code></pre></div>

<p>将导入添加到顶部:</p>


<p>因此，在显示了第一个样式之后，我们继续检查其余的样式，显示每一个样式，直到页面上显示了所有的九个样式。</p>
<p>更新容器并测试:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose up -d --build
</code></pre></div>

<p>现在，剩下的样式将异步显示，不会阻塞初始响应。</p>
<p><a href="https://www.youtube.com/watch?v=XblrYvlXLnA" title="Style transfer demo"><img alt="multiple style transfer" src="../Images/3e4acf86108ef2a1c037b4b7a3b5b5f7.png" data-original-src="https://yt-embed.herokuapp.com/embed?v=XblrYvlXLnA"/>T2】</a></p>
<h2 id="conclusion">结论</h2>
<p>FastAPI是Flask的一个现代异步替代方案。它有很多Flask没有的特性，而且比Flask快，因为它利用了Starlette并支持异步函数处理程序。FastAPI有很多额外的特性，比如数据验证、自动化API文档、后台任务以及一个强大的依赖注入系统。此外，由于您最有可能利用Python类型提示(因此您可以利用数据验证)，由于编辑器自动完成和自动错误检查，您将能够更快地进行开发。</p>
<p>你可以在GitHub上的<a href="https://github.com/amalshaji/style-transfer"> style-transfer </a> repo中找到最终代码。</p>
  </div>

  </div>    
</body>
</html>