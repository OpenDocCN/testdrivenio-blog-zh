<html>
<head>
<title>Building a CRUD App with FastAPI, MongoDB, and Beanie </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用FastAPI、MongoDB和Beanie构建CRUD应用程序</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/fastapi-beanie/#0001-01-01">https://testdriven.io/blog/fastapi-beanie/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>在本教程中，你将学习如何用<a href="https://fastapi.tiangolo.com/"> FastAPI </a>和<a href="https://www.mongodb.com/"> MongoDB </a>开发异步API。我们将使用<a href="https://roman-right.github.io/beanie/"> Beanie ODM </a>库与MongoDB进行异步交互。</p>



<h2 id="objectives">目标</h2>
<p>本教程结束时，您将能够:</p>
<ol>
<li>解释什么是Beanie ODM以及为什么您可能想要使用它</li>
<li>使用Beanie ODM与MongoDB异步交互</li>
<li>用Python和FastAPI开发RESTful API</li>
</ol>
<h2 id="why-beanie-odm">为什么是Beanie ODM？</h2>
<p>Beanie是MongoDB的异步对象文档映射器(ODM ),它支持开箱即用的数据和模式迁移。它使用<a href="https://motor.readthedocs.io">马达</a>作为异步数据库引擎，使用<a href="https://pydantic-docs.helpmanual.io/">活塞</a>。</p>
<p>虽然您可以简单地使用Motor，但是Beanie提供了一个额外的抽象层，使得与Mongo数据库中的集合进行交互更加容易。</p>
<blockquote>
<p>想只用电机？查看<a href="/blog/fastapi-mongo">用FastAPI和MongoDB </a>构建CRUD应用程序。</p>
</blockquote>
<h2 id="initial-setup">初始设置</h2>
<p>首先创建一个新文件夹来保存名为“fastapi-beanie”的项目:</p>
<div class="codehilite"><pre><span/><code>$ mkdir fastapi-beanie
$ <span class="nb">cd</span> fastapi-beanie
</code></pre></div>

<p>接下来，创建并激活虚拟环境:</p>
<div class="codehilite"><pre><span/><code>$ python3.10 -m venv venv
$ <span class="nb">source</span> venv/bin/activate
<span class="o">(</span>venv<span class="o">)</span>$ <span class="nb">export</span> <span class="nv">PYTHONPATH</span><span class="o">=</span><span class="nv">$PWD</span>
</code></pre></div>

<blockquote>
<p>随意把venv和Pip换成<a href="https://python-poetry.org">诗歌</a>或<a href="https://github.com/pypa/pipenv"> Pipenv </a>。更多信息，请查看<a href="/blog/python-environments/">现代Python环境</a>。</p>
</blockquote>
<p>接下来，创建以下文件和文件夹:</p>
<div class="codehilite"><pre><span/><code>├── app
│   ├── __init__.py
│   ├── main.py
│   └── server
│       ├── app.py
│       ├── database.py
│       ├── models
│       └── routes
└── requirements.txt
</code></pre></div>

<p>将以下依赖项添加到您的<em> requirements.txt </em>文件中:</p>
<div class="codehilite"><pre><span/><code>beanie==1.11.0
fastapi==0.78.0
uvicorn==0.17.6
</code></pre></div>

<p>从终端安装依赖项:</p>
<div class="codehilite"><pre><span/><code><span class="gp gp-VirtualEnv">(venv)</span><span class="gp">$ </span>pip install -r requirements.txt
</code></pre></div>

<p>在<em> app/main.py </em>文件中，定义运行应用程序的入口点:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">uvicorn</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">uvicorn</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s2">"server.app:app"</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s2">"0.0.0.0"</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8000</span><span class="p">,</span> <span class="n">reload</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p>这里，我们指示文件在端口8000上运行一个<a href="https://www.uvicorn.org/">uvicon</a>服务器，并在每次文件更改时重新加载。</p>
<p>在通过入口点文件启动服务器之前，在<em> app/server/app.py </em>中创建一个基本路由:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"Root"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_root</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"message"</span><span class="p">:</span> <span class="s2">"Welcome to your beanie powered app!"</span><span class="p">}</span>
</code></pre></div>

<p>从控制台运行入口点文件:</p>
<div class="codehilite"><pre><span/><code><span class="gp gp-VirtualEnv">(venv)</span><span class="gp">$ </span>python app/main.py
</code></pre></div>

<p>在浏览器中导航至<a href="http://localhost:8000"> http://localhost:8000 </a>。您应该看到:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Welcome to your beanie powered app!"</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<h2 id="what-are-we-building">我们在建造什么？</h2>
<p>我们将构建一个产品评论应用程序，它允许我们执行以下操作:</p>
<ul>
<li>创建评论</li>
<li>阅读评论</li>
<li>更新评论</li>
<li>删除评论</li>
</ul>
<p>在开始编写路线之前，让我们使用Beanie来配置应用程序的数据库模型。</p>
<h2 id="database-schema">数据库模式</h2>
<p>Beanie允许您创建<a href="https://roman-right.github.io/beanie/api-documentation/document/">文档</a>，这些文档可以用来与数据库中的集合进行交互。文档代表您的数据库模式。它们可以通过创建从Beanie继承<code>Document</code>类的子类来定义。<code>Document</code>类由Pydantic的<code>BaseModel</code>提供支持，这使得定义集合和数据库模式以及交互式Swagger文档页面中显示的示例数据变得容易。</p>
<p>示例:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">beanie</span> <span class="kn">import</span> <span class="n">Document</span>


<span class="k">class</span> <span class="nc">TestDrivenArticle</span><span class="p">(</span><span class="n">Document</span><span class="p">):</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">date</span><span class="p">:</span> <span class="n">datetime</span>
    <span class="n">author</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div>

<p>定义的文档表示文章将如何存储在数据库中。然而，它是一个普通的文档类，没有与之相关联的数据库集合。要关联一个集合，只需添加一个<code>Settings</code>类作为子类:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">beanie</span> <span class="kn">import</span> <span class="n">Document</span>


<span class="k">class</span> <span class="nc">TestDrivenArticle</span><span class="p">(</span><span class="n">Document</span><span class="p">):</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">date</span><span class="p">:</span> <span class="n">datetime</span>
    <span class="n">author</span><span class="p">:</span> <span class="nb">str</span>


    <span class="k">class</span> <span class="nc">Settings</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">"testdriven_collection"</span>
</code></pre></div>

<p>现在我们已经知道了模式是如何创建的，我们将为我们的应用程序创建模式。在“app/server/models”文件夹中，创建一个名为<em> product_review.py </em>的新文件:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">from</span> <span class="nn">beanie</span> <span class="kn">import</span> <span class="n">Document</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>


<span class="k">class</span> <span class="nc">ProductReview</span><span class="p">(</span><span class="n">Document</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">product</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">rating</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">review</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">date</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

    <span class="k">class</span> <span class="nc">Settings</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">"product_review"</span>
</code></pre></div>

<p>由于<code>Document</code>类是由Pydantic支持的，我们可以定义示例模式数据，使开发人员更容易从交互式Swagger文档中使用API。</p>
<p>像这样添加<code>Config</code>子类:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">from</span> <span class="nn">beanie</span> <span class="kn">import</span> <span class="n">Document</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>


<span class="k">class</span> <span class="nc">ProductReview</span><span class="p">(</span><span class="n">Document</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">product</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">rating</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">review</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">date</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

    <span class="k">class</span> <span class="nc">Settings</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">"product_review"</span>

    <span class="k">class</span> <span class="nc">Config</span><span class="p">:</span>
        <span class="n">schema_extra</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"example"</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"Abdulazeez"</span><span class="p">,</span>
                <span class="s2">"product"</span><span class="p">:</span> <span class="s2">"TestDriven TDD Course"</span><span class="p">,</span>
                <span class="s2">"rating"</span><span class="p">:</span> <span class="mf">4.9</span><span class="p">,</span>
                <span class="s2">"review"</span><span class="p">:</span> <span class="s2">"Excellent course!"</span><span class="p">,</span>
                <span class="s2">"date"</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>

<p>因此，在上面的代码块中，我们定义了一个名为<code>ProductReview</code>的Beanie文档，它表示产品评论将如何存储。我们还定义了集合<code>product_review</code>，数据将存储在其中。</p>
<p>我们将在路由中使用这个模式来实施正确的请求体。</p>
<p>最后，让我们定义更新产品评论的模式:</p>
<div class="codehilite"><pre><span/><code><span class="k">class</span> <span class="nc">UpdateProductReview</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">product</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">rating</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">review</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span>

    <span class="k">class</span> <span class="nc">Config</span><span class="p">:</span>
        <span class="n">schema_extra</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"example"</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"Abdulazeez Abdulazeez"</span><span class="p">,</span>
                <span class="s2">"product"</span><span class="p">:</span> <span class="s2">"TestDriven TDD Course"</span><span class="p">,</span>
                <span class="s2">"rating"</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>
                <span class="s2">"review"</span><span class="p">:</span> <span class="s2">"Excellent course!"</span><span class="p">,</span>
                <span class="s2">"date"</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>

<p>上面的<code>UpdateProductReview</code>类属于类型<a href="https://pydantic-docs.helpmanual.io/usage/models/"> BaseModel </a>，它允许我们只对请求体中的字段进行修改。</p>
<p>有了模式之后，让我们在继续编写路由之前设置MongoDB和我们的数据库。</p>
<h2 id="mongodb">MongoDB</h2>
<p>在这一节中，我们将连接MongoDB并配置我们的应用程序与之通信。</p>
<blockquote>
<p>据<a href="https://en.wikipedia.org/wiki/MongoDB">维基百科</a>介绍，MongoDB是一个跨平台的面向文档的数据库程序。作为一个NoSQL数据库程序，MongoDB使用带有可选模式的类似JSON的文档。</p>
</blockquote>
<h3 id="mongodb-setup">MongoDB设置</h3>
<p>如果您的机器上没有安装MongoDB，请参考文档中的<a href="https://docs.mongodb.com/manual/installation/">安装</a>指南。安装完成后，继续按照指南运行<a href="https://docs.mongodb.com/manual/reference/program/mongod/#bin.mongod"> mongod </a>守护进程。一旦完成，您就可以通过使用<code>mongo</code> shell命令连接到实例来验证MongoDB已经启动并正在运行:</p>


<p>作为参考，本教程使用MongoDB社区版v5.0.7。</p>
<div class="codehilite"><pre><span/><code><span class="gp">$ </span>mongo --version
<span class="go">MongoDB shell version v5.0.7</span>

<span class="go">Build Info: {</span>
<span class="go">    "version": "5.0.7",</span>
<span class="go">    "gitVersion": "b977129dc70eed766cbee7e412d901ee213acbda",</span>
<span class="go">    "modules": [],</span>
<span class="go">    "allocator": "system",</span>
<span class="go">    "environment": {</span>
<span class="go">        "distarch": "x86_64",</span>
<span class="go">        "target_arch": "x86_64"</span>
<span class="go">    }</span>
<span class="go">}</span>
</code></pre></div>

<h3 id="setting-up-the-database">设置数据库</h3>
<p>在<em> database.py </em>中，添加以下内容:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">beanie</span> <span class="kn">import</span> <span class="n">init_beanie</span>
<span class="kn">import</span> <span class="nn">motor.motor_asyncio</span>

<span class="kn">from</span> <span class="nn">app.server.models.product_review</span> <span class="kn">import</span> <span class="n">ProductReview</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">init_db</span><span class="p">():</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">motor</span><span class="o">.</span><span class="n">motor_asyncio</span><span class="o">.</span><span class="n">AsyncIOMotorClient</span><span class="p">(</span>
        <span class="s2">"mongodb://localhost:27017/productreviews"</span>
    <span class="p">)</span>

    <span class="k">await</span> <span class="n">init_beanie</span><span class="p">(</span><span class="n">database</span><span class="o">=</span><span class="n">client</span><span class="o">.</span><span class="n">db_name</span><span class="p">,</span> <span class="n">document_models</span><span class="o">=</span><span class="p">[</span><span class="n">ProductReview</span><span class="p">])</span>
</code></pre></div>

<p>在上面的代码块中，我们导入了<a href="https://roman-right.github.io/beanie/tutorial/initialization/"> init_beanie </a>方法，该方法负责初始化由<a href="https://motor.readthedocs.io/en/stable/api-asyncio/asyncio_motor_client.html#motor.motor_asyncio.AsyncIOMotorClient"> motor.motor_asyncio </a>驱动的数据库引擎。<code>init_beanie</code>方法有两个参数:</p>
<ol>
<li><code>database</code> -要使用的数据库的名称。</li>
<li><code>document_models</code>——定义的文档模型列表——在我们的例子中是<code>ProductReview</code>模型。</li>
</ol>
<p><code>init_db</code>函数将在应用程序启动事件中被调用。更新<em> app.py </em>以包含启动事件:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>

<span class="kn">from</span> <span class="nn">app.server.database</span> <span class="kn">import</span> <span class="n">init_db</span>


<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">"startup"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">start_db</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">init_db</span><span class="p">()</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"Root"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_root</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"message"</span><span class="p">:</span> <span class="s2">"Welcome to your beanie powered app!"</span><span class="p">}</span>
</code></pre></div>

<p>现在我们已经有了数据库配置，让我们来写路线。</p>
<h2 id="routes">路线</h2>
<p>在本节中，我们将构建从应用程序对数据库执行CRUD操作的路线:</p>
<ol>
<li>事后审查</li>
<li>获取单个评论和获取所有评论</li>
<li>提交单个评论</li>
<li>删除单个评论</li>
</ol>
<p>在“routes”文件夹中，创建名为<em> product_review.py </em>的文件:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">beanie</span> <span class="kn">import</span> <span class="n">PydanticObjectId</span>
<span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">APIRouter</span><span class="p">,</span> <span class="n">HTTPException</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="kn">from</span> <span class="nn">app.server.models.product_review</span> <span class="kn">import</span> <span class="n">ProductReview</span><span class="p">,</span> <span class="n">UpdateProductReview</span>


<span class="n">router</span> <span class="o">=</span> <span class="n">APIRouter</span><span class="p">()</span>
</code></pre></div>

<p>在上面的代码块中，我们导入了<code>PydanticObjectId</code>，它将在检索单个请求时用于类型提示ID参数。我们还导入了负责处理路由操作的<code>APIRouter</code>类。我们还导入了之前定义的模型类。</p>
<p>Beanie文档模型允许我们用更少的代码直接与数据库交互。例如，要检索数据库集合中的所有记录，我们所要做的就是:</p>
<div class="codehilite"><pre><span/><code><span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ProductReview</span><span class="o">.</span><span class="n">find_all</span><span class="p">()</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
<span class="k">return</span> <span class="n">data</span> <span class="c1"># A list of all records in the collection.</span>
</code></pre></div>

<p>在我们开始为CRUD操作编写route函数之前，让我们在<em> app.py </em>中注册路由:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>

<span class="kn">from</span> <span class="nn">app.server.database</span> <span class="kn">import</span> <span class="n">init_db</span>
<span class="kn">from</span> <span class="nn">app.server.routes.product_review</span> <span class="kn">import</span> <span class="n">router</span> <span class="k">as</span> <span class="n">Router</span>


<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>
<span class="n">app</span><span class="o">.</span><span class="n">include_router</span><span class="p">(</span><span class="n">Router</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"Product Reviews"</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">"/reviews"</span><span class="p">)</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">"startup"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">start_db</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">init_db</span><span class="p">()</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="s2">"Root"</span><span class="p">])</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_root</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"message"</span><span class="p">:</span> <span class="s2">"Welcome to your beanie powered app!"</span><span class="p">}</span>
</code></pre></div>

<h3 id="create">创造</h3>
<p>在<em> routes/product_review.py </em>中，添加以下内容:</p>
<div class="codehilite"><pre><span/><code><span class="nd">@router</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="n">response_description</span><span class="o">=</span><span class="s2">"Review added to the database"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">add_product_review</span><span class="p">(</span><span class="n">review</span><span class="p">:</span> <span class="n">ProductReview</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">await</span> <span class="n">review</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">"message"</span><span class="p">:</span> <span class="s2">"Review added successfully"</span><span class="p">}</span>
</code></pre></div>

<p>这里，我们定义了route函数，它接受一个类型为<code>ProductReview</code>的参数。如前所述，文档类可以直接与数据库交互。</p>
<p>新记录是通过调用<a href="https://roman-right.github.io/beanie/api-documentation/document/#documentcreate"> create() </a>方法创建的。</p>
<p>上面的路由需要类似的有效负载，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Abdulazeez"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"product"</span><span class="p">:</span><span class="w"> </span><span class="s2">"TestDriven TDD Course"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"rating"</span><span class="p">:</span><span class="w"> </span><span class="mf">4.9</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"review"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Excellent course!"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2022-05-17T13:53:17.196135"</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>测试路线:</p>
<div class="codehilite"><pre><span/><code>$ curl -X <span class="s1">'POST'</span> <span class="se">\</span>
  <span class="s1">'http://0.0.0.0:8000/reviews/'</span> <span class="se">\</span>
  -H <span class="s1">'accept: application/json'</span> <span class="se">\</span>
  -H <span class="s1">'Content-Type: application/json'</span> <span class="se">\</span>
  -d <span class="s1">'{</span>
<span class="s1">  "name": "Abdulazeez",</span>
<span class="s1">  "product": "TestDriven TDD Course",</span>
<span class="s1">  "rating": 4.9,</span>
<span class="s1">  "review": "Excellent course!",</span>
<span class="s1">  "date": "2022-05-17T13:53:17.196135"</span>
<span class="s1">}'</span>
</code></pre></div>

<p>上面的请求应该会返回一条成功的消息:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Review added successfully"</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<h3 id="read">阅读</h3>
<p>接下来是使我们能够检索数据库中存在的单个评论和所有评论的路线:</p>
<div class="codehilite"><pre><span/><code><span class="nd">@router</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/</span><span class="si">{id}</span><span class="s2">"</span><span class="p">,</span> <span class="n">response_description</span><span class="o">=</span><span class="s2">"Review record retrieved"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_review_record</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">PydanticObjectId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ProductReview</span><span class="p">:</span>
    <span class="n">review</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ProductReview</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">review</span>


<span class="nd">@router</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="n">response_description</span><span class="o">=</span><span class="s2">"Review records retrieved"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">get_reviews</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ProductReview</span><span class="p">]:</span>
    <span class="n">reviews</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ProductReview</span><span class="o">.</span><span class="n">find_all</span><span class="p">()</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">reviews</span>
</code></pre></div>

<p>在上面的代码块中，我们定义了两个函数:</p>
<ol>
<li>在第一个函数中，该函数接受一个类型为<code>ObjectiD</code>的ID，这是MongoDB IDs的默认编码。使用<a href="https://roman-right.github.io/beanie/api-documentation/document/#documentget"> get() </a>方法检索记录。</li>
<li>第二，我们使用<a href="https://roman-right.github.io/beanie/tutorial/finding-documents/#finding-documents"> find_all() </a>方法检索所有的评论。追加了<code>to_list()</code>方法，因此结果以列表的形式返回。</li>
</ol>
<blockquote>
<p>另一种可以用来检索单个条目的方法是采用条件的<a href="https://roman-right.github.io/beanie/tutorial/finding-documents/#finding-single-documents"> find_one() </a>方法。例如:</p><div class="codehilite"><pre><span/><code><span class="c1"># Return a record who has a rating of 4.0</span>
<span class="k">await</span> <span class="n">ProductReview</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">ProductReview</span><span class="o">.</span><span class="n">rating</span> <span class="o">==</span> <span class="mf">4.0</span><span class="p">)</span>
</code></pre></div>
</blockquote>

<p>让我们测试检索所有记录的第一条路线:</p>
<div class="codehilite"><pre><span/><code>$ curl -X <span class="s1">'GET'</span> <span class="se">\</span>
  <span class="s1">'http://0.0.0.0:8000/reviews/'</span> <span class="se">\</span>
  -H <span class="s1">'accept: application/json'</span>
</code></pre></div>

<p>回应:</p>
<div class="codehilite"><pre><span/><code><span class="p">[</span><span class="w"/>
<span class="w">  </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="nt">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"62839ad1d9a88a040663a734"</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Abdulazeez"</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nt">"product"</span><span class="p">:</span><span class="w"> </span><span class="s2">"TestDriven TDD Course"</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nt">"rating"</span><span class="p">:</span><span class="w"> </span><span class="mf">4.9</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nt">"review"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Excellent course!"</span><span class="p">,</span><span class="w"/>
<span class="w">    </span><span class="nt">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2022-05-17T13:53:17.196000"</span><span class="w"/>
<span class="w">  </span><span class="p">}</span><span class="w"/>
<span class="p">]</span><span class="w"/>
</code></pre></div>

<p>接下来，让我们测试检索与提供的ID匹配的单个记录的路径:</p>
<div class="codehilite"><pre><span/><code>$ curl -X <span class="s1">'GET'</span> <span class="se">\</span>
  <span class="s1">'http://0.0.0.0:8000/reviews/62839ad1d9a88a040663a734'</span> <span class="se">\</span>
  -H <span class="s1">'accept: application/json'</span>
</code></pre></div>

<p>回应:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"62839ad1d9a88a040663a734"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Abdulazeez"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"product"</span><span class="p">:</span><span class="w"> </span><span class="s2">"TestDriven TDD Course"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"rating"</span><span class="p">:</span><span class="w"> </span><span class="mf">4.9</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"review"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Excellent course!"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2022-05-17T13:53:17.196000"</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<h3 id="update">更新</h3>
<p>接下来，我们来写一下更新复习记录的路线:</p>
<div class="codehilite"><pre><span/><code><span class="nd">@router</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">"/</span><span class="si">{id}</span><span class="s2">"</span><span class="p">,</span> <span class="n">response_description</span><span class="o">=</span><span class="s2">"Review record updated"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">update_student_data</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">PydanticObjectId</span><span class="p">,</span> <span class="n">req</span><span class="p">:</span> <span class="n">UpdateProductReview</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ProductReview</span><span class="p">:</span>
    <span class="n">req</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">req</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
    <span class="n">update_query</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"$set"</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">field</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">req</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}}</span>

    <span class="n">review</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ProductReview</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">review</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HTTPException</span><span class="p">(</span>
            <span class="n">status_code</span><span class="o">=</span><span class="mi">404</span><span class="p">,</span>
            <span class="n">detail</span><span class="o">=</span><span class="s2">"Review record not found!"</span>
        <span class="p">)</span>

    <span class="k">await</span> <span class="n">review</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">update_query</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">review</span>
</code></pre></div>

<p>在这个函数中，我们过滤掉了没有更新的字段，以防止用<code>None</code>覆盖现有字段。</p>
<p>要更新记录，需要更新查询。我们定义了一个更新查询，用请求体中传递的数据覆盖现有字段。然后我们检查记录是否存在。如果存在，它将被更新并返回更新后的记录，否则将引发404异常。</p>
<p>让我们测试一下路线:</p>
<div class="codehilite"><pre><span/><code>$ curl -X <span class="s1">'PUT'</span> <span class="se">\</span>
  <span class="s1">'http://0.0.0.0:8000/reviews/62839ad1d9a88a040663a734'</span> <span class="se">\</span>
  -H <span class="s1">'accept: application/json'</span> <span class="se">\</span>
  -H <span class="s1">'Content-Type: application/json'</span> <span class="se">\</span>
  -d <span class="s1">'{</span>
<span class="s1">  "name": "Abdulazeez Abdulazeez",</span>
<span class="s1">  "product": "TestDriven TDD Course",</span>
<span class="s1">  "rating": 5</span>
<span class="s1">}'</span>
</code></pre></div>

<p>回应:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"62839ad1d9a88a040663a734"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Abdulazeez Abdulazeez"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"product"</span><span class="p">:</span><span class="w"> </span><span class="s2">"TestDriven TDD Course"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"rating"</span><span class="p">:</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"review"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Excellent course!"</span><span class="p">,</span><span class="w"/>
<span class="w">  </span><span class="nt">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2022-05-17T13:53:17.196000"</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<h3 id="delete">删除</h3>
<p>最后，让我们编写负责删除记录的路由:</p>
<div class="codehilite"><pre><span/><code><span class="nd">@router</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s2">"/</span><span class="si">{id}</span><span class="s2">"</span><span class="p">,</span> <span class="n">response_description</span><span class="o">=</span><span class="s2">"Review record deleted from the database"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">delete_student_data</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">PydanticObjectId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="n">record</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ProductReview</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">record</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HTTPException</span><span class="p">(</span>
            <span class="n">status_code</span><span class="o">=</span><span class="mi">404</span><span class="p">,</span>
            <span class="n">detail</span><span class="o">=</span><span class="s2">"Review record not found!"</span>
        <span class="p">)</span>

    <span class="k">await</span> <span class="n">record</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">"message"</span><span class="p">:</span> <span class="s2">"Record deleted successfully"</span>
    <span class="p">}</span>
</code></pre></div>

<p>因此，在删除记录之前，我们首先检查记录是否存在。通过调用<a href="https://roman-right.github.io/beanie/api-documentation/document/#documentdelete"> delete() </a>方法删除记录。</p>
<p>让我们测试一下路线:</p>
<div class="codehilite"><pre><span/><code>$ curl -X <span class="s1">'DELETE'</span> <span class="se">\</span>
  <span class="s1">'http://0.0.0.0:8000/reviews/62839ad1d9a88a040663a734'</span> <span class="se">\</span>
  -H <span class="s1">'accept: application/json'</span>
</code></pre></div>

<p>回应:</p>
<div class="codehilite"><pre><span/><code><span class="p">{</span><span class="w"/>
<span class="w">  </span><span class="nt">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Record deleted successfully"</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</code></pre></div>

<p>我们已经成功构建了一个由FastAPI、MongoDB和Beanie ODM支持的CRUD应用程序。</p>
<h2 id="conclusion">结论</h2>
<p>在本教程中，您学习了如何使用FastAPI、MongoDB和Beanie ODM创建CRUD应用程序。通过回顾本教程开头的目标来进行快速自检，您可以在<a href="https://github.com/Youngestdev/fastapi-beanie"> GitHub </a>上找到本教程中使用的代码。</p>
<p>想要更多吗？</p>
<ol>
<li>用pytest设置单元和集成测试。</li>
<li>添加其他路线。</li>
<li>为您的应用程序创建一个GitHub repo，并使用GitHub操作配置CI/CD。</li>
</ol>
<blockquote>
<p>查看<a href="/courses/tdd-fastapi/">测试驱动的FastAPI开发和Docker </a>课程，了解有关测试和设置FastAPI应用的CI/CD的更多信息。</p>
</blockquote>
<p>干杯！</p>
  </div>

  </div>    
</body>
</html>