<html>
<head>
<title>Web Authentication Methods Compared </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较的Web身份验证方法</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/web-authentication-methods/#0001-01-01">https://testdriven.io/blog/web-authentication-methods/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>在本文中，我们将从Python web开发人员的角度来看最常用的处理web身份验证的方法。</p>
<blockquote>
<p>虽然代码示例和资源是为Python开发人员准备的，但是每种身份验证方法的实际描述适用于所有web开发人员。</p>
</blockquote>



<h2 id="authentication-vs-authorization">身份验证与授权</h2>
<p>身份认证是对试图访问受限系统的用户或设备的凭据进行验证的过程。同时，授权是验证用户或设备是否被允许在给定系统上执行某些任务的过程。</p>
<p>简而言之:</p>
<ol>
<li>认证:<em>你是谁？</em></li>
<li>授权:<em>你能做什么？</em></li>
</ol>
<p>认证先于授权。也就是说，在根据授权级别授予用户访问资源的权限之前，用户必须是有效的。认证用户最常见的方式是通过<code>username</code>和<code>password</code>。一旦通过认证，不同的角色如<code>admin</code>、<code>moderator</code>等。分配给他们，这将授予他们系统的特权。</p>
<p>接下来，让我们来看看认证用户的不同方法。</p>
<h2 id="http-basic-authentication">HTTP基本身份验证</h2>
<p>HTTP协议中内置的基本身份验证是最基本的身份验证形式。有了它，登录凭据将在每个请求的请求头中发送:</p>
<div class="codehilite"><pre><span/><code>"Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=" your-website.com
</code></pre></div>

<p>用户名和密码不加密。相反，用户名和密码使用一个<code>:</code>符号连接在一起，形成一个字符串:<code>username:password</code>。然后，使用base64对该字符串进行编码。</p>
<div class="codehilite"><pre><span/><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">base64</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">auth</span> <span class="o">=</span> <span class="s2">"username:password"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">auth_bytes</span> <span class="o">=</span> <span class="n">auth</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">)</span> <span class="c1"># convert to bytes</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">auth_bytes</span>
<span class="sa">b</span><span class="s1">'username:password'</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">encoded</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">auth_bytes</span><span class="p">)</span> <span class="c1"># base64 encode</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">encoded</span>
<span class="sa">b</span><span class="s1">'dXNlcm5hbWU6cGFzc3dvcmQ='</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span> <span class="c1"># base64 decode</span>
<span class="sa">b</span><span class="s1">'username:password'</span>
</code></pre></div>

<p>这个方法是无状态的，所以客户端必须为每个请求提供凭证。它适用于API调用以及不需要持久会话的简单身份验证工作流。</p>
<h3 id="flow">流动</h3>
<ol>
<li>未经身份验证的客户端请求受限资源</li>
<li>HTTP 401 Unauthorized返回一个值为<code>Basic</code>的头<code>WWW-Authenticate</code>。</li>
<li><code>WWW-Authenticate: Basic</code>标题使浏览器显示用户名和密码提示</li>
<li>输入您的凭证后，它们会在每个请求的标头中发送:<code>Authorization: Basic dcdvcmQ=</code></li>
</ol>
<p><img data-src="/static/images/blog/web-authentication-methods/basic_auth.png" loading="lazy" class="lazyload" alt="http basic auth workflow" src="../Images/e88c0ee734e80bfc58aab5d98d866717.png" data-original-src="https://testdriven.io/static/images/blog/web-authentication-methods/basic_auth.png"/></p>
<h3 id="pros">赞成的意见</h3>
<ul>
<li>因为没有太多的操作在进行，所以使用这种方法认证会更快。</li>
<li>容易实现。</li>
<li>所有主流浏览器都支持。</li>
</ul>
<h3 id="cons">骗局</h3>
<ul>
<li>Base64不同于加密。这只是表示数据的另一种方式。base64编码的字符串很容易被解码，因为它是以纯文本形式发送的。这种糟糕的安全特性需要多种类型的攻击。因此，HTTPS/SSL是绝对必要的。</li>
<li>每个请求都必须发送凭据。</li>
<li>用户只能通过用无效凭据重写凭据来注销。</li>
</ul>
<h3 id="packages">包装</h3>

<h3 id="code">密码</h3>
<p>使用<a href="https://github.com/miguelgrinberg/Flask-HTTPAuth"> Flask-HTTP </a>包可以在Flask中轻松完成基本的HTTP认证。</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">flask_httpauth</span> <span class="kn">import</span> <span class="n">HTTPBasicAuth</span>
<span class="kn">from</span> <span class="nn">werkzeug.security</span> <span class="kn">import</span> <span class="n">generate_password_hash</span><span class="p">,</span> <span class="n">check_password_hash</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">auth</span> <span class="o">=</span> <span class="n">HTTPBasicAuth</span><span class="p">()</span>

<span class="n">users</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"username"</span><span class="p">:</span> <span class="n">generate_password_hash</span><span class="p">(</span><span class="s2">"password"</span><span class="p">),</span>
<span class="p">}</span>


<span class="nd">@auth</span><span class="o">.</span><span class="n">verify_password</span>
<span class="k">def</span> <span class="nf">verify_password</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">username</span> <span class="ow">in</span> <span class="n">users</span> <span class="ow">and</span> <span class="n">check_password_hash</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"username"</span><span class="p">),</span> <span class="n">password</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">username</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/"</span><span class="p">)</span>
<span class="nd">@auth</span><span class="o">.</span><span class="n">login_required</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">"You have successfully logged in, </span><span class="si">{</span><span class="n">auth</span><span class="o">.</span><span class="n">current_user</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div>

<h3 id="resources">资源</h3>

<h2 id="http-digest-authentication">HTTP摘要认证</h2>
<p>HTTP摘要式身份验证(或摘要式访问身份验证)是HTTP基本身份验证的一种更安全的形式。主要区别在于密码是以MD5散列形式发送的，而不是以明文形式，因此它比基本Auth更安全。</p>
<h3 id="flow_1">流动</h3>
<ol>
<li>未经身份验证的客户端请求受限资源</li>
<li>服务器生成一个名为nonce的随机值，并发回一个HTTP 401未授权状态，带有一个带有值为<code>Digest</code>的<code>WWW-Authenticate</code>报头以及nonce: <code>WWW-Authenticate: Digest nonce="44f0437004157342f50f935906ad46fc"</code></li>
<li><code>WWW-Authenticate: Basic</code>标题使浏览器显示用户名和密码提示</li>
<li>在输入您的凭证之后，密码被散列，然后在每个请求的报头中与随机数一起发送:<code>Authorization: Digest username="username", nonce="16e30069e45a7f47b4e2606aeeb7ab62", response="89549b93e13d438cd0946c6d93321c52"</code></li>
<li>有了用户名，服务器就获得了密码，将密码和随机数一起散列，然后验证散列是否相同</li>
</ol>
<p><img data-src="/static/images/blog/web-authentication-methods/digest_auth.png" loading="lazy" class="lazyload" alt="http basic auth workflow" src="../Images/9037d80356254d882ab2a1cfa1aff8c1.png" data-original-src="https://testdriven.io/static/images/blog/web-authentication-methods/digest_auth.png"/></p>
<h3 id="pros_1">赞成的意见</h3>
<ul>
<li>比基本身份验证更安全，因为密码不是以纯文本形式发送的。</li>
<li>容易实现。</li>
<li>所有主流浏览器都支持。</li>
</ul>
<h3 id="cons_1">骗局</h3>
<ul>
<li>每个请求都必须发送凭据。</li>
<li>用户只能通过使用无效凭据重写凭据来注销。</li>
<li>与基本auth相比，密码在服务器上不太安全，因为bcrypt不能使用。</li>
<li>易受中间人攻击。</li>
</ul>
<h3 id="packages_1">包装</h3>

<h3 id="code_1">密码</h3>
<p><a href="https://github.com/miguelgrinberg/Flask-HTTPAuth"> Flask-HTTP </a>包也支持摘要HTTP认证。</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">flask_httpauth</span> <span class="kn">import</span> <span class="n">HTTPDigestAuth</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">"SECRET_KEY"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"change me"</span>
<span class="n">auth</span> <span class="o">=</span> <span class="n">HTTPDigestAuth</span><span class="p">()</span>

<span class="n">users</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"username"</span><span class="p">:</span> <span class="s2">"password"</span>
<span class="p">}</span>


<span class="nd">@auth</span><span class="o">.</span><span class="n">get_password</span>
<span class="k">def</span> <span class="nf">get_user</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">username</span> <span class="ow">in</span> <span class="n">users</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">users</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/"</span><span class="p">)</span>
<span class="nd">@auth</span><span class="o">.</span><span class="n">login_required</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">"You have successfully logged in, </span><span class="si">{</span><span class="n">auth</span><span class="o">.</span><span class="n">current_user</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div>

<h3 id="resources_1">资源</h3>

<h2 id="session-based-auth">基于会话的身份验证</h2>
<p>使用基于会话的身份验证(或会话cookie身份验证或基于cookie的身份验证)，用户的状态存储在服务器上。它不要求用户为每个请求提供用户名或密码。相反，在登录后，服务器会验证凭据。如果有效，它将生成一个会话，将其存储在会话存储中，然后将会话id发送回浏览器。浏览器将会话ID存储为cookie，每当向服务器发出请求时，就会发送该cookie。</p>
<p>基于会话的身份验证是有状态的。每当客户端请求服务器时，服务器必须在内存中定位会话，以便将会话ID绑定到相关用户。</p>
<h3 id="flow_2">流动</h3>
<p><img data-src="/static/images/blog/web-authentication-methods/session_auth.png" loading="lazy" class="lazyload" alt="http session auth workflow" src="../Images/6dd47a95130c6d8af0ecd7d86e3842e0.png" data-original-src="https://testdriven.io/static/images/blog/web-authentication-methods/session_auth.png"/></p>
<h3 id="pros_2">赞成的意见</h3>
<ul>
<li>更快的后续登录，因为不需要凭据。</li>
<li>改善了用户体验。</li>
<li>相当容易实现。许多框架(比如Django)都提供了开箱即用的特性。</li>
</ul>
<h3 id="cons_2">骗局</h3>
<ul>
<li>它是有状态的。服务器在服务器端跟踪每个会话。用于存储用户会话信息的会话存储需要跨多个服务共享，以实现身份验证。正因为如此，它不适合RESTful服务，因为REST是一种无状态协议。</li>
<li>Cookies会随每个请求一起发送，即使它不需要身份验证。</li>
<li>易受CSRF攻击。点击这里阅读更多关于CSRF以及如何预防它的信息。</li>
</ul>
<h3 id="packages_2">包装</h3>

<h3 id="code_2">密码</h3>
<p><a href="https://flask-login.readthedocs.io/"> Flask-Login </a>非常适合基于会话的认证。这个包负责登录、注销，并且可以在一段时间内记住用户。</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span>
<span class="kn">from</span> <span class="nn">flask_login</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">LoginManager</span><span class="p">,</span>
    <span class="n">UserMixin</span><span class="p">,</span>
    <span class="n">current_user</span><span class="p">,</span>
    <span class="n">login_required</span><span class="p">,</span>
    <span class="n">login_user</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">werkzeug.security</span> <span class="kn">import</span> <span class="n">generate_password_hash</span><span class="p">,</span> <span class="n">check_password_hash</span>


<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="n">SECRET_KEY</span><span class="o">=</span><span class="s2">"change_this_key"</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">login_manager</span> <span class="o">=</span> <span class="n">LoginManager</span><span class="p">()</span>
<span class="n">login_manager</span><span class="o">.</span><span class="n">init_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>


<span class="n">users</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"username"</span><span class="p">:</span> <span class="n">generate_password_hash</span><span class="p">(</span><span class="s2">"password"</span><span class="p">),</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">UserMixin</span><span class="p">):</span>
    <span class="o">...</span>


<span class="nd">@login_manager</span><span class="o">.</span><span class="n">user_loader</span>
<span class="k">def</span> <span class="nf">user_loader</span><span class="p">(</span><span class="n">username</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">username</span> <span class="ow">in</span> <span class="n">users</span><span class="p">:</span>
        <span class="n">user_model</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
        <span class="n">user_model</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">username</span>
        <span class="k">return</span> <span class="n">user_model</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/login"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s2">"POST"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login_page</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">get_json</span><span class="p">()</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"username"</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"password"</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">username</span> <span class="ow">in</span> <span class="n">users</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">check_password_hash</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">username</span><span class="p">),</span> <span class="n">password</span><span class="p">):</span>
            <span class="n">user_model</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
            <span class="n">user_model</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">username</span>
            <span class="n">login_user</span><span class="p">(</span><span class="n">user_model</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">"Wrong credentials"</span>
    <span class="k">return</span> <span class="s2">"logged in"</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/"</span><span class="p">)</span>
<span class="nd">@login_required</span>
<span class="k">def</span> <span class="nf">protected</span><span class="p">():</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">"Current user: </span><span class="si">{</span><span class="n">current_user</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">"</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div>

<h3 id="resources_2">资源</h3>

<h2 id="token-based-authentication">基于令牌的认证</h2>
<p>这种方法使用令牌而不是cookies来验证用户。用户使用有效凭据进行身份验证，服务器返回一个签名令牌。该令牌可用于后续请求。</p>
<p>最常用的令牌是一个<a href="https://jwt.io/"> JSON Web令牌</a> (JWT)。JWT由三部分组成:</p>
<ul>
<li>标头(包括令牌类型和使用的哈希算法)</li>
<li>有效负载(包括声明，即关于主题的陈述)</li>
<li>签名(用于验证消息没有被更改)</li>
</ul>
<p>所有这三个都是base64编码的，使用一个<code>.</code>连接起来并进行哈希处理。因为它们是编码的，任何人都可以解码和阅读信息。但是只有真实的用户才能产生有效的签名令牌。令牌使用签名进行身份验证，签名是用私钥签署的。</p>
<blockquote>
<p>JSON Web Token (JWT)是一种紧凑的、URL安全的方式，用于表示在双方之间传输的声明。JWT中的声明被编码为JSON对象，该对象被用作JSON Web签名(JWS)结构的有效载荷，或者被用作JSON Web加密(JWE)结构的明文，从而能够对声明进行数字签名或使用消息认证码(MAC)进行完整性保护和/或加密。- <a href="https://tools.ietf.org/html/rfc7519"> IETF </a></p>
</blockquote>
<p>令牌不需要保存在服务器端。他们可以通过他们的签名来验证。最近，由于RESTful APIs和单页面应用程序(spa)的兴起，令牌的采用有所增加。</p>
<h3 id="flow_3">流动</h3>
<p><img data-src="/static/images/blog/web-authentication-methods/token_auth.png" loading="lazy" class="lazyload" alt="token auth workflow" src="../Images/b5ad315e085457dc4fda914fddcc7452.png" data-original-src="https://testdriven.io/static/images/blog/web-authentication-methods/token_auth.png"/></p>
<h3 id="pros_3">赞成的意见</h3>
<ul>
<li>它是无国籍的。服务器不需要存储令牌，因为它可以使用签名进行验证。这使得请求更快，因为不需要数据库查找。</li>
<li>适合微服务架构，其中多个服务需要身份验证。我们在每一端需要配置的只是如何处理令牌和令牌秘密。</li>
</ul>
<h3 id="cons_3">骗局</h3>
<ul>
<li>根据令牌在客户端的保存方式，它可能会导致XSS(通过本地存储)或CSRF(通过cookies)攻击。</li>
<li>无法删除令牌。它们只能过期。这意味着，如果令牌泄露，攻击者可以滥用它，直到到期。因此，将令牌到期时间设置得很短很重要，比如15分钟。</li>
<li>刷新令牌需要设置为在到期时自动颁发令牌。</li>
<li>删除令牌的一种方法是创建一个用于将令牌列入黑名单的数据库。这给微服务架构增加了额外的开销，并引入了状态。</li>
</ul>
<h3 id="packages_3">包装</h3>

<h3 id="code_3">密码</h3>
<p><a href="https://github.com/vimalloc/flask-jwt-extended">烧瓶JWTs扩展</a>包为处理JWT提供了许多可能性。</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">jsonify</span>
<span class="kn">from</span> <span class="nn">flask_jwt_extended</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">JWTManager</span><span class="p">,</span>
    <span class="n">jwt_required</span><span class="p">,</span>
    <span class="n">create_access_token</span><span class="p">,</span>
    <span class="n">get_jwt_identity</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">werkzeug.security</span> <span class="kn">import</span> <span class="n">check_password_hash</span><span class="p">,</span> <span class="n">generate_password_hash</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="n">JWT_SECRET_KEY</span><span class="o">=</span><span class="s2">"please_change_this"</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">jwt</span> <span class="o">=</span> <span class="n">JWTManager</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

<span class="n">users</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"username"</span><span class="p">:</span> <span class="n">generate_password_hash</span><span class="p">(</span><span class="s2">"password"</span><span class="p">),</span>
<span class="p">}</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/login"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s2">"POST"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login_page</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"username"</span><span class="p">)</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"password"</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">username</span> <span class="ow">in</span> <span class="n">users</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">check_password_hash</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">username</span><span class="p">),</span> <span class="n">password</span><span class="p">):</span>
            <span class="n">access_token</span> <span class="o">=</span> <span class="n">create_access_token</span><span class="p">(</span><span class="n">identity</span><span class="o">=</span><span class="n">username</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">access_token</span><span class="o">=</span><span class="n">access_token</span><span class="p">),</span> <span class="mi">200</span>

    <span class="k">return</span> <span class="s2">"Wrong credentials"</span><span class="p">,</span> <span class="mi">400</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/"</span><span class="p">)</span>
<span class="nd">@jwt_required</span>
<span class="k">def</span> <span class="nf">protected</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">logged_in_as</span><span class="o">=</span><span class="n">get_jwt_identity</span><span class="p">()),</span> <span class="mi">200</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div>

<h3 id="resources_3">资源</h3>

<h2 id="one-time-passwords">一次性密码</h2>
<p>一次性密码(OTP)通常用作身份验证的确认。OTP是随机生成的代码，可用于验证用户是否是他们声称的那个人。它通常在利用双因素身份验证的应用程序的用户凭据得到验证后使用。</p>
<p>要使用OTP，必须存在可信系统。这个可信系统可以是经过验证的电子邮件或手机号码。</p>
<p>现代OTP是无状态的。可以使用多种方法来验证它们。虽然有几种不同类型的动态口令，但基于时间的动态口令(TOTPs)无疑是最常见的类型。一旦生成，它们会在一段时间后过期。</p>
<p>因为您获得了额外的安全层，所以建议将OTP用于涉及高度敏感数据的应用程序，如网上银行和其他金融服务。</p>
<h3 id="flow_4">流动</h3>
<p>实现OTP的传统方式是:</p>
<ul>
<li>客户端发送用户名和密码</li>
<li>在凭证验证之后，服务器生成随机代码，将其存储在服务器端，并将代码发送到可信系统</li>
<li>用户在可信系统上获取代码，并将其输入回web应用程序</li>
<li>服务器根据存储的代码验证该代码，并相应地授权访问</li>
</ul>
<p>TOTPs如何工作:</p>
<ul>
<li>客户端发送用户名和密码</li>
<li>在凭证验证之后，服务器使用随机生成的种子生成随机代码，将种子存储在服务器端，并将代码发送到可信系统</li>
<li>用户在可信系统上获取代码，并将其输入回web应用程序</li>
<li>服务器根据存储的种子验证代码，确保它没有过期，并相应地授予访问权限</li>
</ul>
<p>像<a href="https://en.wikipedia.org/wiki/Google_Authenticator"> Google Authenticator </a>、<a href="https://www.microsoft.com/en-us/account/authenticator">微软Authenticator </a>、<a href="https://en.wikipedia.org/wiki/FreeOTP"> FreeOTP </a>这样的OTP代理是如何工作的:</p>
<ul>
<li>注册双因素身份验证(2FA)后，服务器会生成一个随机种子值，并以唯一QR码的形式将该种子发送给用户</li>
<li>用户使用他们的2FA应用程序扫描QR码来验证可信设备</li>
<li>每当需要OTP时，用户就在他们的设备上检查代码，并在web应用程序上输入代码</li>
<li>服务器验证代码并相应地授权访问</li>
</ul>
<h3 id="pros_4">赞成的意见</h3>
<ul>
<li>增加一层额外的保护。</li>
<li>不存在被盗密码可用于也实现OTP的多个站点或服务的危险。</li>
</ul>
<h3 id="cons_4">骗局</h3>
<ul>
<li>您需要存储用于生成OTP的种子。</li>
<li>如果您丢失了恢复代码，像Google Authenticator这样的OTP代理很难再次设置。</li>
<li>当可信设备不可用时(电池没电、网络错误等)，问题就会出现。).因此，通常需要备份设备，这会增加额外的攻击媒介。</li>
</ul>
<h3 id="packages_4">包装</h3>

<h3 id="code_4">密码</h3>
<p>PyOTP包提供基于时间和基于计数器的OTP。</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

<span class="kn">import</span> <span class="nn">pyotp</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">otp</span> <span class="o">=</span> <span class="n">pyotp</span><span class="o">.</span><span class="n">TOTP</span><span class="p">(</span><span class="n">pyotp</span><span class="o">.</span><span class="n">random_base32</span><span class="p">())</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">otp</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"OTP generated: </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Verify OTP: </span><span class="si">{</span><span class="n">otp</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Verify after 30s: </span><span class="si">{</span><span class="n">otp</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>

<p>示例:</p>
<div class="codehilite"><pre><span/><code>OTP generated: <span class="m">474771</span>
Verify OTP: True
Verify after 30s: False
</code></pre></div>

<h3 id="resources_4">资源</h3>

<h2 id="oauth-and-openid">OAuth和OpenID</h2>
<p>OAuth/OAuth2和OpenID分别是授权和认证的流行形式。它们用于实现<a href="https://en.wikipedia.org/wiki/Social_login">社交登录</a>，这是一种形式的<a href="https://en.wikipedia.org/wiki/Single_sign-on">单点登录</a> (SSO)，使用来自脸书、推特或谷歌等社交网络服务的现有信息登录第三方网站，而不是专门为该网站创建新的登录帐户。</p>
<p>当您需要高度安全的身份验证时，可以使用这种类型的身份验证和授权。其中一些提供商有足够的资源投资于身份验证本身。利用这种久经考验的身份验证系统最终可以使您的应用程序更加安全。</p>
<p>这种方法通常与基于会话的身份验证结合使用。</p>
<h3 id="flow_5">流动</h3>
<p>您访问了一个要求您登录的网站。您导航到登录页面，看到一个名为“使用Google登录”的按钮。你点击按钮，它会把你带到谷歌登录页面。通过身份验证后，您会被重定向回自动让您登录的网站。这是一个使用OpenID进行身份验证的例子。它允许您使用现有帐户(通过OpenID提供者)进行身份验证，而无需创建新帐户。</p>
<p>最著名的OpenID提供商是谷歌、脸书、Twitter和GitHub。</p>
<p>登录后，您可以导航到网站内的下载服务，让您直接将大文件下载到Google Drive。网站是如何访问你的谷歌硬盘的？这就是OAuth发挥作用的地方。您可以授予访问其他网站上的资源的权限。在这种情况下，对Google Drive进行写访问。</p>
<h3 id="pros_5">赞成的意见</h3>
<ul>
<li>提高安全性。</li>
<li>由于无需创建和记住用户名或密码，登录流程更加简单快捷。</li>
<li>在安全漏洞的情况下，不会发生第三方损害，因为认证是无密码的。</li>
</ul>
<h3 id="cons_5">骗局</h3>
<ul>
<li>您的应用程序现在依赖于另一个应用程序，不受您的控制。如果OpenID系统关闭，用户将无法登录。</li>
<li>人们往往会忽略OAuth应用程序请求的权限。</li>
<li>在您配置的OpenID提供商上没有帐户的用户将无法访问您的应用程序。最好的方法是两者都实现——即用户名、密码和OpenID——并让用户选择。</li>
</ul>
<h3 id="packages_5">包装</h3>
<p>希望实现社交登录？</p>

<p>想运行自己的OAuth或OpenID服务吗？</p>

<h3 id="code_5">密码</h3>
<p>你可以用<a href="https://flask-dance.readthedocs.io/"> Flask-Dance </a>实现GitHub social auth。</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">url_for</span><span class="p">,</span> <span class="n">redirect</span>
<span class="kn">from</span> <span class="nn">flask_dance.contrib.github</span> <span class="kn">import</span> <span class="n">make_github_blueprint</span><span class="p">,</span> <span class="n">github</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">secret_key</span> <span class="o">=</span> <span class="s2">"change me"</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">"GITHUB_OAUTH_CLIENT_ID"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"1aaf1bf583d5e425dc8b"</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">"GITHUB_OAUTH_CLIENT_SECRET"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"dee0c5bc7e0acfb71791b21ca459c008be992d7c"</span>

<span class="n">github_blueprint</span> <span class="o">=</span> <span class="n">make_github_blueprint</span><span class="p">()</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">github_blueprint</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s2">"/login"</span><span class="p">)</span>


<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">"/"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">github</span><span class="o">.</span><span class="n">authorized</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s2">"github.login"</span><span class="p">))</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">github</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/user"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">resp</span><span class="o">.</span><span class="n">ok</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">"You have successfully logged in, </span><span class="si">{</span><span class="n">resp</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s1">'login'</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div>

<h3 id="resources_5">资源</h3>

<h2 id="conclusion">结论</h2>
<p>在本文中，我们研究了许多不同的web身份验证方法，它们都有各自的优缺点。</p>
<p>你应该在什么时候使用它们？看情况。基本经验法则:</p>
<ol>
<li>对于利用服务器端模板的web应用程序，通过用户名和密码进行基于会话的身份验证通常是最合适的。您也可以添加OAuth和OpenID。</li>
<li>对于RESTful APIs，基于令牌的认证是推荐的方法，因为它是无状态的。</li>
<li>如果您必须处理高度敏感的数据，您可能希望将OTP添加到您的授权流中。</li>
</ol>
<p>最后，请记住，所示的示例只是触及了表面。生产使用需要进一步配置。</p>
  </div>

  </div>    
</body>
</html>