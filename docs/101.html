<html>
<head>
<title>Python 3.10: What's New </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python 3.10:新特性</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/python310/#0001-01-01">https://testdriven.io/blog/python310/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>Python 3.10发布于<a href="https://www.python.org/downloads/release/python-3100/">2021年</a>10月4日。本文着眼于Python语言中最有趣的新增内容，这些内容将有助于使您的Python代码更加整洁:</p>
<ol>
<li>结构模式匹配</li>
<li>带括号的上下文管理器</li>
<li>更清晰的错误消息</li>
<li>改进的类型注释</li>
<li>拉链的严格论证</li>
</ol>



<h2 id="installing-python-310">安装Python 3.10</h2>
<p>如果您有Docker，您可以快速构建一个Python 3.10 shell来使用本文中的示例，如下所示:</p>
<div class="codehilite"><pre><span/><code>$ docker run -it --rm python:3.10
</code></pre></div>

<p>不用Docker？我们建议用<a href="https://github.com/pyenv/pyenv"> pyenv </a>安装Python 3.10:</p>


<p>从<a href="https://testdriven.io/blog/python-environments/#installing-python">Modern Python Environments-dependency and workspace management</a>文章中，您可以了解更多关于使用pyenv管理Python的信息。</p>
<h2 id="structural-pattern-matching">结构模式匹配</h2>
<p>在所有的新特性中，结构模式匹配最受关注，也是最有争议的。它在Python语言中引入了一个<code>match/case</code>语句，看起来非常像其他编程语言中的<code>switch/case</code>语句。使用结构模式匹配，您可以根据一个或多个模式测试对象，以确定比较对象的结构是否与给定的模式之一匹配。</p>
<p>快速示例:</p>
<div class="codehilite"><pre><span/><code><span class="n">code</span> <span class="o">=</span> <span class="mi">404</span>

<span class="k">match</span> <span class="n">code</span><span class="p">:</span>
    <span class="k">case</span> <span class="mi">200</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"OK"</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">404</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Not found"</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">500</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Server error"</span><span class="p">)</span>
    <span class="k">case</span> <span class="k">_</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Code not found"</span><span class="p">)</span>
</code></pre></div>

<p><a href="https://www.python.org/dev/peps/pep-0634/#id2">图案</a>可以是:</p>
<ol>
<li>文字</li>
<li>捕获</li>
<li>通配符</li>
<li>价值观念</li>
<li>组</li>
<li>顺序</li>
<li>绘图</li>
<li>班</li>
</ol>
<p>上面的例子使用了<a href="https://www.python.org/dev/peps/pep-0634/#literal-patterns">文字模式</a>。</p>
<p>想去掉这个例子中的幻数吗？像这样利用<a href="https://www.python.org/dev/peps/pep-0634/#value-patterns">值模式</a>:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">http</span> <span class="kn">import</span> <span class="n">HTTPStatus</span>

<span class="n">code</span> <span class="o">=</span> <span class="mi">404</span>

<span class="k">match</span> <span class="n">code</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">HTTPStatus</span><span class="o">.</span><span class="n">OK</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"OK"</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">HTTPStatus</span><span class="o">.</span><span class="n">NOT_FOUND</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Not found"</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">HTTPStatus</span><span class="o">.</span><span class="n">INTERNAL_SERVER_ERROR</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Server error"</span><span class="p">)</span>
    <span class="k">case</span> <span class="k">_</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Code not found"</span><span class="p">)</span>


<span class="c1"># =&gt; "Not found"</span>
</code></pre></div>

<p>您也可以使用<a href="https://www.python.org/dev/peps/pep-0634/#or-patterns">或模式</a>组合多个模式:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">http</span> <span class="kn">import</span> <span class="n">HTTPStatus</span>

<span class="n">code</span> <span class="o">=</span> <span class="mi">400</span>

<span class="k">match</span> <span class="n">code</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">HTTPStatus</span><span class="o">.</span><span class="n">OK</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"OK"</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">HTTPStatus</span><span class="o">.</span><span class="n">NOT_FOUND</span> <span class="o">|</span> <span class="n">HTTPStatus</span><span class="o">.</span><span class="n">BAD_REQUEST</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"You messed up"</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">HTTPStatus</span><span class="o">.</span><span class="n">INTERNAL_SERVER_ERROR</span> <span class="o">|</span> <span class="n">HTTPStatus</span><span class="o">.</span><span class="n">BAD_GATEWAY</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Our bad"</span><span class="p">)</span>
    <span class="k">case</span> <span class="k">_</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Code not found"</span><span class="p">)</span>


<span class="c1"># =&gt; "You messed up"</span>
</code></pre></div>

<p>结构化模式匹配与其他语言中的<code>switch/case</code>语法的不同之处在于，您可以解包复杂的数据类型，并基于结果数据执行操作:</p>
<div class="codehilite"><pre><span/><code><span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="k">match</span> <span class="n">point</span><span class="p">:</span>
    <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Origin"</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">case</span> <span class="k">_</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Not a point"</span><span class="p">)</span>


<span class="c1"># =&gt; Y=10</span>
</code></pre></div>

<p>这里，值(<code>10</code>)从主题(<code>(0, 10)</code>)绑定到案例内部的变量。这是<a href="https://www.python.org/dev/peps/pep-0634/#capture-patterns">捕获模式</a>。</p>
<p>你可以用<a href="https://www.python.org/dev/peps/pep-0634/#class-patterns">类模式</a>实现几乎同样的事情:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="k">match</span> <span class="n">point</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Origin"</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"On Y axis with Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"On X axis with X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Somewhere in a X, Y plane with X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">case</span> <span class="k">_</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Not a point"</span><span class="p">)</span>


<span class="c1"># =&gt; Somewhere in a X, Y plane with X=10, Y=10</span>
</code></pre></div>

<p>您可以使用<a href="https://www.python.org/dev/peps/pep-0634/#id1">保护符</a>来添加if子句，如下所示:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">match</span> <span class="n">point</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"The point is located on the diagonal Y=X at </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Point is not on the diagonal."</span><span class="p">)</span>

<span class="c1"># =&gt; Point is not on the diagonal.</span>
</code></pre></div>

<p>因此，当guard为<code>False</code>时，将评估下一个案例。</p>
<blockquote>
<p>值得注意的是，<code>match</code>和<code>case</code>是<a href="https://www.python.org/dev/peps/pep-0622/#backwards-compatibility">软关键字</a>，所以你仍然可以在你现有的代码中使用它们作为变量名。</p>
</blockquote>
<p>更多信息，请参考<a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-634-structural-pattern-matching">正式文件</a>以及相关pep:</p>
<ol>
<li><a href="https://www.python.org/dev/peps/pep-0622/"> PEP 622 -提案</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0634/"> PEP 634 -规格</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0635/"> PEP 635 -动机和基本原理</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0636/">人教版636 -教程</a></li>
</ol>
<h2 id="parenthesized-context-managers">带括号的上下文管理器</h2>
<p>使用上下文管理器时，Python现在支持跨多行的延续:</p>
<div class="codehilite"><pre><span/><code><span class="k">with</span> <span class="p">(</span>
    <span class="n">CtxManager1</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx1</span><span class="p">,</span>
    <span class="n">CtxManager2</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx2</span>
<span class="p">):</span>
</code></pre></div>

<p>在以前的版本中，你必须把所有东西都放在同一行或者嵌套<code>with</code>语句。</p>
<p>Python &lt; 3.10:</p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">mock</span>

<span class="kn">from</span> <span class="nn">my_module</span> <span class="kn">import</span> <span class="n">my_function</span>


<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">"my_module.secrets.token_urlsafe"</span><span class="p">)</span> <span class="k">as</span> <span class="n">a</span><span class="p">,</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">"my_module.string.capwords"</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">,</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">"my_module.collections.defaultdict"</span><span class="p">)</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">my_function</span><span class="p">()</span>
            <span class="n">a</span><span class="o">.</span><span class="n">assert_called</span><span class="p">()</span>
            <span class="n">b</span><span class="o">.</span><span class="n">assert_called</span><span class="p">()</span>
            <span class="n">c</span><span class="o">.</span><span class="n">assert_called</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_same</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">"my_module.secrets.token_urlsafe"</span><span class="p">)</span> <span class="k">as</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">"my_module.string.capwords"</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">"my_module.collections.defaultdict"</span><span class="p">)</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
                    <span class="n">my_function</span><span class="p">()</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">assert_called</span><span class="p">()</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">assert_called</span><span class="p">()</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">assert_called</span><span class="p">()</span>
</code></pre></div>

<p>Python &gt;= 3.10:</p>
<div class="codehilite"><pre><span/><code><span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="p">(</span>
            <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">"my_module.secrets.token_urlsafe"</span><span class="p">)</span> <span class="k">as</span> <span class="n">a</span><span class="p">,</span>
            <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">"my_module.string.capwords"</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">"my_module.collections.defaultdictl"</span><span class="p">)</span> <span class="k">as</span> <span class="n">c</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">my_function</span><span class="p">()</span>
            <span class="n">a</span><span class="o">.</span><span class="n">assert_called</span><span class="p">()</span>
            <span class="n">b</span><span class="o">.</span><span class="n">assert_called</span><span class="p">()</span>
            <span class="n">c</span><span class="o">.</span><span class="n">assert_called</span><span class="p">()</span>
</code></pre></div>

<p>值得注意的是，在Python 3.9中，Python切换到基于<a href="/blog/python39/#new-parser"> PEG </a>的解析器支持了这个特性。在可预见的未来，我们应该会在每个新的Python版本中看到像这样的新特性和变化，这<em>应该</em> (1)导致更优雅的语法和(2)让所有人感到不安。</p>
<p>更多信息:</p>
<ol>
<li><a href="https://docs.python.org/3.10/whatsnew/3.10.html#parenthesized-context-managers">发行说明</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0617/"> PEP-617 </a></li>
<li><a href="https://bugs.python.org/issue12782">原始bug </a></li>
</ol>
<h2 id="clearer-error-messages">更清晰的错误消息</h2>
<p>Python 3.10改进了错误消息，提供了关于错误和错误实际发生位置的更精确的信息。</p>
<p>例如，在Python 3.10之前，如果您缺少了一个右括号<code>}</code></p>
<div class="codehilite"><pre><span/><code><span class="kn">import</span> <span class="nn">datetime</span>

<span class="n">expected</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'Jan'</span><span class="p">,</span> <span class="s1">'Mike'</span><span class="p">,</span> <span class="s1">'Marry'</span><span class="p">,</span>

<span class="n">today</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
</code></pre></div>

<p>-您将看到以下错误消息:</p>
<div class="codehilite"><pre><span/><code>  File <span class="s2">"example.py"</span>, line <span class="m">5</span>
    <span class="nv">today</span> <span class="o">=</span> datetime.datetime.today<span class="o">()</span>
          ^
SyntaxError: invalid syntax
</code></pre></div>

<p>使用Python 3.10，您将看到:</p>
<div class="codehilite"><pre><span/><code>  <span class="n">File</span> <span class="s2">"example.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">3</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'Jan'</span><span class="p">,</span> <span class="s1">'Mike'</span><span class="p">,</span> <span class="s1">'Marry'</span><span class="p">,</span>
               <span class="o">^</span>
<span class="ne">SyntaxError</span><span class="p">:</span> <span class="s1">'{'</span> <span class="n">was</span> <span class="n">never</span> <span class="n">closed</span>
</code></pre></div>

<p>正如您所看到的，使用新的错误消息更容易发现实际问题。这对初学者特别有帮助，使其更容易识别错误的真正原因</p>
<ol>
<li>缺少关键字</li>
<li>不正确或拼写错误的关键字或变量名</li>
<li>缺少冒号</li>
<li>不正确的缩进</li>
<li>缺少右括号或大括号</li>
</ol>
<p>更多信息请参考<a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-634-structural-pattern-matching">官方文件</a>。</p>
<blockquote>
<p>看起来Python 3.11也将发布对错误消息的另一个<a href="https://docs.python.org/3.11/whatsnew/3.11.html#enhanced-error-locations-in-tracebacks">改进。</a></p>
</blockquote>
<h2 id="improved-type-annotations">改进的类型注释</h2>
<p>Python 3.10提供了许多与类型注释相关的改进:</p>
<ol>
<li>PEP 604:允许将联合类型写成X | Y</li>
<li>PEP 613:显式类型别名</li>
<li>PEP 647:用户定义的类型保护</li>
<li>PEP 612:参数规范变量</li>
</ol>
<h3 id="union-operator">联合运算符</h3>
<p>首先，您还可以使用一个新的类型联合操作符<code>|</code>，这样您就可以表示X或Y类型，而不必从<code>typing</code>模块导入<code>Union</code>:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># before</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="k">def</span> <span class="nf">sum_xy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>


<span class="c1"># after</span>
<span class="k">def</span> <span class="nf">sum_xy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div>

<p>更多信息:</p>
<ol>
<li><a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-604-new-type-union-operator">正式文件</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0604/"> PEP-604 </a></li>
</ol>
<h3 id="type-aliases">键入别名</h3>
<p>另一个好处是显式定义类型别名的能力。静态类型检查器和其他开发人员有时会在区分变量赋值和类型别名方面遇到问题。</p>
<p>例如:</p>
<div class="codehilite"><pre><span/><code><span class="n">StrCache</span> <span class="o">=</span> <span class="s2">"Cache[str]"</span>    <span class="c1"># a type alias</span>
<span class="n">LOG_PREFIX</span> <span class="o">=</span> <span class="s2">"LOG[DEBUG]"</span>  <span class="c1"># a module constant</span>
</code></pre></div>

<p>在Python 3.10中，可以使用<code>TypeAlias</code>显式定义类型别名:</p>
<div class="codehilite"><pre><span/><code><span class="n">StrCache</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="s2">"Cache[str]"</span>  <span class="c1"># a type alias</span>
<span class="n">LOG_PREFIX</span> <span class="o">=</span> <span class="s2">"LOG[DEBUG]"</span>           <span class="c1"># a module constant</span>
</code></pre></div>

<p>这将为类型检查者和阅读您代码的其他开发人员理清思路。</p>
<p>更多信息:</p>
<ol>
<li><a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-613-typealias">正式文件</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0613/"> PEP-613 </a></li>
</ol>
<h3 id="type-guards">防护类型</h3>
<p>类型保护有助于类型收缩，这是将类型从不太精确的类型(基于其定义)移动到更精确的类型(在程序的代码流中)的过程。</p>
<p>以下面两种风格的<code>is_employee</code>为例:</p>
<div class="codehilite"><pre><span/><code><span class="c1"># without type guards</span>
<span class="k">def</span> <span class="nf">is_employee</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">Employee</span><span class="p">)</span>


<span class="c1"># with type guards</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeGuard</span>

<span class="k">def</span> <span class="nf">is_employee</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="n">Employee</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">Employee</span><span class="p">)</span>
</code></pre></div>

<p>因此，使用第二种风格的<code>is_employee</code>，当它返回<code>True</code>时，类型检查器将能够把<code>user</code>从<code>User</code>缩小到<code>Employee</code>。</p>
<p>更多信息:</p>
<ol>
<li><a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-647-user-defined-type-guards">正式文件</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0647/"> PEP-647 </a></li>
</ol>
<h3 id="parameter-specification-variables">参数规格变量</h3>
<p>为了支持更高阶函数(例如decorators)的真正注释，Python 3.10增加了<code>typing.ParamSpec</code>和<code>typing.Concatenate</code>。</p>
<p>例如(从<a href="https://www.python.org/dev/peps/pep-0612/"> PEP-612 </a>):</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Awaitable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">TypeVar</span>


<span class="n">R</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">"R"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">add_logging</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">R</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Awaitable</span><span class="p">[</span><span class="n">R</span><span class="p">]]:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">log_to_database</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>


<span class="nd">@add_logging</span>
<span class="k">def</span> <span class="nf">takes_int_str</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">7</span>

<span class="k">await</span> <span class="n">takes_int_str</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">)</span>
<span class="k">await</span> <span class="n">takes_int_str</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># fails at runtime</span>
</code></pre></div>

<p>在这个例子中，当使用不正确的参数调用修饰函数时，您的代码将在运行时失败。</p>
<p>现在，您可以通过使用<code>typing.ParamSpec</code>来强制参数类型:</p>
<div class="codehilite"><pre><span/><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Awaitable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">TypeVar</span>


<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">"P"</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">"R"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">add_logging</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">Awaitable</span><span class="p">[</span><span class="n">R</span><span class="p">]]:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">log_to_database</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>


<span class="nd">@add_logging</span>
<span class="k">def</span> <span class="nf">takes_int_str</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">7</span>


<span class="k">await</span> <span class="n">takes_int_str</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">)</span> <span class="c1"># Accepted</span>
<span class="k">await</span> <span class="n">takes_int_str</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Correctly rejected by the type checker</span>
</code></pre></div>

<p>类型检查器，比如<a href="https://mypy.readthedocs.io/"> mypy </a>，会在分析代码时捕捉错误。</p>
<p>更多信息:</p>
<ol>
<li><a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-612-parameter-specification-variables">正式文件</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0612/"> PEP-612 </a></li>
</ol>
<h3 id="postponed-evaluation-of-annotations">注释的延期评估</h3>
<p>不是在函数定义时评估注释，注释的延迟评估建议将它们作为字符串保存在内置的__annotations__字典中。在运行时利用注释的工具将需要通过<code>typing.get_type_hints()</code>显式地评估注释，而不是依赖已经被评估的注释。</p>
<p>这原本是Python 3.10的一部分，但是由于Python的作用域规则，像<a href="https://pydantic-docs.helpmanual.io/"> pydantic </a>这样的工具很难利用<code>typing.get_type_hints()</code>来获得类型。所以，<a href="https://mail.python.org/archives/list/python-dev@python.org/thread/CLVXXPQ2T2LQ5MP2Y53VVQFCXYWQJHKZ/"> Python指导委员会</a>决定推迟改变。我们可能会在Python 3.11中看到。</p>
<p>更多信息:</p>
<ol>
<li><a href="https://realpython.com/python-news-april-2021/#pep-563-pep-649-and-the-future-of-python-type-annotations"> PEP 563，PEP 649，以及Python类型注释的未来</a></li>
<li><a href="https://github.com/samuelcolvin/pydantic/issues/2678">重要提示:PEP 563、PEP 649和pydantic的未来</a></li>
<li><a href="https://dev.to/tiangolo/the-future-of-fastapi-and-pydantic-is-bright-3pbm">FastAPI和Pydantic的未来一片光明</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0563/"> PEP-563 </a></li>
</ol>
<h2 id="strict-argument-for-zipping">拉链的严格论证</h2>
<p>当你试图<a href="https://docs.python.org/3/library/functions.html#zip">压缩</a>两个长度不同的可重复项时会发生什么？</p>
<div class="codehilite"><pre><span/><code><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Jan"</span><span class="p">,</span> <span class="s2">"Mike"</span><span class="p">,</span> <span class="s2">"Marry"</span><span class="p">,</span> <span class="s2">"Daisy"</span><span class="p">]</span>
<span class="n">grades</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"B+"</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="s2">"A+"</span><span class="p">]</span>

<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">grade</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">grades</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">grade</span><span class="p">)</span>

<span class="sd">"""</span>
<span class="sd">Jan B+</span>
<span class="sd">Mike A</span>
<span class="sd">Marry A+</span>
<span class="sd">"""</span>
</code></pre></div>

<p>当到达较短的iterable末尾时，迭代停止。</p>
<p>Python 3.10引入了一个新的<code>strict</code>关键字参数，以确保在运行时所有的iterables都具有相同的长度:</p>
<div class="codehilite"><pre><span/><code><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Jan"</span><span class="p">,</span> <span class="s2">"Mike"</span><span class="p">,</span> <span class="s2">"Marry"</span><span class="p">,</span> <span class="s2">"Daisy"</span><span class="p">]</span>
<span class="n">grades</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"B+"</span><span class="p">,</span> <span class="s2">"A"</span><span class="p">,</span> <span class="s2">"A+"</span><span class="p">]</span>

<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">grade</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">grades</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">grade</span><span class="p">)</span>

<span class="c1"># ValueError: zip() argument 2 is shorter than argument 1</span>
</code></pre></div>

<p>参考<a href="https://www.python.org/dev/peps/pep-0618/"> PEP-618 </a>了解更多信息。</p>
<h2 id="additional-updates-and-optimizations">其他更新和优化</h2>
<p><a href="https://docs.python.org/3/library/distutils.html"> distutils </a>包是<a href="https://docs.python.org/3.10/whatsnew/3.10.html#distutils">弃用的</a>，将在Python 3.12中被完全移除。其功能存在于<a href="https://github.com/pypa/setuptools">设置工具</a>和<a href="https://github.com/pypa/packaging">包装</a>中。</p>
<p>最后，Python 3.10引入了几个导致性能提高的<a href="https://docs.python.org/3.10/whatsnew/3.10.html#optimizations">优化</a>。对于小对象，构造函数<code>str()</code>、<code>bytes()</code>和<code>bytearray()</code>要快30%到40% <a href="https://bugs.python.org/issue41334">。</a><a href="https://docs.python.org/3/library/runpy.html"> runpy </a>模块现在导入更少的模块，所以<code>python -m module-name</code>平均快1.4倍。</p>
<h2 id="conclusion">结论</h2>
<p>如您所见，Python 3.10带来了许多新特性。一些旧的，很少使用的功能已经贬值或完全删除。本文只是简单介绍了该语言的新特性和变化。请务必查看所有更改的官方发行说明:<a href="https://docs.python.org/3.10/whatsnew/3.10.html">Python 3.10中的新特性</a>。</p>
<p>快乐的蟒蛇！</p>
  </div>

  </div>    
</body>
</html>