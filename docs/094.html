<html>
<head>
<title>Deploying Self-Hosted GitLab CI Runners with Docker </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Docker部署自托管GitLab CI运行程序</h1>
<blockquote>原文：<a href="https://testdriven.io/blog/gitlab-ci-docker/#0001-01-01">https://testdriven.io/blog/gitlab-ci-docker/#0001-01-01</a></blockquote><div><div class="blog-content long-content" data-local-nav-source="">
    <p>在本教程中，我们将详细介绍如何使用Docker将自托管的<a href="https://docs.gitlab.com/ee/ci/"> GitLab CI/CD </a>运行程序部署到<a href="https://www.digitalocean.com/">数字海洋</a>。</p>



<h2 id="gitlab-cicd">GitLab CI/CD</h2>
<p><a href="https://docs.gitlab.com/ee/ci/"> GitLab CI/CD </a>是一个持续集成和交付(CI/CD)解决方案，与GitLab完全集成。GitLab CI/CD管道中的作业在称为runners的进程上运行。你既可以使用GitLab托管的共享运行器，也可以在自己的基础设施上运行自己的<a href="https://docs.gitlab.com/runner/install/">自托管运行器</a>。</p>
<h3 id="scope">范围</h3>
<p>Runners可以对GitLab实例中的所有项目和组可用，也可以对特定的组或特定的项目(存储库)可用。我们将使用第一种方法，这样我们可以用同一个运行器处理来自多个存储库的作业。</p>
<p>您还可以使用<a href="https://docs.gitlab.com/ee/ci/runners/configure_runners.html#use-tags-to-control-which-jobs-a-runner-can-run">标签</a>来控制运行程序可以运行哪些作业。</p>
<blockquote>
<p>关于跑步者范围的更多信息，请看官方文件中的<a href="https://docs.gitlab.com/ee/ci/runners/runners_scope.html">跑步者范围</a>。</p>
</blockquote>
<h3 id="docker">码头工人</h3>
<p>因为您可能想在工作中运行<code>docker</code>命令——构建和测试Docker容器中运行的应用程序——所以您需要选择以下三种方法之一:</p>
<ol>
<li><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-the-shell-executor">外壳执行器</a></li>
<li><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-the-docker-executor-with-the-docker-image-docker-in-docker">码头工人</a></li>
<li><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-socket-binding">套接字绑定</a></li>
</ol>
<p>我们将使用套接字绑定方法(Docker-out-of-Docker？)将对接插座捆绑安装到具有容积的容器上。运行GitLab runner的容器将能够与Docker守护进程通信，从而产生兄弟容器。</p>
<blockquote>
<p>虽然我对这些方法没有什么强烈的意见，但我还是推荐阅读<a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">为您的CI或测试环境使用Docker-in-Docker？三思而后行。</a>作者jérme Petazzoni，Docker-in-Docker的创造者。</p>
<p>如果你对Docker-in-Docker方法感兴趣，可以看看定制的Gitlab CI/CD Runner，用Docker-in-Docker 进行高速缓存。</p>
</blockquote>
<h2 id="digitalocean-setup">数字海洋设置</h2>
<p>首先，<a href="https://m.do.co/c/d8f211a4b4c2">注册</a>一个数字海洋账户，如果你还没有的话，然后<a href="https://www.digitalocean.com/docs/apis-clis/api/">生成</a>一个访问令牌，这样你就可以访问数字海洋API。</p>
<p>将令牌添加到您的环境中:</p>
<div class="codehilite"><pre><span/><code>$ <span class="nb">export</span> <span class="nv">DIGITAL_OCEAN_ACCESS_TOKEN</span><span class="o">=[</span>your_digital_ocean_token<span class="o">]</span>
</code></pre></div>

<p>安装<a href="https://docs.docker.com/machine/install-machine/"> Docker Machine </a>如果你的本地机器上还没有的话。</p>
<p>旋转出一个叫做<code>runner-node</code>的小液滴:</p>
<div class="codehilite"><pre><span/><code>$ docker-machine create <span class="se">\</span>
    --driver digitalocean <span class="se">\</span>
    --digitalocean-access-token <span class="nv">$DIGITAL_OCEAN_ACCESS_TOKEN</span> <span class="se">\</span>
    --digitalocean-region <span class="s2">"nyc1"</span> <span class="se">\</span>
    --digitalocean-image <span class="s2">"debian-10-x64"</span> <span class="se">\</span>
    --digitalocean-size <span class="s2">"s-4vcpu-8gb"</span> <span class="se">\</span>
    --engine-install-url <span class="s2">"https://releases.rancher.com/install-docker/19.03.9.sh"</span> <span class="se">\</span>
    runner-node<span class="p">;</span>
</code></pre></div>

<h2 id="docker-deployment">Docker部署</h2>
<p>SSH进入droplet:</p>
<div class="codehilite"><pre><span/><code>$ docker-machine ssh runner-node
</code></pre></div>

<p>创建以下文件和文件夹:</p>
<div class="codehilite"><pre><span/><code>├── config
│   └── config.toml
└── docker-compose.yml
</code></pre></div>

<p>将以下内容添加到<em> docker-compose.yml </em>文件中:</p>
<div class="codehilite"><pre><span/><code><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">'3'</span><span class="w"/>

<span class="nt">services</span><span class="p">:</span><span class="w"/>
<span class="w">  </span><span class="nt">gitlab-runner-container</span><span class="p">:</span><span class="w"/>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">gitlab/gitlab-runner:v14.3.2</span><span class="w"/>
<span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">gitlab-runner-container</span><span class="w"/>
<span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">always</span><span class="w"/>
<span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">./config/:/etc/gitlab-runner/</span><span class="w"/>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/var/run/docker.sock:/var/run/docker.sock</span><span class="w"/>
</code></pre></div>

<p>在此，我们:</p>
<ol>
<li>使用了官方<a href="https://hub.docker.com/r/gitlab/gitlab-runner"> GitLab Runner Docker图片</a>。</li>
<li>增加了Docker套接字和“配置”文件夹的容量。</li>
<li>将端口9252暴露给Docker主机。稍后会有更多内容。</li>
</ol>
<p>按照<a href="https://docs.docker.com/compose/install/">官方安装指南</a>在droplet上下载并安装Docker Compose，然后旋转容器:</p>


<blockquote>
<p>如果您遇到Docker编写挂起的问题，请查看这个堆栈溢出问题。</p>
</blockquote>
<p>接下来，您需要获得注册令牌和URL。在您小组的“CI/CD设置”中，展开“跑步者”部分。一定要禁用共享跑步者。</p>
<p><img data-src="/static/images/blog/gitlab-ci-docker/register_runner.png" loading="lazy" class="lazyload" alt="GitLab CI Register Runner" src="../Images/c88823f5327b2de98b75c613a4ca755d.png" data-original-src="https://testdriven.io/static/images/blog/gitlab-ci-docker/register_runner.png"/></p>
<p>运行以下命令来注册一个新的跑步者，确保用您的组的注册令牌和URL替换<code>&lt;YOUR-GITLAB-REGISTRATION-TOKEN&gt;</code>和<code>&lt;YOUR-GITLAB-URL&gt;</code>:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose <span class="nb">exec</span> gitlab-runner-container <span class="se">\</span>
    gitlab-runner register <span class="se">\</span>
    --non-interactive <span class="se">\</span>
    --url &lt;YOUR-GITLAB-URL&gt; <span class="se">\</span>
    --registration-token &lt;YOUR-GITLAB-REGISTRATION-TOKEN&gt; <span class="se">\</span>
    --executor docker <span class="se">\</span>
    --description <span class="s2">"Sample Runner 1"</span> <span class="se">\</span>
    --docker-image <span class="s2">"docker:stable"</span> <span class="se">\</span>
    --docker-volumes /var/run/docker.sock:/var/run/docker.sock
</code></pre></div>

<p>您应该会看到类似如下的内容:</p>
<div class="codehilite"><pre><span/><code>Runtime platform
<span class="nv">arch</span><span class="o">=</span>amd64 <span class="nv">os</span><span class="o">=</span>linux <span class="nv">pid</span><span class="o">=</span><span class="m">18</span> <span class="nv">revision</span><span class="o">=</span>e0218c92 <span class="nv">version</span><span class="o">=</span><span class="m">14</span>.3.2

Running <span class="k">in</span> system-mode.

Registering runner... succeeded
<span class="nv">runner</span><span class="o">=</span>hvdSfcc1

Runner registered successfully. Feel free to start it, but <span class="k">if</span> it<span class="err">'</span>s running already
the config should be automatically reloaded!
</code></pre></div>

<p>同样，我们使用了<a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-socket-binding"> docker套接字绑定方法</a>，以便<code>docker</code>命令可以在运行于runner上的作业内部运行。</p>
<blockquote>
<p>查看<a href="https://docs.gitlab.com/runner/commands/"> GitLab Runner命令</a>以了解更多关于<code>register</code>命令以及注册和管理跑步者的其他命令。</p>
</blockquote>
<p>回到GitLab，您应该会在您小组的“CI/CD设置”中看到已注册的跑步者:</p>
<p><img data-src="/static/images/blog/gitlab-ci-docker/available_runners.png" loading="lazy" class="lazyload" alt="GitLab CI Runners" src="../Images/c4e4da732887b15168c449f521cc2c12.png" data-original-src="https://testdriven.io/static/images/blog/gitlab-ci-docker/available_runners.png"/></p>
<p>通过为您的一个存储库运行CI/CD管道来测试它。</p>
<p>回到您的终端，查看一下集装箱日志:</p>
<div class="codehilite"><pre><span/><code>$ docker logs gitlab-runner-container -f
</code></pre></div>

<p>您应该会看到作业的状态:</p>
<div class="codehilite"><pre><span/><code>Checking <span class="k">for</span> jobs... received
<span class="nv">job</span><span class="o">=</span><span class="m">1721313345</span> <span class="nv">repo_url</span><span class="o">=</span>https://gitlab.com/testdriven/testing-gitlab-ci.git <span class="nv">runner</span><span class="o">=</span>yK2DqWMQ

Job succeeded
<span class="nv">duration_s</span><span class="o">=</span><span class="m">32</span>.174537956 <span class="nv">job</span><span class="o">=</span><span class="m">1721313345</span> <span class="nv">project</span><span class="o">=</span><span class="m">30721568</span> <span class="nv">runner</span><span class="o">=</span>yK2DqWMQ
</code></pre></div>

<h2 id="configuration">配置</h2>
<p>记下配置文件<em> config/config.toml </em>:</p>
<div class="codehilite"><pre><span/><code>$ cat config/config.toml

<span class="nv">concurrent</span> <span class="o">=</span> <span class="m">1</span>
<span class="nv">check_interval</span> <span class="o">=</span> <span class="m">0</span>

<span class="o">[</span>session_server<span class="o">]</span>
  <span class="nv">session_timeout</span> <span class="o">=</span> <span class="m">1800</span>

<span class="o">[[</span>runners<span class="o">]]</span>
  <span class="nv">name</span> <span class="o">=</span> <span class="s2">"Sample Runner 1"</span>
  <span class="nv">url</span> <span class="o">=</span> <span class="s2">"https://gitlab.com/"</span>
  <span class="nv">token</span> <span class="o">=</span> <span class="s2">"yK2DqWMQB1CqPsRx6gwn"</span>
  <span class="nv">executor</span> <span class="o">=</span> <span class="s2">"docker"</span>
  <span class="o">[</span>runners.custom_build_dir<span class="o">]</span>
  <span class="o">[</span>runners.cache<span class="o">]</span>
    <span class="o">[</span>runners.cache.s3<span class="o">]</span>
    <span class="o">[</span>runners.cache.gcs<span class="o">]</span>
    <span class="o">[</span>runners.cache.azure<span class="o">]</span>
  <span class="o">[</span>runners.docker<span class="o">]</span>
    <span class="nv">tls_verify</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="nv">image</span> <span class="o">=</span> <span class="s2">"docker:stable"</span>
    <span class="nv">privileged</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="nv">disable_entrypoint_overwrite</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="nv">oom_kill_disable</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="nv">disable_cache</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="nv">volumes</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"/var/run/docker.sock:/var/run/docker.sock"</span>, <span class="s2">"/cache"</span><span class="o">]</span>
    <span class="nv">shm_size</span> <span class="o">=</span> <span class="m">0</span>
</code></pre></div>

<blockquote>
<p>查看<a href="https://docs.gitlab.com/runner/configuration/advanced-configuration.html">高级配置</a>，了解更多可用选项。您可以配置许多东西，例如日志和缓存选项、内存限制和CPU数量等等。</p>
</blockquote>
<p>因为我们没有利用外部缓存，比如亚马逊S3或谷歌云存储，所以删除<code>[runners.cache]</code>部分。然后，重新启动转轮:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose <span class="nb">exec</span> gitlab-runner-container gitlab-runner restart
</code></pre></div>

<p>尝试同时运行两个作业。由于并发性设置为1 - <code>concurrent = 1</code> -在运行器上一次只能运行一个作业。因此，其中一个作业将保持“挂起”状态，直到第一个作业完成运行。如果您只是为一个小团队设置跑步者，那么您也许可以一次只运行一个任务。随着团队的成长，您会想要尝试并发配置选项:</p>
<ol>
<li><code>concurrent</code> -限制在所有运行程序中全局同时运行的作业数量。</li>
<li><code>limit</code> -适用于单个跑步者，限制可同时处理的工作数量。默认为<code>0</code>，表示不应用限制。</li>
<li><code>request_concurrency</code> -适用于单个跑步者，限制新工作的并发请求数量。默认为<code>1</code>。</li>
</ol>
<p>在我们更新并发选项之前，添加一个新的runner:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose <span class="nb">exec</span> gitlab-runner-container <span class="se">\</span>
    gitlab-runner register <span class="se">\</span>
    --non-interactive <span class="se">\</span>
    --url &lt;YOUR-GITLAB-URL&gt; <span class="se">\</span>
    --registration-token &lt;YOUR-GITLAB-REGISTRATION-TOKEN&gt; <span class="se">\</span>
    --executor docker <span class="se">\</span>
    --description <span class="s2">"Sample Runner 2"</span> <span class="se">\</span>
    --docker-image <span class="s2">"docker:stable"</span> <span class="se">\</span>
    --docker-volumes /var/run/docker.sock:/var/run/docker.sock
</code></pre></div>

<p>然后，像这样更新<em> config/config.toml </em>:</p>
<div class="codehilite"><pre><span/><code><span class="n">concurrent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w">                </span><span class="c1"># NEW</span><span class="w"/>
<span class="n">check_interval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"/>

<span class="k">[session_server]</span><span class="w"/>
<span class="w">  </span><span class="n">session_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1800</span><span class="w"/>

<span class="k">[[runners]]</span><span class="w"/>
<span class="w">  </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Sample Runner 1"</span><span class="w"/>
<span class="w">  </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"https://gitlab.com/"</span><span class="w"/>
<span class="w">  </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"yK2DqWMQB1CqPsRx6gwn"</span><span class="w"/>
<span class="w">  </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"docker"</span><span class="w"/>
<span class="w">  </span><span class="n">limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">                   </span><span class="c1"># NEW</span><span class="w"/>
<span class="w">  </span><span class="n">request_concurrency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">     </span><span class="c1"># NEW</span><span class="w"/>
<span class="w">  </span><span class="k">[runners.custom_build_dir]</span><span class="w"/>
<span class="w">  </span><span class="k">[runners.docker]</span><span class="w"/>
<span class="w">    </span><span class="n">tls_verify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"docker:stable"</span><span class="w"/>
<span class="w">    </span><span class="n">privileged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">disable_entrypoint_overwrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">oom_kill_disable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">disable_cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">volumes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">"/var/run/docker.sock:/var/run/docker.sock"</span><span class="p">,</span><span class="w"> </span><span class="s">"/cache"</span><span class="p">]</span><span class="w"/>
<span class="w">    </span><span class="n">shm_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"/>

<span class="k">[[runners]]</span><span class="w"/>
<span class="w">  </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Sample Runner 2"</span><span class="w"/>
<span class="w">  </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"https://gitlab.com/"</span><span class="w"/>
<span class="w">  </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"qi-b3gFzVaX3jRRskJbz"</span><span class="w"/>
<span class="w">  </span><span class="n">limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">                 </span><span class="c1"># NEW</span><span class="w"/>
<span class="w">  </span><span class="n">request_concurrency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">   </span><span class="c1"># NEW</span><span class="w"/>
<span class="w">  </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"docker"</span><span class="w"/>
<span class="w">  </span><span class="k">[runners.custom_build_dir]</span><span class="w"/>
<span class="w">  </span><span class="k">[runners.cache]</span><span class="w"/>
<span class="w">    </span><span class="k">[runners.cache.s3]</span><span class="w"/>
<span class="w">    </span><span class="k">[runners.cache.gcs]</span><span class="w"/>
<span class="w">    </span><span class="k">[runners.cache.azure]</span><span class="w"/>
<span class="w">  </span><span class="k">[runners.docker]</span><span class="w"/>
<span class="w">    </span><span class="n">tls_verify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"docker:stable"</span><span class="w"/>
<span class="w">    </span><span class="n">privileged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">disable_entrypoint_overwrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">oom_kill_disable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">disable_cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"/>
<span class="w">    </span><span class="n">volumes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">"/var/run/docker.sock:/var/run/docker.sock"</span><span class="p">,</span><span class="w"> </span><span class="s">"/cache"</span><span class="p">]</span><span class="w"/>
<span class="w">    </span><span class="n">shm_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"/>
</code></pre></div>

<p>现在，我们可以跨两个运行程序同时运行四个作业，每个运行程序有两个子流程:</p>
<p><img data-src="/static/images/blog/gitlab-ci-docker/runners.png" loading="lazy" class="lazyload" alt="GitLab CI Runners" src="../Images/dec14989a7c41ec69ea761ba19adb250.png" data-original-src="https://testdriven.io/static/images/blog/gitlab-ci-docker/runners.png"/></p>
<p>重新启动:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose <span class="nb">exec</span> gitlab-runner-container gitlab-runner restart
</code></pre></div>

<p><img data-src="/static/images/blog/gitlab-ci-docker/available_runners2.png" loading="lazy" class="lazyload" alt="GitLab CI Runners" src="../Images/651f61202a59bf1b847f57d26be109d8.png" data-original-src="https://testdriven.io/static/images/blog/gitlab-ci-docker/available_runners2.png"/></p>
<p>通过运行四个作业来测试它。</p>
<p>请记住，如果您正在构建和测试Docker映像，您最终会耗尽磁盘空间。因此，定期删除Docker主机上所有未使用的图像和容器是一个好主意。</p>
<p>Example crontab:</p>
<div class="codehilite"><pre><span/><code><span class="nv">@weekly</span><span class="w"> </span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">docker</span><span class="w"> </span><span class="k">system</span><span class="w"> </span><span class="n">prune</span><span class="w"> </span><span class="o">-</span><span class="n">f</span><span class="w"/>
</code></pre></div>

<p>--</p>
<p>就是这样！</p>
<p>不要忘记注销跑步者:</p>
<div class="codehilite"><pre><span/><code>$ docker-compose <span class="nb">exec</span> gitlab-runner-container gitlab-runner unregister --all-runners
</code></pre></div>

<p>然后，回到您的本地机器，关闭机器/droplet:</p>
<div class="codehilite"><pre><span/><code>$ docker-machine rm runner-node
</code></pre></div>
  </div>

  </div>    
</body>
</html>